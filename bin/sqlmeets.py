import reimport numpy as npimport operatorfrom datetime import datefrom peewee import *import os, urlparseimport heapqimport time as Timefrom sympy import binomialfrom swimdb import Swim, HSSwim, Improvement, TeamMeet, TeamSeason, SwimmerpointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]eventsDualS = ["200 Yard Medley Relay","1000 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsDualL = ["400 Yard Medley Relay","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","400 Yard Individual Medley","400 Yard Freestyle Relay"]eventsChamp = ["400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsChamp3 = ['1 mtr Diving','200 Yard Freestyle Relay','','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','','400 Yard Medley Relay','','400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','800 Yard Freestyle Relay','','1650 Yard Freestyle','','200 Yard Medley Relay','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','','400 Yard Freestyle Relay','3 mtr Diving']eventsDay1 = ['1 mtr Diving','200 Yard Freestyle Relay','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','400 Yard Medley Relay']eventsDay2 = ['400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','800 Yard Freestyle Relay']eventsDay3 = ['1650 Yard Freestyle','200 Yard Medley Relay','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','400 Yard Freestyle Relay','3 mtr Diving']allEvents={"400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay",'1000 Yard Freestyle','100 Yard Breastroke','200 Yard Breastroke'}eventsHS = ["200 Yard Medley Relay","200 Yard Individual Medley","200 Yard Freestyle","50 Yard Freestyle","1 mtr Diving","100 Yard Butterfly","100 Yard Freestyle","500 Yard Freestyle","200 Yard Freestyle Relay","100 Yard Backstroke","100 Yard Breastroke","400 Yard Freestyle Relay"]MIAC = ["Carleton","Augsburg","St. Olaf","Saint Mary's MN","Macalester","Gustavus","Saint Benedict","St. Kate's","Concordia","St. John's","St. Thomas","Hamline"]requiredEvents={"200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly"}eventOrder = ["50 Yard Freestyle","100 Yard Freestyle","200 Yard Freestyle","500 Yard Freestyle","1000 Yard Freestyle","1650 Yard Freestyle","100 Yard Butterfly","200 Yard Butterfly","100 Yard Backstroke","200 Yard Backstroke","100 Yard Breastroke","200 Yard Breastroke","200 Yard Individual Medley","400 Yard Individual Medley","200 Yard Medley Relay","400 Yard Medley Relay","200 Yard Freestyle Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay"]#setup database connectiondb_proxy = Proxy()db = Proxy()swimDatabase = None#make time look nicedef swimTime(time):	(seconds, point) = re.split("\.", str(time))	if int(seconds) < 60:		time = round(time, 2)		time = str(time)		while len(time) < 5:			time += '0'		return time	minutes = str(int(seconds) / 60)	seconds = str(int(seconds) % 60)	while len(seconds) < 2:		seconds = '0' + seconds	while len(point) < 2:		point = point + '0'	return  minutes + ":" + seconds + "." + point[:2]#convers to a time in secondsdef toTime(time):	if time[0]=="X" or time[0]=="x":		time=time[1:]	if re.match(".*:.*",time) == None:		return float(time)	return float(re.split(":",time)[0])*60 +float(re.split(":",time)[1])'''sees if one list contains another'''def contains(small, big):	for i in small:		if not i in big:			return False	return True'''events contained within a relay'''def relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']def thisSeason():	today = date.today()	if today.month > 6:		return today.year + 1	return today.yeardef rejectOutliers(data, l=5, r=6):	u = np.mean(data)	s = np.std(data)	newList = [i for i in data if (u - l*s < i < u + r*s)]	print swimTime(max(data)), swimTime(min(data))	print "Num rejected: " + str(len(data)-len(newList))	return newListdef ECDF(data):	def cdf(num):		d = data		l = float(len(d))		return (sum(1 for i in d if i < num) + sum(.5 for i in d if i==num))/l	return cdf'''stores a team's data'''class Team:	def __init__(self, name, database):		self.database = database		self.name = name		if self.name in database.teamMeets:			self.meets = database.teamMeets[self.name]		else:			self.meets = {}		self.topRelays = {}		self.swimmers = {}		self.relays = {}		self.topDuals = {} #cache top duals		self.averageImprovement = {}		self.averageTaper = None		self.totalAverageImprovement = None	def topDual(self, season, debug=False, includeEvents=requiredEvents, gender='Men'):		if debug: print self.name, self.meets		if season in self.topDuals:			if debug: print 'cached'			return self.topDuals[season]		#now we will swim the season's meets against each other		topMeet = None		if not season in self.meets:			return None		for meetName in self.meets[season]:			meet = Meet(meetName, gender=gender, teams=[self.name])  # this will actually load the data			if not meet.isDual():				continue			if debug:				print 'testing ' + meet.name			if not topMeet:				topMeet = meet				continue			result = self.database.swimMeet([[self.name, topMeet, 'old'], [self.name, meet, 'new']],									   includeEvents=includeEvents, selectEvents=True)  # token names			score = result.teamScores()			if debug:				print score				result.printout()			if score and score[0][0]=='new':				topMeet = meet			meet.reset(teams=True)			topMeet.reset(teams=True)		if not topMeet:			self.topDuals[season] = None			return None		self.topDuals[season] = topMeet		if debug: print 'top '+ self.topDuals[season].name		return self.topDuals[season]	def __str__(self):		return self.name	def __eq__(self, s):		if self.name == s:			return True		if not type(s)==type(self): return False #not called on a season		return self.name==s.name	def __hash__(self):		return hash(self.name)'''this class contains a swim meetscores itself'''class Meet:	def __init__(self, name=None, events=list(allEvents), gender=None, topSwim=True, teams=None, season=None):		self.gender = gender  # None means both		self.teams = []  # teams added as swims are		self.scores = None		self.eventSwims = {}		if type(allEvents) != list:			events = list(events)		self.events = events		self.name = name  # named meets are ones that actually happened		self.date = None		self.season = None		if isinstance(teams, basestring):			teams = [teams]		if not gender:			genders = ['Men', 'Women']		else:			genders = [gender]		if self.name:			query = Swim.select().where(Swim.meet==name, Swim.gender << genders, Swim.event << events)			if teams:				query = query.select().where(Swim.team << teams)			if season:				query = query.select().where(Swim.season==season)			if topSwim:				query = query.select(Swim.name, Swim.event, Swim.team, Swim.gender, fn.Min(Swim.time)).group_by(					Swim.name, Swim.event, Swim.team, Swim.gender)			for swim in query:				if topSwim:					swim.time = swim.min					swim.meet = name				self.addSwim(swim)	def reset(self, teams=False, times=False):		for swim in self.getSwims():			if teams:				swim.scoreTeam = None			if times:				swim.scoreTime = None	#sees if any swims are in the meet	def isEmpty(self):		for event in self.eventSwims:			if not self.eventSwims[event]==[]:				return False		return True	def isDual(self):		return len(self.teams) == 2	def getSwims(self, team='all', relays=True, splits=False, ind=True):		swims=set()		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if ind and (swim.team == str(team) or team=='all') and (relays or not swim.relay):					swims.add(swim)				if splits and swim.relay and (team=='all' or swim.team == str(team)):					for split in swim.swims:						swims.add(split)		return swims	def addSwim(self, swim):		if not swim.getScoreTeam() in self.teams:			self.teams.append(swim.getScoreTeam())		if self.name and not self.date or not self.season:  # without a name, its a dummy meet			self.date=swim.date			self.season=swim.season		if not swim.event in self.eventSwims:			self.eventSwims[swim.event] = []		self.eventSwims[swim.event].append(swim)	def addSwims(self, swims):		for swim in swims:			self.addSwim(swim)	def removeSwimmer(self, name):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.name==name:					self.eventSwims[event].remove(swim)	def getEvents(self, events=''):		myEvents = set(self.eventSwims.keys())		if events=='':			if self.events == None:				events = allEvents			else:				events = self.events		events = set(events) & set(myEvents)		return events	def eventVariance(self):		timeVar={}		self.place()		for event in self.eventSwims:			average=0			count=0			for i in range(len(self.eventSwims[event])-1):				timeDif=abs(self.eventSwims[event][i].time-self.eventSwims[event][i+1].time) #time dif between this and next place				average=(average*count+timeDif)/(count+1) #running average				count+=1			timeVar[event]=average		return timeVar	'''	decides top events for each swimmer	top swimmers are decided by highest scoring event right now	unlimited divers	total max not counted right now	'''	def topEvents(self, teamMax=17, indMax=3, totalMax=4, adjEvents=False, debug=False):		self.place()		conference = Meet()		indSwims = {}		relaySwims = {}		teamSwimmers = {}		teamDivers = {}		drops = []		relayEvents = set()		events = self.eventSwims.keys()		for team in self.teams:			teamSwimmers[team]=0			teamDivers[team]=0		for event in self.eventSwims:  # we will keep relays as is, but count them towards total swims			if re.search('Relay', event):				relayEvents.add(event)				while not self.eventSwims[event] == []:  # move relays over to new meet					relay = self.eventSwims[event].pop()					conference.addSwim(relay)		for event in relayEvents:			events.remove(event)		#pare down		self.place()		for event in self.eventSwims:			if len(self.eventSwims[event]) > 100:				self.eventSwims[event] = self.eventSwims[event][:99]  # start with top 100 times		#now make sure that each person swims their top events		preEvent = None		nextEvent = None		if debug: print self		while not self.isEmpty():			for event in events:				#print event				drop = True  # just allow us to enter the loop				while drop and not self.eventSwims[event] == []:  # we need to loop on an event until we find				#someone who is actually in it					drop = False					#print self.eventSwims[event]					if self.events and type(self.events) == type([]) and event in self.events:						if not self.events.index(event) == 0:							preEvent = self.events[self.events.index(event)-1]						if not self.events.index(event)==len(self.events)-1:							nextEvent = self.events[self.events.index(event)+1]					newSwim = self.eventSwims[event].pop(0)					if preEvent in conference.eventSwims and not adjEvents:  # check to make sure no adjacent events						for swim in conference.eventSwims[preEvent]:							if newSwim.name == swim.name and newSwim.getScoreTeam() == swim.getScoreTeam():								drops.append(newSwim)								drop = True								if debug: print 'pre', swim.name, swim.event								if debug: print 'pre', newSwim.name, newSwim.event								break					if nextEvent in conference.eventSwims and not adjEvents:						for swim in conference.eventSwims[nextEvent]:							if newSwim.name == swim.name and newSwim.getScoreTeam() == swim.getScoreTeam():								drop = True								drops.append(newSwim)								if debug: print 'post', swim.name, swim.event								if debug: print 'post', newSwim.name, newSwim.event								break					if drop:  # already swimming previous or next event						continue					if not newSwim.name+newSwim.getScoreTeam() in indSwims:   # team max events						if teamSwimmers[newSwim.getScoreTeam()] < teamMax:							indSwims[newSwim.name + newSwim.getScoreTeam()] = 0  # count same person on two teams							# differently							teamSwimmers[newSwim.getScoreTeam()] += 1						else:							if debug: print 'team', swim.name, swim.event							if debug: print 'team', newSwim.name, newSwim.event							drops.append(newSwim)							continue # fixed to still add swim when all 18					if indSwims[newSwim.name + newSwim.getScoreTeam()] < indMax:  # individual max events						conference.addSwim(newSwim)						indSwims[newSwim.name + newSwim.getScoreTeam()] += 1					else:						if debug: print 'ind', swim.name, swim.event						if debug: print 'ind', newSwim.name, newSwim.event						drops.append(newSwim)						drop = True  # can't swim any more events		self.score()		if debug:			print teamSwimmers, indSwims, teamMax, indMax			for swim in drops:				print swim.name, swim.event, swim.getScoreTeam(), swim.time		self.eventSwims = conference.eventSwims		return drops	'''	adds top relays using same method in database	'''	def addTopRelays(self, number, team, database):		relays = [event for event in self.events if re.search('Relay',event)]		return database.topRelays(relays, team, self)	'''	creates the best lineup for the given team against another set lineup	no two person swapping instabilities	->must implement relay creation and switching	'''	def lineup(self, team, debug=False, splits=False):		team=str(team)		drops = self.topEvents(30, 3, 4)		self.place()		'''		now we have a starting point		'''		extras = {}  # double dictionary,swim:event		for swim in drops:  # + dropSplits			if not swim.name in extras:				extras[swim.name] = {}			extras[swim.name][swim.event]=swim		if debug: self.printout()		toCheck = self.getSwims(team, False, splits=splits)		while len(toCheck) > 0:  # double loop on all swims, trying to see if more points are scored if swapped			swim1=toCheck.pop()			swims=self.getSwims(team, False, splits=splits)			while len(swims) > 0:				swim2=swims.pop()				if swim1==swim2 or swim1.event==swim2.event:					continue				#make sure swims exist				if extras.has_key(swim2.name) and extras.has_key(swim1.name) and extras[swim1.name].has_key(swim2.event) and extras[swim2.name].has_key(swim1.event):					self.score()					if debug:						print self.score()						print team					oldScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]					(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)					self.score()					newScore = self.teamScores(sorted=False)[team] # [swim1.event,swim2.event]					if oldScore < newScore: # swap in new swims						if debug:							print "swap"							print newSwim1.name, newSwim1.event							print newSwim2.name, newSwim2.event						swims.add(newSwim1)						swims.add(newSwim2)						if swim1 in swims:							swims.remove(swim1)						if swim2 in swims:							swims.remove(swim2)						for swim in (newSwim1, newSwim2):							if swim.split:  # re-add swims in those events								for relay in self.eventSwims[newSwim1.fromRelay]:									if relay.team==team:										for split in relay.swims:											if not split in toCheck:												toCheck.add(split)							else:								for swim in self.eventSwims[newSwim1.event]:									if not swim in toCheck and swim.team==team:										toCheck.add(swim)						if swim2 in toCheck:  # make sure second swim is not checked again							toCheck.remove(swim2)						swim1=toCheck.pop()  # start checking next swim					else: # revert to old lineup						self.swap(newSwim1, newSwim2, extras)		self.score()	'''	given two old swims	will swap two swims, returns two new swims	'''	def swap(self, swim1, swim2, extras):		newSwim1=extras[swim1.name][swim2.event]		newSwim2=extras[swim2.name][swim1.event]		if self.eventSwims.has_key(swim2.event) and swim2 in self.eventSwims[swim2.event]: # ind swim			self.eventSwims[swim2.event].remove(swim2)			self.addSwim(newSwim1)		else: #gotta be a relay			self.relaySwap(swim2,newSwim1)		if self.eventSwims.has_key(swim1.event) and swim1 in self.eventSwims[swim1.event]: # ind swim			self.eventSwims[swim1.event].remove(swim1)			self.addSwim(newSwim2)		else: #gotta be a relay			self.relaySwap(swim1,newSwim2)		if not extras.has_key(swim1.name):			extras[swim1.name]={}		extras[swim1.name][swim1.event]=swim1		if not extras.has_key(swim2.name):			extras[swim2.name]={}		extras[swim2.name][swim2.event]=swim2		return (newSwim1,newSwim2)	'''	swaps someone into a relay	given old (swim1) and new (swim2) split	'''	def relaySwap(self, swim1, swim2):		for relay in self.eventSwims[swim1.fromRelay]:			if swim1 in relay.swims:				relay.changeSwimmer(swim1,swim2)				return	def taper(self):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				swim.taper()	def expectedScores(self, division='D3', swimmers=6, debug=False):		self.place()		scores = {}		teamSwims = {}		for event in self.eventSwims:			teamSwims[event] = {}			for swim in self.eventSwims[event]:				if not swim.team in scores:					scores[swim.team] = 0				if not swim.team in teamSwims[event]:					teamSwims[event][swim.team] = 0				else:					teamSwims[event][swim.team] += 1				losses = teamSwims[event][swim.team]				points = swimDatabase.expectedPoints(time=swim.time, event=event, gender=swim.gender,									division=division, numSwimmers=swimmers, losses=losses)				if points:					scores[swim.team] += points				if debug: print swim.event, swim.time, points, int(round(scores[swim.team])), losses		for team in scores:			scores[team] = int(round(scores[team]))		return scores	'''	places the meet	'''	def place(self, events='', storePlace=False):		events=self.getEvents(events)		for event in events:			if not event in self.eventSwims or len(self.eventSwims[event]) == 0:				continue			self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=False)			if storePlace:				for idx, swim in enumerate(self.eventSwims[event]):					swim.place = idx+1	'''	scores the meet	'''	def score(self, dual=None, events='', heatSize=8, heats=2, debug=False):		events = self.getEvents(events)		if debug:			print events		if dual is None:			if len(self.teams)==2:				dual=True			else:				dual=False		self.place(events)		max = 16		if heats == 3:			pointsI = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif heats == 2:			pointsI = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		if heatSize == 6:			pointsI = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		pointsR = [x*2 for x in pointsI]		if dual:			max = 3			pointsI = [9, 4, 3, 2, 1]			pointsR = [11, 4, 2]		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0			if debug:				print 'scoring', event			place = 1			teamSwims = {}			for swim in self.eventSwims[event]:				swim.score = None  # reset score				if not 'Relay' in swim.event:  # should use real relay var					team = swim.getScoreTeam()					if place > len(pointsI) or (team in teamSwims) and teamSwims[team] >= max:						swim.score = 0					else:						swim.score = pointsI[place-1]						if not team in teamSwims:							teamSwims[team] = 0						teamSwims[team] += 1						place += 1				else:					team = swim.team					if place > len(pointsR) or (team in teamSwims) and teamSwims[team] >= max:						swim.score = 0					else:						swim.score = pointsR[place-1]						if not team in teamSwims:							teamSwims[team] = 0						teamSwims[team] += 1						place += 1		return self.teamScores(events)	def scoreMonteCarlo(self, dual=None, events='', heatSize=8, heats=2, debug=False, sigma=.02, runs=500):		events = self.getEvents(events)		if debug:			print events		if dual is None:			if len(self.teams)==2:				dual=True			else:				dual=False		max = 16		if heats == 3:			pointsI = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif heats == 2:			pointsI = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		if heatSize == 6:			pointsI = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		pointsR = [x*2 for x in pointsI]		if dual:			max = 3			pointsI = [9, 4, 3, 2, 1]			pointsR = [11, 4, 2]		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0		teamScoresDist = []		for iternation in range(runs):  # run runs # of times			for event in self.eventSwims:  # add noise				for swim in self.eventSwims[event]:					if swim.time:						noise = np.random.normal(0, sigma)						swim.scoreTime = swim.time + swim.time * (noise)			#place again			self.place(events)			#now score			for event in self.eventSwims:				if debug:					print 'scoring', event				place = 1				teamSwims = {}				for swim in self.eventSwims[event]:					swim.score = None  # reset score					if not 'Relay' in swim.event:  # should use real relay var						team = swim.getScoreTeam()						if place > len(pointsI) or (team in teamSwims) and teamSwims[team] >= max:							swim.score = 0						else:							swim.score = pointsI[place-1]							if not team in teamSwims:								teamSwims[team] = 0							teamSwims[team] += 1							place += 1					else:						team = swim.team						if place > len(pointsR) or (team in teamSwims) and teamSwims[team] >= max:							swim.score = 0						else:							swim.score = pointsR[place-1]							if not team in teamSwims:								teamSwims[team] = 0							teamSwims[team] += 1							place += 1			self.teamScores(events)			#self.printout()			teamScoresDist.append(self.teamScores(events))			self.reset(times=True)  # reset the times to normal		places = {}		for score in teamScoresDist:			for idx, (team, score) in enumerate(score):				if not team in places:					places[team] = []				places[team].append(idx)		#print places		probMatrix = {}		for team in places:			probMatrix[team] = [0 for _ in range(len(places))]			for place in places[team]:				probMatrix[team][place] += 1.0/len(places[team])		return probMatrix	def teamScores(self, events='', sorted=True):		events = self.getEvents(events)		teams = {}		for event in events:			if not event in self.eventSwims: continue			for swim in self.eventSwims[event]:				team = swim.getScoreTeam()				if not team in teams:					teams[team] = 0				teams[team] += swim.getScore()		if not sorted:			return teams		#now sort		scores = []		for team in teams:			scores.append([team, teams[team]])		scores.sort(key=lambda team: team[1], reverse=True)		self.scores = scores		return scores	def winningTeam(self):		if not self.scores: self.teamScores()		if len(self.scores)<1 or len(self.scores[0])<1: return None		return self.scores[0][0]	'''	lists swimmers by team and by points scored	'''	def scoreReport(self, printout=True, repressSwim=False, repressTeam=False):		scores={}		for team in self.teams:			scores[team]={'total': 0, 'year': {}, 'swimmer': {}, 'event': {}}		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.relay:					name = 'Relays'				else:					name = swim.name				if repressSwim and swim.score == 0:					continue   # repess zero scores				team = swim.getScoreTeam()				if not name in scores[team]['swimmer']:					scores[team]['swimmer'][name] = 0				if not event in scores[team]['event']:					scores[team]['event'][event]=0				scores[team]['swimmer'][name] += swim.score				scores[team]['total'] += swim.score				scores[team]['event'][event] += swim.score				if swim.year:					if not swim.year in scores[team]['year']:						scores[team]['year'][swim.year] = 0					scores[team]['year'][swim.year] += swim.score		if printout:			for team in sorted(scores['swimmer'], key=scores['swimmer']['total']):				print '-------------------------------'				print team				for name in sorted(scores['swimmer'][team], key=scores['swimmer'][team].__getitem__):					print name.join(scores['swimmer'][team][name].ljust(25))		if repressTeam:			zeroTeams=set()			for team in scores:				if scores[team]['total'] == 0:					zeroTeams.add(team)			for team in zeroTeams:				del(scores[team])		return scores	def printout(self, events=''):		events=self.getEvents(events)		for event in events:			if event not in self.eventSwims: continue			print "-------------------------------------------------------------------------------------"			print "Event: " + event			for swim in self.eventSwims[event]:				if swim.score:					print swim.printScore().lstrip()+"\t"+str(swim.score)				else:					print swim.printScore().lstrip()		print self.scores	def scoreString(self, showNum='all', showScores=True, showPlace=False):		self.score()		string = {}		events=self.getEvents('')		for event in events:			if event not in self.eventSwims: continue			string[event]=[]			place = 0			for swim in self.eventSwims[event]:				place += 1				if not showNum=='all' and place > showNum:					break				swimAry = re.split('\t', swim.printScore(gender=False).strip())				if showPlace:					swimAry.insert(0, place)				if swim.score and showScores:					swimAry.append(str(swim.score))					string[event].append(swimAry)				else:					string[event].append(swimAry)		string["scores"]=self.teamScores()		return string	def __str__(self):		if self.name:			return self.name		self.printout()		return ''	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name and self.date==s.date	def __hash__(self):		return hash(self.name)^hash(self.date)'''full database methods'''class SwimDatabase:	def __init__(self, database):		global swimDatabase		swimDatabase = self		db_proxy.initialize(database)		self.database = database		self.dist = {}		self.results = {}  # cache dual results		self.teams = {}	def topDual(self, season=thisSeason(), events=requiredEvents, debug=False, teams='all', gender='Men'):		if teams == 'all':			teams = self.teams		meets = {}		wins = {}		losses = {}		for team in teams:			if not team in self.teams:				self.teams[team] = Team(team, self)			if not self.teams[team].topDual(season, debug=debug, gender=gender):				continue			meets[team] = self.teams[team].topDual(season, debug=debug, gender=gender)  # its cached			wins[team] = 0			losses[team] = 0			#if debug: print team, '\t\t', meets[team]		if debug: print '-----------'		for team1 in meets:			for team2 in meets:				if team1 == team2:					continue				if not team1 in self.results:					self.results[team1] = {}				if not team2 in self.results:					self.results[team2] = {}				if team2 in self.results[team1] or team1 in self.results[team2]:  # reverse meet already swum					continue				newMeet = self.swimMeet([[team1, meets[team1]], [team2, meets[team2]]], includeEvents=events,									  selectEvents=False)  # should convert to dual form				self.results[team1][team2] = newMeet.winningTeam()				self.results[team2][team1] = newMeet.winningTeam()				if debug: print team1, team2, newMeet.winningTeam()				if self.results[team1][team2] == team1: # team1 wins					wins[team1] += 1					losses[team2] += 1				elif self.results[team1][team2] == team2:  # team2 wins, otherwise no points					wins[team2] += 1					losses[team1] += 1		if debug:			for (index, team) in enumerate(sorted(wins.items(), key=operator.itemgetter(1), reverse=True)):				print str(index)+'.',team[0]+':',team[1],'-',losses[team[0]]		return meets, wins, losses	'''	creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	'''	def swimMeet(self, teamMeets, gender=None, debug=False, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False):		if debug: print teamMeets		meet = Meet()		teams = []		if includeEvents == 'all':			includeEvents = allEvents		commonEvents = allEvents		for teamMeet in teamMeets:			newTeamName = None			newTeam = teamMeet[0]			newMeet = teamMeet[1]			if len(teamMeet) >= 3 and teamMeet[2]:  # maybe pass in new team name				newTeamName = teamMeet[2]			if len(teamMeet) == 4:				season = teamMeet[3]			else:				season = None			if isinstance(newMeet, basestring):  # just a name				newMeet = Meet(name=newMeet, gender=gender, teams=[newTeam], season=season)			commonEvents = commonEvents & set(newMeet.eventSwims.keys())			if debug:				print set(newMeet.eventSwims.keys())				newMeet.printout()			duplicates = None			if not newTeamName:				duplicates = teams.count(newTeam)				teams.append(newTeam)			else:				teams.append(newTeamName)			for swim in newMeet.getSwims(newTeam):				if duplicates:					swim.scoreTeam = swim.getScoreTeam() + ' ' + str(duplicates + 1)				if newTeamName:					swim.scoreTeam = newTeamName				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		if len(meet.teams) == 2:			if selectEvents:				meet.topEvents(25, 3, 4)				'''need to fix event selection for dual meets'''			meet.events = (commonEvents | includeEvents) - excludeEvents			meet.score(dual=True)		else:			if selectEvents:				meet.topEvents()			meet.score()		if debug: meet.printout()		return meet	'''	optimal lineup creator	'''	def lineup(self, teamsSeasons, meet, debug=False, resetTimes=False, events=eventsDualS, gender='Men'):		meet.events = events		teams = []		print teamsSeasons		if debug:			print meet.getEvents(), events		for team in teamsSeasons:			teams.append(team)			if not teamsSeasons[team]:				season = thisSeason()			else:				season = teamsSeasons[team]			#handle duplicate teams			newMeet = self.topTimes(events=events, teams=[team], season=season, gender=gender, topTimes=True).getSwims()			duplicates = teams.count(team) - 1			if debug: print team, season, teams, duplicates			for swim in newMeet:				if duplicates > 0:					swim.scoreTeam = swim.getScoreTeam() + ' ' + str(duplicates + 1)					print swim.getScoreTeam() + ' ' + str(duplicates + 1)				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		meet.place()		teams = teamsSeasons.keys()		if debug:			meet.printout()		if len(teams) == 1:			meet.lineup(teams.pop(), debug=debug)		else:			meet.topEvents(17, indMax=3, totalMax=4)		return meet	'''	top expected score	'''	def topTeamScore(self, team, dual=True, season=thisSeason(), gender='Men', division='D3', recruits=False):		#print team, dual, season, gender, division		if recruits:			topMeet = self.topTimesRecruit(teams=[team], gender=gender, meetForm=True)			score = 0			for swim in topMeet.getSwims():				#print swim.time, swim.team, swim.event, swim.name				score += self.expectedPoints(swim.time, swim.gender, division, swim.event, percentile=50)			return score		else:			if dual:				events = eventsDualS			else:				events = eventsChamp			topMeet = self.topTimes(teams=[team], season=season, gender=gender, events=events, divisions=[division])		topMeet.topEvents(teamMax=17, indMax=3)		#topMeet.printout()		if dual:			scores = topMeet.expectedScores(swimmers=6, division=division)		else:			scores = topMeet.expectedScores(swimmers=16, division=division)		#print scores		if team in scores:			return scores[team]		return 0	'''	returns meet of top times	'''	def topTimes(self, events=None, teams=MIAC, season=None, gender='Men', topTimes=True, meetForm=True,				divisions='all', year=None, date=None):		if not events:			events = allEvents		if teams == 'all':			teams = self.teams		if divisions == 'all':			divisions = ['D1', 'D2', 'D3']		if not season:			season = thisSeason()  # use current season		topMeet = Meet(events=events)		swimmers = {}		def ls(items):			sqlList = "("			for item in items:				if not sqlList == "(":					sqlList += ","				sqlList += '"' + item + '"'			sqlList += ")"			return sqlList		'''		select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\			.where(TeamSeason.gender==gender, TeamSeason.team << list(teams), TeamSeason.division << list(divisions),				   TeamSeason.season==season)		qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team, Swim.year).group_by(Swim.name,				Swim.event, Swim.team, Swim.year)		for swim in qwery:			print swim.name, swim.event, swim.year, swim.team		'''		if year:  # to get the freshman swimmers for HS improvement NOT TAPER TIMES!!			select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\			.where(TeamSeason.gender==gender, TeamSeason.team << list(teams), TeamSeason.division << list(divisions),				   TeamSeason.season==season, Swimmer.year=='Freshman')		else:			select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\				.where(TeamSeason.gender==gender, TeamSeason.team << list(teams), TeamSeason.division << list(divisions),			   	TeamSeason.season==season)		if topTimes:			if date:				qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team, Swim.year).group_by(Swim.name,					Swim.event, Swim.team, Swim.year).where(Swim.date < date)			else:				qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team, Swim.year).group_by(Swim.name,					Swim.event, Swim.team, Swim.year)		else:			qwery = select.select(Swim.name, Swim.event, fn.Avg(Swim.time), Swim.team, Swim.year).group_by(Swim.name,				Swim.event, Swim.team, Swim.year)		for swim in qwery:			if topTimes:				time = swim.min			else:				time = swim.avg			if meetForm:				topMeet.addSwim(Swim(name=swim.name, event=swim.event, time=time, gender=gender, team=swim.team,									  season=season, year=swim.year))			else:				newSwim = Swim(name=swim.name, event=swim.event, time=time,									gender=gender, team=swim.team, season=season, year=swim.year)				if not swim.team in swimmers:					swimmers[swim.team] = {}				if not swim.name in swimmers[swim.team]:						swimmers[swim.team][swim.name] = {}				swimmers[swim.team][swim.name][swim.event] = newSwim		if meetForm:			topMeet.place()			return topMeet		#print swimmers		return swimmers	def topTimesRecruit(self, teams=MIAC, events=allEvents, gender='Men', meetForm=False):		swimmers = {}		#print names		for swim in HSSwim.select().where(HSSwim.gender==gender, HSSwim.event << list(events), HSSwim.team <<				list(teams)):			if not swim.team in swimmers:				swimmers[swim.team] = {}			if not swim.name in swimmers[swim.team]:				swimmers[swim.team][swim.name] = {}			swimmers[swim.team][swim.name][swim.event] = Swim(name=swim.name, event=swim.event, time=swim.time,												   gender=swim.gender, team=swim.team)		#print swimmers		if meetForm:			newMeet = Meet()			for team in swimmers:				for name in swimmers[team]:					for event in swimmers[team][name]:						newMeet.addSwim(swimmers[team][name][event])			newMeet.place()			return newMeet		return swimmers	def conference(self, teams=MIAC, season=None, topTimes=True, gender='Men', divisions='D3', date=None):		events = eventsChamp3		if not season:			season = thisSeason()  # use current season		start = Time.time()		conference = self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=topTimes,								   divisions=[divisions], date=date)		print Time.time() - start		conference.topEvents(17)		print Time.time() - start		conference.score()		return conference	def improvement(self, gender='Men', teams=MIAC, events=allEvents, season1=thisSeason()-1, season2=thisSeason()-2,					season3=None, season4=None):		#top1 = self.topTimes(gender=gender, events=events, teams=teams, season=season1, meetForm=False)		#top2 = self.topTimes(gender=gender, events=events, teams=teams, season=season2, meetForm=False)		top1 = self.taperSwims(teams=teams, gender=gender, season=season1)		top2 = self.taperSwims(teams=teams, gender=gender, season=season2)		if season3:			top3 = self.topTimes(gender=gender, events=events, teams=teams, season=season3, meetForm=False)		if season4:			top4 = self.topTimes(gender=gender, events=events, teams=teams, season=season4, meetForm=False)		def calcImprovement(top1, top2):			allImprovement = {}			teamImprovement = {}			for team in top1:				if not team in top2:					continue				if not team in allImprovement:					allImprovement[team] = {}					teamImprovement[team] = []				for swimmer in top1[team]:					if not swimmer in top2[team]:						continue					if not swimmer in allImprovement:						allImprovement[team][swimmer] = {}					for event in top1[team][swimmer]:						if not event in top2[team][swimmer]:							continue						time1 = top1[team][swimmer][event].time						time2 = top2[team][swimmer][event].time						drop = (time2-time1) / ((time1+time2) / 2) * 100						print swimmer, event, time1, time2						if abs(drop) > 10:  # toss outliers							continue						allImprovement[team][swimmer][event] = drop						teamImprovement[team].append(drop)			return allImprovement, teamImprovement		allImprovement, teamImprovement = calcImprovement(top1, top2)		if season3:			allImprovement2, teamImprovement2 = calcImprovement(top2, top3)			combined = teamImprovement.copy()			for team in teamImprovement2:				if team in combined:					combined[team].extend(teamImprovement2[team])				else:					combined[team] = teamImprovement2[team]			teamImprovement = combined		if season4 and season3:			allImprovement2, teamImprovement2 = calcImprovement(top3, top4)			combined = teamImprovement.copy()			for team in teamImprovement2:				if team in combined:					combined[team].extend(teamImprovement2[team])				else:					combined[team] = teamImprovement2[team]			teamImprovement = combined		return teamImprovement, allImprovement	def improvement2(self, gender='Men', teams=MIAC, season1=thisSeason()-1, season2=thisSeason()-2):		posSeasons = [2016, 2015, 2014, 2013, 2012, 2011]		#print season1, season2		if season1 > season2 and season1 in posSeasons and season2 in posSeasons:			seasons = range(season2, season1)			#print seasons		teamImprovement = {}		for swim in Improvement.select().where(Improvement.fromseason << seasons, Improvement.gender==gender,									   Improvement.team << list(teams)):			if swim.team not in teamImprovement:				teamImprovement[swim.team] = []			teamImprovement[swim.team].append(swim.improvement)		if len(teams)==1 and teams[0] in teamImprovement:			return teamImprovement[teams[0]]		return teamImprovement	def HSImprovement(self, gender='Men', teams=['Carleton'], events=allEvents):		def calcImprovement(top1, top2):			allImprovement = {}			teamImprovement = {}			for team in top1:				if not team in top2:					continue				if not team in allImprovement:					allImprovement[team] = {}					teamImprovement[team] = []				for swimmer in top1[team]:					if not swimmer in top2[team]:						continue					if not swimmer in allImprovement:						allImprovement[team][swimmer] = {}					for event in top1[team][swimmer]:						if not event in top2[team][swimmer]:							continue						time1 = top1[team][swimmer][event].time						time2 = top2[team][swimmer][event].time						drop = (time2-time1) / ((time1+time2) / 2) * 100						if abs(drop) > 10:  # toss outliers							continue						allImprovement[team][swimmer][event] = drop						teamImprovement[team].append(drop)			return allImprovement, teamImprovement		#improvement from HS to whatever year specified		top1 = self.topTimes(gender=gender, events=events, teams=teams, meetForm=False, taper=True,							 year='Freshman')		'''		names = set()		for team in top1:			for name in top1[team]:				names.add(name)		'''		top2 = self.topTimesRecruit(events=events, gender=gender, teams=teams)		allImprovement, teamImprovement = calcImprovement(top1, top2)		#print teamImprovement		return teamImprovement, allImprovement	def conferencePlace(self, division, gender, newSwims):		newEvents = set()		for swim in newSwims:			newEvents.add(swim[0])		confMeets = {}		with open('./data/' + division + gender + '.csv') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet					confMeets[confName].addSwims(Meet(name=meetName, events=newEvents, gender=gender,													  topSwim=True).getSwims())				else:					confMeets[confName] = Meet(name=meetName, events=newEvents, gender=gender, topSwim=True)		confScores = {}		for conference in confMeets:			confMeet = confMeets[conference]			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScores	def expectedPoints(self, time, gender, division, event, numSwimmers=6, losses=0, percentile=30):		scoresR = None		if numSwimmers == 24:			scores = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif numSwimmers == 16:			scores = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif numSwimmers == 12:			scores = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		else:			if not 'Relay' in event:				if losses > 2:					return 0			else:				if losses < 1:					return 0			scores = [9, 4, 3, 2, 1]			scoresR = [11, 4, 2]		if 'Relay' in event:			if scoresR:				scores = scoresR			else:				scores = [x*2 for x in scores]		scores = scores[losses:]  # people who you know you will lose to		cdf = self.getTimeCDF(gender, division, event, percentile)		lose = 1 - cdf(time)		win = cdf(time)		num = numSwimmers - 1 - losses  # other swimmers		totalScore = 0		for place, score in enumerate(scores):			comb = binomial(num, place)			totalScore += score * comb * (lose**(num-place) * win**(place))		return totalScore	def getTimeCDF(self, gender, division, event, percentile):		if not gender in self.dist:			self.dist[gender] = {}		if not division in self.dist[gender]:			self.dist[gender][division] = {}		if not event in self.dist[gender][division]:			times = []			for swim in Swim.select(Swim.time).where(Swim.division==division, Swim.gender==gender, Swim.event==event):				if swim.time > 15:					times.append(swim.time)			if len(times) == 0:				return			'''top 10,1 percent'''			pTime = np.percentile(times, percentile)			#print pTime			fastTimes = [i for i in times if i<pTime]			ecdf = ECDF(fastTimes)			self.dist[gender][division][event] = ecdf		return self.dist[gender][division][event]	def taperMeets(self, teams=MIAC):  #find meets where most best times come from		teamMeets = {}		teams=['Univ of Utah', 'Stanford', 'California', 'Arizona', 'Southern Cali', 'Arizona St']		for team in teams:			for swim in Swim.raw("WITH topTimes AS (SELECT name, event, meet, time, row_number() OVER (PARTITION BY event,name "					 "ORDER BY time) AS rnum "					 "FROM Swim "					 "WHERE team=%s AND season=%s) "					 "SELECT name,event,meet,time FROM topTimes WHERE rnum=1",					 team, 2015):				if not team in teamMeets:					teamMeets[team] = []				teamMeets[team].append(swim.meet)		print teamMeets.keys()		for team in teamMeets:			print team, max(set(teamMeets[team]), key=teamMeets[team].count)	def taperSwims(self, teams, gender, season=None, numTimes=3):		if season == None:			season = thisSeason()		teamSwims = {}		for team in teams:			teamSwims[team] = {}			if team in self.teamSwimmers and season in self.teamSwimmers[team] and gender in self.teamSwimmers[team][season]:				for swimmer in self.teamSwimmers[team][season][gender]:					if 'Relay' in swimmer: continue					teamSwims[team][swimmer] = {}					times = []					for swim in Swim.raw("WITH topTimes as "							"(SELECT name, gender, meet, event, time, year, division, row_number() OVER "							"(PARTITION BY event, name ORDER BY time) as rnum "							"FROM Swim WHERE name=%s AND season=%s AND team=%s) "							"SELECT name, event, meet, time, gender, division, year FROM topTimes WHERE rnum=1",							swimmer, season, team):						if swim.event == '1000 Yard Freestyle': continue						cdf = self.getTimeCDF(gender, swim.division, swim.event, 100)						points = 1 - cdf(swim.time)  # self.expectedPoints(swim.time, swim.gender, swim.division,						# swim.event,						# percentile=80,										# numSwimmers=6)						#print swim.time, swim.gender, swim.division, swim.event, points						heapq.heappush(times, (points, swim))					for (points, swim) in heapq.nlargest(numTimes, times):						#print team, swimmer, swim.event, points						teamSwims[team][swimmer][swim.event] = swim		return teamSwims	def storeImprovement(self):		seasons = [2015, 2014, 2013]		swims = []		confs = getConfs()		for division in confs:			for conference in confs[division]:				for team in confs[division][conference]:					if team != 'Carleton': continue					for gender in ['Men', 'Women']:						for season in seasons:							top1 = self.taperSwims(teams=[team], gender=gender, season=season)							top2 = self.taperSwims(teams=[team], gender=gender, season=season-1)							if not team in top2 and team in top2:								continue							for swimmer in top1[team]:								if not swimmer in top2[team]:									continue								for event in top1[team][swimmer]:									if not event in top2[team][swimmer]:										continue									swim1 = top1[team][swimmer][event]									swim2 = top2[team][swimmer][event]									time1 = swim1.time									time2 = swim2.time									drop = (time2-time1) / ((time1+time2) / 2) * 100									#print swimmer, event, time1, time2									if abs(drop) > 10:  # toss outliers										continue									newSwim = {'fromseason': season-1, 'toseason': season, 'name': swim1.name,											   'fromyear': swim2.year, 'toyear': swim1.year,											   'team': team, 'gender': gender, 'event': event,											   'improvement': drop,  # positive=faster											   'fromtime': swim2.time, 'totime': swim1.time,											   'conference': conference, 'division': division}									#print newSwim									swims.append(newSwim)		print len(swims)		db_proxy.connect()		for i in range(len(swims) / 100):			print i			with db_proxy.transaction():				Improvement.insert_many(swims[i*100:(i+1)*100]).execute()	def attrition(self, teams=MIAC, seasons=[2015, 2014, 2013, 2012], gender='Men'):		teamDrops = {}		teamSwims = {}		for team in teams:			teamDrops[team] = 0			teamSwims[team] = 0			for season in seasons:				try:					# make sure there was a team both years					seasonID = TeamSeason.get(TeamSeason.team==team, TeamSeason.gender==gender,											  TeamSeason.season==season).id					seasonID2 = TeamSeason.get(TeamSeason.team==team, TeamSeason.gender==gender,											 TeamSeason.season==season+1).id					for swimmer in Swimmer.select(Swimmer.name, Swimmer.teamid, Swimmer.year).where(									Swimmer.year!='Senior', Swimmer.teamid==seasonID):						teamSwims[team] += 1  # total number of swimmers						try:							Swimmer.get(Swimmer.name==swimmer.name, Swimmer.season==season+1,										Swimmer.teamid==seasonID2)  # swam the next year						except Swimmer.DoesNotExist:							teamDrops[team] += 1				except TeamSeason.DoesNotExist:					pass		dropRate = {}		for team in teamDrops:			if teamSwims[team] > 0:				dropRate[team] = float(teamDrops[team]) / float(teamSwims[team])		if len(teams)==1 and teams[0] in dropRate:			return dropRate[teams[0]]		return dropRateif __name__ == "__main__":	urlparse.uses_netloc.append("postgres")	if "DATABASE_URL" in os.environ:  # production		url = urlparse.urlparse(os.environ["DATABASE_URL"])		db = PostgresqlDatabase(database=url.path[1:],    		user=url.username,    		password=url.password,    		host=url.hostname,    		port=url.port)	else:		db = PostgresqlDatabase('swimdb', user='hallmank')	database = SwimDatabase(db)	#print database.conference().scoreMonteCarlo()	print database.topTimes()	#print Time.time() - start	#print database.attrition(gender='Women')	#database.HSImprovement(teams=MIAC)  # positive is faster	#print database.HSImprovement()	#for swim in database.topTeamScore(team='Carleton', recruits=True):	#	print swim.time	#database.taperMeets()	#print database.taperSwims(teams=['Carleton'], gender='Men', season=2016)	#database.storeImprovement()	#findTeamSwimmers()	#print loadTeamSwimmers()	#print database.topTimes(teams=['Carleton', 'St. Olaf'], season=2016)