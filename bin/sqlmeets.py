import reimport numpy as npimport operatorfrom datetime import datefrom peewee import *import time as Timeimport os, urlparsepointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]eventsDualS = ["200 Yard Medley Relay","1000 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsDualL = ["400 Yard Medley Relay","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","400 Yard Individual Medley","400 Yard Freestyle Relay"]eventsChamp = ["400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsChamp3 = ['1 mtr Diving','200 Yard Freestyle Relay','','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','','400 Yard Medley Relay','','400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','800 Yard Freestyle Relay','','1650 Yard Freestyle','','200 Yard Medley Relay','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','','400 Yard Freestyle Relay','3 mtr Diving']eventsDay1 = ['1 mtr Diving','200 Yard Freestyle Relay','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','400 Yard Medley Relay']eventsDay2 = ['400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','800 Yard Freestyle Relay']eventsDay3 = ['1650 Yard Freestyle','200 Yard Medley Relay','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','400 Yard Freestyle Relay','3 mtr Diving']allEvents={"400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay",'1000 Yard Freestyle','100 Yard Breastroke','200 Yard Breastroke'}eventsHS = ["200 Yard Medley Relay","200 Yard Individual Medley","200 Yard Freestyle","50 Yard Freestyle","1 mtr Diving","100 Yard Butterfly","100 Yard Freestyle","500 Yard Freestyle","200 Yard Freestyle Relay","100 Yard Backstroke","100 Yard Breastroke","400 Yard Freestyle Relay"]MIAC = ["Carleton","Augsburg","St. Olaf","Saint Mary's MN","Macalester","Gustavus","Saint Benedict","St. Kate's","Concordia","St. John's","St. Thomas","Hamline"]requiredEvents={"200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly"}#setup database connectionurlparse.uses_netloc.append("postgres")url = urlparse.urlparse(os.environ["DATABASE_URL"])db = PostgresqlDatabase(database=url.path[1:],    user=url.username,    password=url.password,    host=url.hostname,    port=url.port)#db = PostgresqlDatabase('swimdb', user='hallmank')#make time look nicedef swimTime(time):	(seconds,point) = re.split("\.",str(time))	if int(seconds) < 60:		time=round(time,2)		time=str(time)		while len(time) < 5:			time += '0'		return time	minutes=str(int(seconds)/60)	seconds=str(int(seconds)%60)	while len(seconds) < 2:		seconds='0'+seconds	while len(point) < 2:		point=point+'0'	return  minutes + ":" + seconds + "." + point[:2]#convers to a time in secondsdef toTime(time):	if time[0]=="X" or time[0]=="x":		time=time[1:]	if re.match(".*:.*",time) == None:		return float(time)	return float(re.split(":",time)[0])*60 +float(re.split(":",time)[1])#sees if one list contains anotherdef contains(small, big):	for i in small:		if not i in big:			return False	return Truedef relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']def getConfs(fileName='data/conferences.txt'):	try:		with open(fileName, 'r') as file:			divisions = {'D1': {}, 'D2': {}, 'D3': {}}			teams = {}			for line in file:				parts = re.split('\t', line.strip())				division = parts[0]				conf = parts[1]				team = parts[2]				if not conf in divisions[division]:					divisions[division][conf] = set()				divisions[division][conf].add(team)				if not team in teams:					teams[team] = (conf, division)		return divisions	except IOError:		return Nonedef getTeamMeets(fileName='data/teammeets.txt'):	try:		with open(fileName, 'r') as file:			teams = {}			for line in file:				parts = re.split('\t', line.strip())				(team, season, meet) = (parts[0], int(parts[1]), parts[2])				if not team in teams:					teams[team] = {}				if not season in teams[team]:					teams[team][season] = set()				teams[team][season].add(meet)		return teams	except IOError:		return Nonedef storeTeamMeets(teamMeets, fileName='data/teammeets.txt'):	with open(fileName, 'w') as file:		for team in teamMeets:			for season in teamMeets[team]:				for meet in teamMeets[team][season]:					file.write(team + '\t' + str(season) + '\t' + meet + '\n')def thisSeason():	today = date.today()	if today.month > 6:		return today.year + 1	return today.yearclass Swim(Model):	name = CharField()	event = CharField()	date = DateField()	time = FloatField()	season = IntegerField()	team = CharField()	meet = CharField()	gender = CharField()	conference = CharField()	division = CharField()	relay = BooleanField()	year = CharField()	place = None	score = None	scoreTeam = None	scoreTime = None	split = False	def getScoreTeam(self):		if self.scoreTeam:			return self.scoreTeam		if self.team:			return self.team		return ''	def getScoreTime(self):		if self.scoreTime:			return	self.scoreTime		return self.time	def getScore(self):		if self.score:			return self.score		return 0	def printScore(self, br='\t', gender=True):		time=swimTime(self.getScoreTime())		if gender:			genderStr = br + self.gender		else:			genderStr = ''		if self.relay:			name = 'Relay'		else:			name = self.name		if self.meet:			meet = str(self.meet)		else:			meet = ''		return name+br+self.getScoreTeam()+genderStr+br+self.event+br+time+br+meet	class Meta:		database = db		indexes = ('name', 'meet')class Swimmer: #should add in filtering by season	def __init__(self, swim):		self.name=swim.name		self.team=swim.team		self.gender=swim.gender		self.year=swim.year		self.events={}		self.tapers=None		self.averageTaper=None		self.taperTimes={}		self.medianTaperTimes={}		self.topTaperTimes=None		self.nonTaperTimes={}		self.medianNonTaperTimes={}		self.topNonTaperTimes={}		self.improvement=None		self.improvementTimes=None		self.averageImprovement={}		self.totalAverageImprovement=None		self.topTimes={}		self.scoreTeam=None		self.taperDate=date(2000,2,1)	def getScoreTeam(self):		if self.scoreTeam: return self.scoreTeam		return self.team	def addSwim(self, swim):		swim.swimmer=self		if not swim.season in self.events:			self.events[swim.season] = {}			self.taperTimes[swim.season] = {}			self.nonTaperTimes[swim.season] = {}			self.topNonTaperTimes[swim.season] = {}			self.topTimes[swim.season] = {}		if not swim.event in self.events[swim.season]:			self.events[swim.season][swim.event]=[]		self.events[swim.season][swim.event].append(swim)		if not swim.event in self.topTimes[swim.season] or swim.time < self.topTimes[swim.season][swim.event].time:			self.topTimes[swim.season][swim.event] = swim		if swim.date > swim.season.end.replace(swim.season.end.year, self.taperDate.month, self.taperDate.day):  # tapered swims			if not swim.event in self.taperTimes[swim.season]:				self.taperTimes[swim.season][swim.event]=[]			self.taperTimes[swim.season][swim.event].append(swim.time)		else: 											#non-tapered swims			if not swim.event in self.nonTaperTimes[swim.season]:				self.nonTaperTimes[swim.season][swim.event]=[]			self.nonTaperTimes[swim.season][swim.event].append(swim.time)			if not swim.event in self.topNonTaperTimes[swim.season]:				self.topNonTaperTimes[swim.season][swim.event] = swim.time			elif swim.time < self.topNonTaperTimes[swim.season][swim.event]:				self.topNonTaperTimes[swim.season][swim.event] = swim.time	def getTapers(self,swim=None,season='all',event='all',top=False):		if not self.tapers: self.findTapers(top=top)		if season=='all':			if event=='all':				return self.tapers		if season in self.tapers:			if event in self.tapers[season]:				return self.tapers[season][event]		return None	def findTapers(self,top=False):		self.tapers={}		self.getMedianTaperTimes()		if not top: #median tapers			nonTapers=self.getMedianNonTaperTimes()		else:			nonTapers=self.topNonTaperTimes		if not self.medianTaperTimes=={} and not nonTapers=={}:			for season in self.medianTaperTimes:				if season in nonTapers:					if not season in self.tapers:						self.tapers[season]={}					for event in self.medianTaperTimes[season]:						if event in nonTapers[season]:							if not event in self.tapers[season]:								self.tapers[season][event]=[]							self.tapers[season][event]=self.medianTaperTimes[season][event]/nonTapers[season][event]-1	def getMedianTaperTimes(self,season='all',event='all'):		if self.medianTaperTimes=={}: self.findMedianTaperTimes()		if season in self.medianTaperTimes:			if event=='all':				return self.medianTaperTimes[season]			if event in self.medianTaperTimes[season]:				return self.medianTaperTimes[season][event]		if not season=='all':			return		if not event=='all':			events=[]			for season in self.medianTaperTimes:				if event in self.medianTaperTimes[season]:					events.append(self.medianTaperTimes[season][event])			return events		return self.medianTaperTimes	def findMedianTaperTimes(self):		for season in self.taperTimes:			self.medianTaperTimes[season]={}			for event in self.taperTimes[season]:				self.medianTaperTimes[season][event]=np.median(self.taperTimes[season][event])	def getTopTaperTimes(self):		if not self.topTaperTimes: self.findTopTaperTimes()		return self.topTaperTimes	def findTopTaperTimes(self):		self.topTaperTimes={}		for season in self.taperTimes:			self.topTaperTimes[season]={}			for event in self.taperTimes[season]:				self.taperTimes[season][event].sort()				self.topTaperTimes[season][event]=self.taperTimes[season][event][0]		def getMedianNonTaperTimes(self,season='all',event='all',average=False):		if self.medianNonTaperTimes=={}:			self.findMedianNonTaperTimes(average=average) #use average or median		if season in self.medianNonTaperTimes:			if event=='all':				return self.medianNonTaperTimes[season]			if event in self.medianNonTaperTimes[season]:				return self.medianNonTaperTimes[season][event]		if not season=='all':			return None		if not event=='all' and season=='all':			events=[]			for season in self.medianNonTaperTimes:				if event in self.medianNonTaperTimes[season]:					events.append(self.medianNonTaperTimes[season][event])			return events		return self.medianNonTaperTimes	def findMedianNonTaperTimes(self,average=False):		for season in self.nonTaperTimes:			self.medianNonTaperTimes[season]={}			for event in self.nonTaperTimes[season]:				if average:					self.medianNonTaperTimes[season][event]=np.average(self.nonTaperTimes[season][event])				else:					self.medianNonTaperTimes[season][event]=np.median(self.nonTaperTimes[season][event])	def getImprovement(self):		if not self.improvement: self.findImprovement()		return self.improvement#negative means you got faster!	def findImprovement(self,seasons='all'):		self.improvement={}		self.improvementTimes={}		self.findMedianTaperTimes()		if seasons=='all': seasons=self.events.keys()		for season in self.medianTaperTimes:			nextSeason=season+1			if nextSeason in self.medianTaperTimes:				self.improvement[nextSeason]={}				self.improvementTimes[nextSeason]={}				for event in self.medianTaperTimes[season]:					if event in self.medianTaperTimes[nextSeason]:						self.improvement[nextSeason][event]=self.medianTaperTimes[nextSeason][event]/self.medianTaperTimes[season][event]-1						self.improvementTimes[nextSeason][event]=(self.medianTaperTimes[nextSeason][event],self.medianTaperTimes[season][event])	def printImprovement(self):		if not self.improvement: self.findImprovement()		for season in self.improvement:			print season			for event in self.improvement[season]:				print event,round(self.improvement[season][event],3)*100	def getAverageImprovement(self,oneSeason=None):		#print season		#print self		#print self.averageImprovement		if oneSeason==None and self.totalAverageImprovement: return self.totalAverageImprovement		if oneSeason in self.averageImprovement: return self.averageImprovement[oneSeason]		if not self.improvement: self.findImprovement()		if not self.improvement: return None #well we didn't find anything		countTotal=0		averageTotal=0		for season in self.improvement:			countSeason=0			averageSeason=0			for event in self.improvement[season]:				countTotal+=1				averageTotal=(averageTotal*(countTotal-1)+self.improvement[season][event])/countTotal				countSeason+=1				averageSeason=(averageSeason*(countSeason-1)+self.improvement[season][event])/countSeason			self.averageImprovement[season]=averageSeason		self.totalAverageImprovement=averageTotal		if oneSeason==None: return averageTotal		if oneSeason in self.averageImprovement: return self.averageImprovement[oneSeason]		return None	def assignRest(self): #assigns rest to all swims that I've done		self.getMedianTaperTimes()		for season in self.medianTaperTimes:			for event in self.medianTaperTimes[season]:				for swim in self.events[season][event]:					if swim.diving:	#we will allow for swimming divers						continue					swim.rest=self.medianTaperTimes[season][event]/swim.time	def findTopTimes(self,startDate='',endDate='',events='all'):		if not startDate: startDate=Season().start		if not endDate: endDate=Season().end		topSwims={}		if events=='all':			eventLoop=self.events[Season(startDate)]		else:			eventLoop=events		for event in eventLoop:			for swim in events[Season(startDate).name][event]:				if topSwims[event]==None or topSwims[event].time > swim.time:					topSwims[event]=swim		return topSwims	def taper(self,event,season=None,debug=False,justTime=False):		if not season:			season=Season()		lastNon=self.getMedianNonTaperTimes(season-1,event)		thisNon=self.getMedianNonTaperTimes(season,event)		lastTaper=self.getMedianTaperTimes(season-1,event)		if debug:			print lastNon			print thisNon			print lastTaper		if lastNon and thisNon and lastTaper:			change=.515*(thisNon/lastNon-1)*.995			time = lastTaper*(change+1)		elif lastTaper:			time = lastTaper*.995		elif not thisNon:			return None		else:			time = thisNon*.96		if justTime: return time		return Swim(name=self.name,team=self.team,event=event,time=time,gender=self.gender,year=self.year)	def getTimeVariance(self,cutoff=1,tapers=True):		times={}		if tapers==True: swims=self.events		else: swims=self.taperTimes		for season in swims:			for event in swims[season]:				times[event]=[]				for swim in swims[season][event]:					times[event].append(swim)		var=[]		for event in times:			if len(times[event])<cutoff: continue			mean=sum(times[event])/len(times[event])			var.append((self.name,mean,event,np.std(times[event]),len(times[event])))		return var	def __str__(self):		return self.name	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name	def __hash__(self):		return hash(self.name)'''stores a team's data'''class Team:	def __init__(self, name, database):		self.database = database		self.name = name		if self.name in database.teamMeets:			self.meets = database.teamMeets[self.name]		else:			self.meets = {}		self.topRelays = {}		self.swimmers = {}		self.relays = {}		self.topDuals = {} #cache top duals		self.averageImprovement = {}		self.averageTaper = None		self.totalAverageImprovement = None	def topDual(self, season, debug=False, includeEvents=requiredEvents, gender='Men'):		if debug: print self.name, self.meets		if season in self.topDuals:			if debug: print 'cached'			return self.topDuals[season]		#now we will swim the season's meets against each other		topMeet = None		if not season in self.meets:			return None		for meetName in self.meets[season]:			meet = Meet(meetName, gender=gender, teams=[self.name])  # this will actually load the data			if not meet.isDual():				continue			if debug:				print 'testing ' + meet.name			if not topMeet:				topMeet = meet				continue			result = self.database.swimMeet([[self.name, topMeet, 'old'], [self.name, meet, 'new']],									   includeEvents=includeEvents, selectEvents=True)  # token names			score = result.teamScores()			if debug:				print score				result.printout()			if score and score[0][0]=='new':				topMeet = meet			meet.reset(teams=True)			topMeet.reset(teams=True)		if not topMeet:			self.topDuals[season] = None			return None		self.topDuals[season] = topMeet		if debug: print 'top '+ self.topDuals[season].name		return self.topDuals[season]	def getAverageImprovement(self, season=None):		if season==None and self.totalAverageImprovement: return self.totalAverageImprovement		elif season in self.averageImprovement: return self.averageImprovement		countTotal=0		averageTotal=0		for season in self.swimmers:			#print 'a-----------------------------------------------'			#print season			countSeason=0			averageSeason=0			for swimmer in self.swimmers[season]:				#print '-------------------'				#print swimmer				improvement=swimmer.getAverageImprovement(season)				if improvement:					countTotal+=1					averageTotal=(averageTotal*(countTotal-1)+improvement)/countTotal					countSeason+=1					averageSeason=(averageSeason*(countSeason-1)+improvement)/countSeason			self.averageImprovement[season]=averageSeason		self.totalAverageImprovement=averageTotal		if season==None: return averageTotal		if season in self.averageImprovement: return self.averageImprovement[season]		return None	def getAverageTaper(self, season='all', top=False):		if self.averageTaper: return self.averageTaper		count=0		average=0		if season=='all':			for season in self.swimmers:				for swimmer in self.swimmers[season]:					tapers=swimmer.getTapers(top=top)					for season in tapers:						for event in tapers[season]:							average=(average*count+tapers[season][event])/(count+1)							count=count+1		return average	def __str__(self):		return self.name	def __eq__(self, s):		if self.name == s:			return True		if not type(s)==type(self): return False #not called on a season		return self.name==s.name	def __hash__(self):		return hash(self.name)class Conference:	def __init__(self, name, division=None, teams=set()):		self.division = division		self.teams = teams		self.name = name	def addTeam(self, team):		self.teams.add(team)'''this class contains a swim meetscores itself'''class Meet:	def __init__(self, name=None, events=allEvents, gender=None, topSwim=True, teams=None):		self.gender = gender  # None means both		self.teams = []		self.scores = None		self.eventSwims = {}		self.events = events		self.name = name  # named meets are ones that actually happened		self.date = None		self.season = None		if self.name:			if not gender:				genders = ['Men', 'Women']			else:				genders = [gender]			if topSwim:				if self.teams:					for swim in Swim.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team).where(Swim.meet==name,																					Swim.gender << genders,																					Swim.event << list(events),																					Swim.team << list(teams)).group_by(						Swim.name, Swim.event, Swim.team):						self.addSwim(Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender, meet=name,									  team=swim.team))				else:					for swim in Swim.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team).where(Swim.meet==name,																					Swim.gender << genders,																					Swim.event << list(events)).group_by(						Swim.name, Swim.event, Swim.team):						self.addSwim(Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender, meet=name,									  team=swim.team))			else:				for swim in Swim.select().where(Swim.meet==name, Swim.event << list(events), Swim.gender << genders):					self.addSwim(swim)	def reset(self, teams=False, times=False):		for swim in self.getSwims():			if teams:				swim.scoreTeam = None			if times:				swim.scoreTime = None	#sees if any swims are in the meet	def isEmpty(self):		for event in self.eventSwims:			if not self.eventSwims[event]==[]:				return False		return True	def isDual(self):		return len(self.teams) == 2	def getSwims(self, team='all', relays=True, splits=False, ind=True):		swims=set()		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if ind and (swim.team == str(team) or team=='all') and (relays or not swim.relay):					swims.add(swim)				if splits and swim.relay and (team=='all' or swim.team == str(team)):					for split in swim.swims:						swims.add(split)		return swims	def addSwim(self, swim):		if not swim.getScoreTeam() in self.teams:			self.teams.append(swim.getScoreTeam())		if self.name and not self.date or not self.season:  # without a name, its a dummy meet			self.date=swim.date			self.season=swim.season		if not swim.event in self.eventSwims:			self.eventSwims[swim.event] = []		self.eventSwims[swim.event].append(swim)	def addSwims(self, swims):		for swim in swims:			self.addSwim(swim)	def removeSwimmer(self, name):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.name==name:					self.eventSwims[event].remove(swim)	def getEvents(self, events=''):		myEvents = set(self.eventSwims.keys())		if events=='':			if self.events == None:				events = allEvents			else:				events = self.events		events = set(events) & set(myEvents)		return events	def eventVariance(self):		timeVar={}		self.place()		for event in self.eventSwims:			average=0			count=0			for i in range(len(self.eventSwims[event])-1):				timeDif=abs(self.eventSwims[event][i].time-self.eventSwims[event][i+1].time) #time dif between this and next place				average=(average*count+timeDif)/(count+1) #running average				count+=1			timeVar[event]=average		return timeVar	'''	decides top events for each swimmer	top swimmers are decided by highest scoring event right now	unlimited divers	'''	def topEvents(self, teamMax=17, indMax=3, totalMax=8, events=''):		self.place()		conference = Meet()		indSwims = {}		relaySwims = {}		teamSwimmers = {}		teamDivers = {}		drops = []		relayEvents = set()		events = self.getEvents(events)		for team in self.teams:			teamSwimmers[team]=0			teamDivers[team]=0		for event in events:  # we will keep relays as is, but count them towards total swims			if re.search('Relay', event):				relayEvents.add(event)				while not self.eventSwims[event] == []:  # move relays over to new meet					relay = self.eventSwims[event].pop()					conference.addSwim(relay)					#for swim in relay.swims:					#	if swim.name in relaySwims:					#		relaySwims[swim.name]+=1					#	else:					#		relaySwims[swim.name]=1		for event in relayEvents:			events.remove(event)		#pare down		self.place()		for event in self.eventSwims:			if len(self.eventSwims[event]) > 100:				self.eventSwims[event] = self.eventSwims[event][:99] #start with top 100 times		#now make sure that each person swims their top events		preEvent = None		nextEvent = None		while not self.isEmpty():			for event in events:				drop=True  # just allow us to enter the loop				while drop == True and not self.eventSwims[event]==[]:  # we need to loop on an event until we find				# someone who is actually in it					drop = False					#print self.eventSwims[event]					if self.events and type(self.events) == type([]):						if not self.events.index(event) == 0:							preEvent = self.events[self.events.index(event)-1]						if not self.events.index(event)==len(self.events)-1:							nextEvent = self.events[self.events.index(event)+1]					newSwim = self.eventSwims[event].pop(0)					if preEvent in conference.eventSwims:						for swim in conference.eventSwims[preEvent]:							if newSwim.name==swim.name:								drops.append(newSwim)								drop=True								break					if nextEvent in conference.eventSwims:						for swim in conference.eventSwims[nextEvent]:							if newSwim.name==swim.name:								drop=True								drops.append(newSwim)								break					if drop:  # already swimming previous or next event						continue					if not newSwim.name in indSwims:  # fixed to still add swim when all 18 swimmers there						if teamSwimmers[newSwim.getScoreTeam()] < teamMax:							indSwims[newSwim.name]=0							teamSwimmers[newSwim.getScoreTeam()]+=1						else:							drops.append(newSwim)							continue					if indSwims[newSwim.name]<indMax and ((not newSwim.name in relaySwims) or indSwims[newSwim.name]+relaySwims[newSwim.name] < totalMax):						conference.addSwim(newSwim)						indSwims[newSwim.name]+=1					else:						drops.append(newSwim)						drop = True  # can't swim any more events		self.eventSwims=conference.eventSwims		return drops	'''	adds top relays using same method in database	'''	def addTopRelays(self, number, team, database):		relays = [event for event in self.events if re.search('Relay',event)]		return database.topRelays(relays, team, self)	'''	creates the best lineup for the given team against another set lineup	no two person swapping instabilities	->must implement relay creation and switching	'''	def lineup(self, team, database=None, debug=False, splits=False):		team=str(team)		#take top three relays in each event		#if database:		#	dropSplits = database.topTimes()		#	dropSplits = [split for split in dropSplits if split.split]		drops = self.topEvents(30, 3, 4)		self.place()		'''		now we have a starting point		'''		extras = {}  # double dictionary,swim:event		for swim in drops:  # + dropSplits			if not swim.name in extras:				extras[swim.name] = {}			extras[swim.name][swim.event]=swim		if debug: self.printout()		toCheck = self.getSwims(team, False, splits=splits)		while len(toCheck) > 0:  # double loop on all swims, trying to see if more points are scored if swapped			swim1=toCheck.pop()			swims=self.getSwims(team, False, splits=splits)			while len(swims) > 0:				swim2=swims.pop()				if swim1==swim2 or swim1.event==swim2.event:					continue				#make sure swims exist				if extras.has_key(swim2.name) and extras.has_key(swim1.name) and extras[swim1.name].has_key(swim2.event) and extras[swim2.name].has_key(swim1.event):					self.score()					if debug:						print self.score()						print team					oldScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]					(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)					self.score()					newScore = self.teamScores(sorted=False)[team] # [swim1.event,swim2.event]					if oldScore < newScore: # swap in new swims						if debug:							print "swap"							print newSwim1.name, newSwim1.event							print newSwim2.name, newSwim2.event						swims.add(newSwim1)						swims.add(newSwim2)						if swim1 in swims:							swims.remove(swim1)						if swim2 in swims:							swims.remove(swim2)						for swim in (newSwim1, newSwim2):							if newSwim1.split: #re-add swims in those events								for relay in self.eventSwims[newSwim1.fromRelay]:									if relay.team==team:										for split in relay.swims:											if not split in toCheck:												toCheck.add(split)							else:								for swim in self.eventSwims[newSwim1.event]:									if not swim in toCheck and swim.team==team:										toCheck.add(swim)						if swim2 in toCheck: #make sure second swim is not checked again							toCheck.remove(swim2)						swim1=toCheck.pop() #start checking next swim					else: # revert to old lineup						self.swap(newSwim1,newSwim2,extras)		self.score()	'''	given two old swims	will swap two swims, returns two new swims	'''	def swap(self, swim1, swim2, extras):		newSwim1=extras[swim1.name][swim2.event]		newSwim2=extras[swim2.name][swim1.event]		if self.eventSwims.has_key(swim2.event) and swim2 in self.eventSwims[swim2.event]: # ind swim			self.eventSwims[swim2.event].remove(swim2)			self.addSwim(newSwim1)		else: #gotta be a relay			self.relaySwap(swim2,newSwim1)		if self.eventSwims.has_key(swim1.event) and swim1 in self.eventSwims[swim1.event]: # ind swim			self.eventSwims[swim1.event].remove(swim1)			self.addSwim(newSwim2)		else: #gotta be a relay			self.relaySwap(swim1,newSwim2)		if not extras.has_key(swim1.name):			extras[swim1.name]={}		extras[swim1.name][swim1.event]=swim1		if not extras.has_key(swim2.name):			extras[swim2.name]={}		extras[swim2.name][swim2.event]=swim2		return (newSwim1,newSwim2)	'''	swaps someone into a relay	given old (swim1) and new (swim2) split	'''	def relaySwap(self, swim1, swim2):		for relay in self.eventSwims[swim1.fromRelay]:			if swim1 in relay.swims:				relay.changeSwimmer(swim1,swim2)				return	def taper(self):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				swim.taper()	'''	places the meet	'''	def place(self, events='', storePlace=False):		events=self.getEvents(events)		for event in events:			if not event in self.eventSwims or len(self.eventSwims[event]) == 0:				continue			self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=False)			#else:  #diving			#	self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(),			# reverse=True)			if storePlace:				for idx, swim in enumerate(self.eventSwims[event]):					swim.place = idx+1	'''	scores the meet	'''	def score(self, dual=None, events='', heatSize=8, heats=2, debug=False):		events = self.getEvents(events)		if debug:			print events		if dual is None:			if len(self.teams)==2:				dual=True			else:				dual=False		self.place(events)		max = 16		if heats == 3:			pointsI = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif heats == 2:			pointsI = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		if heatSize == 6:			pointsI = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		pointsR = [x*2 for x in pointsI]		if dual:			max = 3			pointsI = [9, 4, 3, 2, 1]			pointsR = [11, 4, 2]		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0			if debug:				print 'scoring', event			place = 1			teamSwims = {}			for swim in self.eventSwims[event]:				swim.score = None  # reset score				if not 'Relay' in swim.event:  # should use real relay var					team = swim.getScoreTeam()					if place > len(pointsI) or (team in teamSwims) and teamSwims[team] >= max:						swim.score = 0					else:						swim.score = pointsI[place-1]						if not team in teamSwims:							teamSwims[team] = 0						teamSwims[team] += 1						place += 1				else:					team = swim.team					if place > len(pointsR) or (team in teamSwims) and teamSwims[team] >= max:						swim.score = 0					else:						swim.score = pointsR[place-1]						if not team in teamSwims:							teamSwims[team] = 0						teamSwims[team] += 1						place += 1		return self.teamScores(events)	def teamScores(self, events='', sorted=True):		events = self.getEvents(events)		teams = {}		for event in events:			if not event in self.eventSwims: continue			for swim in self.eventSwims[event]:				team = swim.getScoreTeam()				if not team in teams:					teams[team] = 0				teams[team] += swim.getScore()		if not sorted:			return teams		scores = []		for team in teams:			scores.append([team, teams[team]])		scores.sort(key=lambda team: team[1], reverse=True)		self.scores = scores		return scores	def winningTeam(self):		if not self.scores: self.teamScores()		if len(self.scores)<1 or len(self.scores[0])<1: return None		return self.scores[0][0]	'''	lists swimmers by team and by points scored	'''	def scoreReport(self, printout=True, repressSwim=False, repressTeam=False):		scores={}		for team in self.teams:			scores[team]={'total': 0, 'year': {}, 'swimmer': {}, 'event': {}}		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.relay:					name = 'Relays'				else:					name = swim.name				if repressSwim and swim.score == 0:					continue   # repess zero scores				if not name in scores[swim.team]['swimmer']:					scores[swim.team]['swimmer'][name] = 0				if not event in scores[swim.team]['event']:					scores[swim.team]['event'][event]=0				scores[swim.team]['swimmer'][name] += swim.score				scores[swim.team]['total'] += swim.score				scores[swim.team]['event'][event] += swim.score				if swim.year:					if not swim.year in scores[swim.team]['year']:						scores[swim.team]['year'][swim.year] = 0					scores[swim.team]['year'][swim.year] += swim.score		if printout:			for team in sorted(scores['swimmer'],key=scores['swimmer']['total']):				print '-------------------------------'				print team				for name in sorted(scores['swimmer'][team], key=scores['swimmer'][team].__getitem__):					print name.join(scores['swimmer'][team][name].ljust(25))		if repressTeam:			zeroTeams=set()			for team in scores:				if scores[team]['total'] == 0:					zeroTeams.add(team)			for team in zeroTeams:				del(scores[team])		return scores	def printout(self, events=''):		events=self.getEvents(events)		for event in events:			if event not in self.eventSwims: continue			print "-------------------------------------------------------------------------------------"			print "Event: " + event			for swim in self.eventSwims[event]:				if swim.score:					print swim.printScore().lstrip()+"\t"+str(swim.score)				else:					print swim.printScore().lstrip()		print self.scores	def scoreString(self, showNum='all', showScores=True, showPlace=False):		self.score()		string = {}		events=self.getEvents('')		for event in events:			if event not in self.eventSwims: continue			string[event]=[]			place = 0			for swim in self.eventSwims[event]:				place += 1				if not showNum=='all' and place > showNum:					break				swimAry = re.split('\t', swim.printScore(gender=False).strip())				if showPlace:					swimAry.insert(0, place)				if swim.score and showScores:					swimAry.append(str(swim.score))					string[event].append(swimAry)				else:					string[event].append(swimAry)		string["scores"]=self.teamScores()		return string	def __str__(self):		return self.name	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name and self.date==s.date	def __hash__(self):		return hash(self.name)^hash(self.date)'''full database methods'''class SwimDatabase:	def __init__(self):		self.results = {}  # cache dual results		self.teams = {}		self.conferences = getConfs()		if not self.conferences:			self.conferences = {'D1': {}, 'D2': {}, 'D3': {}}			for swim in Swim.select(Swim.conference, Swim.division, Swim.team).distinct(Swim.team):				if swim.division=='':					continue				if not swim.conference in self.conferences[swim.division]:					self.conferences[swim.division][swim.conference] = set()				self.conferences[swim.division][swim.conference].add(swim.team)		self.teamMeets = getTeamMeets()		if not self.teamMeets:			self.teamMeets = {}			for team in Swim.select(Swim.team).distinct():				teamName = team.team				for swim in Swim.select(Swim.meet, Swim.team, Swim.season).where(Swim.team == teamName).distinct(						Swim.meet):					if not teamName in self.teamMeets:						self.teamMeets[teamName] = {}					if not swim.season in self.teamMeets[teamName]:						self.teamMeets[teamName][swim.season] = set()					self.teamMeets[teamName][swim.season].add(swim.meet)			storeTeamMeets(self.teamMeets)		self.teams = {}		for swim in Swim.select(Swim.team).distinct():			self.teams[swim.team] = Team(name=swim.team, database=self)	def topDual(self, season=thisSeason(), events=requiredEvents, debug=False, teams='all', gender='Men'):		if teams == 'all':			teams = self.teams		meets = {}		wins = {}		losses = {}		for team in teams:			if not team in self.teams:				self.teams[team] = Team(team, self)			if not self.teams[team].topDual(season, debug=debug, gender=gender):				continue			meets[team] = self.teams[team].topDual(season, debug=debug, gender=gender)  # its cached			wins[team] = 0			losses[team] = 0			#if debug: print team, '\t\t', meets[team]		if debug: print '-----------'		for team1 in meets:			for team2 in meets:				if team1 == team2:					continue				if not team1 in self.results:					self.results[team1] = {}				if not team2 in self.results:					self.results[team2] = {}				if team2 in self.results[team1] or team1 in self.results[team2]:  # reverse meet already swum					continue				newMeet = self.swimMeet([[team1, meets[team1]], [team2, meets[team2]]], includeEvents=events,									  selectEvents=False)  # should convert to dual form				self.results[team1][team2] = newMeet.winningTeam()				self.results[team2][team1] = newMeet.winningTeam()				if debug: print team1, team2, newMeet.winningTeam()				if self.results[team1][team2] == team1: # team1 wins					wins[team1] += 1					losses[team2] += 1				elif self.results[team1][team2] == team2:  # team2 wins, otherwise no points					wins[team2] += 1					losses[team1] += 1		if debug:			for (index, team) in enumerate(sorted(wins.items(), key=operator.itemgetter(1), reverse=True)):				print str(index)+'.',team[0]+':',team[1],'-',losses[team[0]]		return meets, wins, losses	'''	creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	'''	def swimMeet(self, teamMeets, gender=None, debug=False, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False):		meet = Meet()		teams = set()		if includeEvents == 'all':			includeEvents = allEvents		commonEvents = allEvents		for teamMeet in teamMeets:			newTeamName = None			newTeam = teamMeet[0]			newMeet = teamMeet[1]			if isinstance(newMeet, basestring):  # just a name				newMeet = Meet(name=newMeet, gender=gender, teams=set(newTeam))			commonEvents = commonEvents & set(newMeet.eventSwims.keys())			if debug:				print set(newMeet.eventSwims.keys())				newMeet.printout()			if len(teamMeet) == 3:  # maybe pass in new team name				newTeamName = teamMeet[2]			swims = newMeet.getSwims(newTeam)			duplicate = 1			for swim in swims:				if newTeamName:					swim.scoreTeam = newTeamName				elif newTeam in teams:  # duplicate team and no new name specified					duplicate += 1					swim.scoreTeam = swim.team + ' ' + str(duplicate)				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		if len(meet.teams) == 2:			if selectEvents:				meet.topEvents(25, 3, 4)			meet.events = (commonEvents | includeEvents) - excludeEvents			meet.score(dual=True)		else:			if selectEvents:				meet.topEvents()			meet.score()		if debug: meet.printout()		return meet	'''	optimal lineup creator	'''	def lineup(self, teams, meet, season=None, debug=False, resetTimes=False, events=eventsDualS, gender='Men'):		if not season:			season = thisSeason()		meet.events = events		if debug:			print meet.getEvents(), events		meet.addSwims(self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=True).getSwims())		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		meet.place()		if debug:			meet.printout()		if len(teams) == 1:			meet.lineup(teams.pop(), self, debug=debug)		else:			meet.topEvents(17, indMax=3, totalMax=4)		return meet	'''	doesn't really do anything	'''	def swimMeetPredictor(self, teams):		pass	'''	returns meet of top times	'''	def topTimes(self, events=None, teams=MIAC, season=None, gender='Men', topTimes=True, meetForm=True):		if not events:			events = allEvents		if teams == 'all':			teams = self.teams		if not season:			season = thisSeason()  # use current season		if meetForm:			topMeet = Meet(events=events)		else:			swimmers = {}		if topTimes:			for swim in Swim.select(Swim.name, Swim.event, Swim.team, fn.Min(Swim.time), Swim.year).where(						Swim.gender==gender, Swim.season==season, Swim.event << list(events), Swim.team << list(							teams)).group_by(Swim.name, Swim.event, Swim.team, Swim.year):				if meetForm:					topMeet.addSwim(Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender, team=swim.team,									  season=season, meet=swim.meet, year=swim.year))				else:					if not swim.name in swimmers:						swimmers[swim.name] = {}					if not swim.season in swimmers[swim.name]:						swimmers[swim.name][swim.season] = {}					if not swim.event in swimmers[swim.name][swim.season]:						swimmers[swim.name][swim.season][swim.event] = Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender,										  team=swim.team, season=season, meet=swim.meet, year=swim.year)		else:			for swim in Swim.select(Swim.name, Swim.event, Swim.team, fn.Avg(Swim.time)).where(						Swim.gender==gender,					Swim.season==season, Swim.event << list(events), Swim.team << list(teams)).group_by(Swim.name,																								   Swim.event,																						   Swim.team):				if meetForm:					topMeet.addSwim(Swim(name=swim.name, event=swim.event, time=swim.avg, gender=gender, team=swim.team,									  season=season))				else:					if not swim.name in swimmers:						swimmers[swim.name] = {}					if not swim.season in swimmers[swim.name]:						swimmers[swim.name][swim.season] = {}					if not swim.event in swimmers[swim.name][swim.season]:						swimmers[swim.name][swim.season][swim.event] = Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender,										  team=swim.team, season=season)		topMeet.place()		if meetForm:			return topMeet		return swimmers	def conference(self, teams=MIAC, season=None, topTimes=True, gender='Men'):		events = eventsChamp3		if not season:			season = thisSeason()  # use current season		conference = self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=topTimes)		conference.topEvents(17)		conference.score()		return conference	'''	tests predictions	'''	def taperTest(self):		for swimmer in self.swimmers.values():			tapers = swimmer.getMedianTaperTimes()			nonTapers = swimmer.getMedianNonTaperTimes(average=False)			for season in tapers:				for event in tapers[season]:					if season in nonTapers and event in nonTapers[season]:						absDif = abs(tapers[season][event] - nonTapers[season][event])						perDif = abs(tapers[season][event] - nonTapers[season][event])/abs(tapers[season][event] +																						   nonTapers[season][event])						print swimmer.name+','+swimmer.gender+','+swimmer.team+','+event+','+str(absDif)+','+str(perDif)	def preFinalVariance(self, meetNames):		for meetName in meetNames:			meet = self.meets[meetName]			if not meet.eventSwimsPrelims: return			meet.place('all',True)			placeDif={}			timeDif={}			for event in meet.eventSwims:				placeDif[event]=[]				timeDif[event]=[]				for finalsSwim in meet.eventSwims[event]:					for prelimsSwim in meet.eventSwimsPrelims[event]:						if finalsSwim.name==prelimsSwim.name:							placeDif.append(meet.eventSwims[event].index(finalsSwim)-meet.eventSwimsPrelims[event].index(prelimsSwim))							timeDif.append(abs(prelimsSwim.time-finalsSwim.time)/((prelimsSwim.time+finalsSwim.time)/2))		''' fix with std		if not outliers: #throw away swims >2 std from mean			for event in placeDif:				av=average(placeDif[event])				stdDev=std(placeDif[event])				for dif in placeDif[event]:					if abs(dif-av)>2*stdDev:						placeDif.remove(dif)				av=average(timeDif[event])				stdDev=std(placeDif[event])				for dif in placeDif[event]:					if abs(dif-av)>2*stdDev:						placeDif.remove(dif)		'''	def taperPredictions(self, years='', teams='all', event='all', taperDate=None):		seasons=[]		if years=='': seasons.append(Season())		else:			for year in years:				seasons.append(Season(year))		if teams=='all':			teams=self.teams		taperSwims={}		for season in seasons:			for team in teams:				for swimmer in self.teams[team]:					nonTaper=swimmer.getMedianNonTaperTimes(season=season)					taper=swimmer.getMedianTaperTimes(season=season)					for event in taper:						pass	#not finished	def improvement(self, gender='Men', teams=MIAC, events=allEvents):  # looks at average taper to next year		season1 = self.topTimes(gender=gender, events=events, teams=teams, topTimes=true, season=season1)		season2 = self.topTimes(gender=gender, events=events, teams=teams, topTimes=true, season=season2)		for swimmer in season1.getSwims:			pass		allImprovement={}		for swimmer in self.swimmers:			#if (not self.swimmers[swimmer].team in self.conferences[conference]) and (conference!=None): continue			improvement=self.swimmers[swimmer].getImprovement()			if not improvement: continue			for season in improvement:				for event in improvement[season]:					if not event in allImprovement: allImprovement[event]=[]					if np.abs(improvement[season][event])<.07: allImprovement[event].append(improvement[season][event])#toss outliers		drops={}		for event in allImprovement:			avgDrop=round(np.average(allImprovement[event])*100,3)			stdAvgDrop=round(np.std(allImprovement[event])*100,3)			drops[event]=(avgDrop,stdAvgDrop)			#print event,': ',avgDrop,'+-',stdAvgDrop			#P.hist(allImprovement[event])			#P.show()		return drops	def getTopTimes(self):		topTimes={}		for swimName in self.swims:			swim = self.swims[swimName]			if not swim.event in topTimes:				topTimes[event]=swim.time			else:				if swim.time < topTimes[event]:					topTimes[event]=swim.time		return events	def improvementTimes(self, printout, division, gender):		timeDrops={}		for swimmer in self.swimmers:			self.swimmers[swimmer].findImprovement()			swimmerDrops=self.swimmers[swimmer].improvementTimes			for season in swimmerDrops:				for event in swimmerDrops[season]:					if not event in timeDrops:						timeDrops[event]=[]					t1=swimmerDrops[season][event][0]					t2=swimmerDrops[season][event][1]					if abs(t1/t2-1)>.1: continue					timeDrops[event].append((t1,t2))					print gender+','+division+','+event+','+self.swimmers[swimmer].team+','+str(round((t1-t2)/((t1+t2)/2),5))+','+str((t1+t2)/2)		return timeDrops	def taperDrop(self):		difs={}		for swimmerName in self.swimmers:			swimmer=self.swimmers[swimmerName]			tapers=swimmer.getTapers()			taperTimes=swimmer.getMedianTaperTimes()			nonTaperTimes=swimmer.getMedianNonTaperTimes(True)			for season in tapers:				if season+1 in taperTimes and season+1 in nonTaperTimes:					for event in taperTimes[season+1]:						if event in nonTaperTimes[season+1] and event in tapers[season]:							if not event in difs:								difs[event]=[]							dif=(nonTaperTimes[season+1][event]*(1+tapers[season][event]))/taperTimes[season+1][event]							if abs(dif-1)>.07: continue #toss outliers							difs[event].append(dif)		for event in difs:			print event			print round(np.std(difs[event])*100,3)			np.average(difs[event])			#P.hist(difs[event])			#P.show()	def eventVariance(self, printout=False):		events={}		counts={}		for swimmerName in self.swimmers:			variance=self.swimmers[swimmerName].getTimeVariance(cutoff=2, tapers=False)			if variance!=[]:				for swim in variance:					event=swim[2]					var=swim[3]					num=swim[4]					if event not in events: events[event]=0					if event not in counts: counts[event]=0					events[event]=(events[event]*counts[event]+var*num)/(counts[event]+num)					counts[event]+=num					if printout: print swim		return events	def dualPlace(self):		print 'gender,event,time,score'		for meet in self.meets.values():			if not len(meet.teams)==2: continue			meet.score()			for swim in meet.getSwims():				print swim.gender+','+swim.event+','+str(swim.time)+','+str(swim.score)	def conferencePlace(self, division, gender, newSwims):		newEvents = set()		for swim in newSwims:			newEvents.add(swim[0])		confMeets = {}		with open('./data/' + division + gender + '.csv') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet					confMeets[confName].addSwims(Meet(name=meetName, events=newEvents, gender=gender,													  topSwim=True).getSwims())				else:					confMeets[confName] = Meet(name=meetName, events=newEvents, gender=gender, topSwim=True)		confScores = {}		for conference in confMeets:			confMeet = confMeets[conference]			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScoresif __name__ == "__main__":	database = SwimDatabase()	print database.teams	#teams=set()	#for conf in database.conferences['D1']:	#	for team in database.conferences['D1'][conf]:	#		teams.add(team)	#database.topDual(teams=teams)	#database.conference(teams=teams)	#conf = database.conference()	#conf.printout()