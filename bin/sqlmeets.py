import reimport numpy as npimport operatorfrom datetime import date as Date, timedeltafrom peewee import *import os, urlparse, timefrom scipy.stats import norm, linregress#simport matplotlib.pyplot as pltfrom swimdb import Improvement, Team, TeamStats, TeamSeason, Swimmer, Swim, TeamMeet, swimTime, getSkewDistfrom swimdb import TempMeet as Meetfrom events import eventOrderInd, eventsChamp3, eventsChamp, eventsDualS, requiredEvents, allEvents, eventOrderfrom math import logpointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]# setup database connectiondb_proxy = Proxy()db = Proxy()'''events contained within a relay'''def relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']def thisSeason():	today = Date.today()	if today.month > 6:		return today.year + 1	return today.yeardef rejectOutliers(dataX, dataY=None, l=5, r=6):	u = np.mean(dataX)	s = np.std(dataX)	if dataY:		data = zip(dataX, dataY)		newList = [i for i in data if (u - l*s < i[0] < u + r*s)]		newX, newY = zip(*newList)		return list(newX), list(newY)	else:		newList = [i for i in dataX if (u - l*s < i < u + r*s)]	return newListdef ECDF(data):	def cdf(num):		d = data		l = float(len(d))		return (sum(1 for i in d if i < num) + sum(.5 for i in d if i==num))/l	return cdfdef getConfs():	confs = {'D1': {'Men': {}, 'Women': {}}, 'D2': {'Men': {}, 'Women': {}}, 'D3': {'Men': {}, 'Women': {}}}	allTeams = {'Men': {'D1': [], 'D2': [], 'D3': []}, 'Women': {'D1': [], 'D2': [], 'D3': []}}	for newTeam in TeamSeason.select(TeamSeason.team, TeamSeason.conference, TeamSeason.division,									 TeamSeason.gender).distinct(TeamSeason.team):		if newTeam.conference not in confs[newTeam.division][newTeam.gender]:			confs[newTeam.division][newTeam.gender][newTeam.conference] = set()		confs[newTeam.division][newTeam.gender][newTeam.conference].add(newTeam.team)		allTeams[newTeam.gender][newTeam.division].append(newTeam.team)		for division in ['D1', 'D2', 'D3']:			allTeams['Men'][division].sort()			allTeams['Women'][division].sort()	return confs, allTeamsdef nextYear(year):	if year=='Freshman':		return 'Sophomore'	if year=='Sophomore':		return 'Junior'	if year=='Junior':		return 'Senior'	return Nonedef grad(f, x, y, h=0.0025):	dx = (f(x, y) - f(x+h, y))/h	dy = (f(x, y) - f(x, y+h))/h	return dx, dydef gradientDescent(f, x0, y0, step=.001):	for i in range(10):		dx, dy = grad(f, x0, y0)		length = ((dx**2 + dy**2) ** .5)		print 'delta:', dx, dy		x0 += step * dx / length		y0 += step * dy / length		if x0 < 0:			x0 = 0.001		if y0 < 0:			y0 = 0.001		#print x0, y0	return x0, y0def frange(x, y, jump):	while x < y:		yield x		x += jumpdef date2week(d):	if d > Date.today():		d = Date.today()	if d.month > 6:		season = d.year + 1	else:		season = d.year	startDate = Date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017	weeksIn = int((d - startDate).days / 7)	return weeksIndef week2date(week, season=None):	if not season:		season = thisSeason()	startDate = Date(season - 1, 10, 16)  # use Oct 15 as the start date, prolly good for 2017	if week == None:		return Date.today()	simDate = startDate + timedelta(weeks=week)	if simDate > Date.today():  # can't simulate with future data		simDate = Date.today()	return simDate'''full database methods'''class SwimDatabase:	def __init__(self, database):		global swimDatabase		swimDatabase = self		db_proxy.initialize(database)		self.database = database		self.dist = {}		self.results = {}  # cache dual results		self.teams = {}		self.meetCache = {}		self.eventImpCache = {}		self.topScoreCache = {}		self.topTimesCache = {}		self.teamRankCache = {}		self.swimmerRankCache = {}		self.conferences, self.allTeams = getConfs()	def topDual(self, season=thisSeason(), events=requiredEvents, debug=False, teams='all', gender='Men'):		if teams == 'all':			teams = self.teams		meets = {}		wins = {}		losses = {}		for team in teams:			if not team in self.teams:				self.teams[team] = Team(team, self)			if not self.teams[team].topDual(season, debug=debug, gender=gender):				continue			meets[team] = self.teams[team].topDual(season, debug=debug, gender=gender)  # its cached			wins[team] = 0			losses[team] = 0			#if debug: print team, '\t\t', meets[team]		if debug: print '-----------'		for team1 in meets:			for team2 in meets:				if team1 == team2:					continue				if not team1 in self.results:					self.results[team1] = {}				if not team2 in self.results:					self.results[team2] = {}				if team2 in self.results[team1] or team1 in self.results[team2]:  # reverse meet already swum					continue				newMeet = self.swimMeet([[team1, meets[team1]], [team2, meets[team2]]], includeEvents=events,									  selectEvents=False)  # should convert to dual form				self.results[team1][team2] = newMeet.winningTeam()				self.results[team2][team1] = newMeet.winningTeam()				if debug: print team1, team2, newMeet.winningTeam()				if self.results[team1][team2] == team1: # team1 wins					wins[team1] += 1					losses[team2] += 1				elif self.results[team1][team2] == team2:  # team2 wins, otherwise no points					wins[team2] += 1					losses[team1] += 1		if debug:			for (index, team) in enumerate(sorted(wins.items(), key=operator.itemgetter(1), reverse=True)):				print str(index)+'.',team[0]+':',team[1],'-',losses[team[0]]		return meets, wins, losses	'''	creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	'''	def swimMeet(self, teamMeets, gender=None, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False, verbose=False):		meet = Meet()		teams = []		if includeEvents == 'all':			includeEvents = allEvents		commonEvents = allEvents  # start with all events and whittle down		for teamMeet in teamMeets:			newTeam = teamMeet['team']			newMeet = teamMeet['meet']			if 'season' in teamMeet:				season = teamMeet['season']			else:				season = None			if verbose: print isinstance(newMeet, basestring)			if isinstance(newMeet, basestring):  # just a name				newMeet = Meet(name=newMeet, gender=gender, teams=[newTeam], season=season)			commonEvents = commonEvents & set(newMeet.eventSwims.keys())			if verbose: print season, newMeet, newTeam			if verbose: print newMeet.eventSwims			# resolve duplicate names, first try season, then a number			newTeamName = None			if teams.count(newTeam) > 0:				newTeamName = newTeam + ' ' + season				if teams.count(newTeamName) > 0:					newTeamName += ' ' + str(teams.count(newTeamName))			if newTeamName:				teams.append(newTeamName)			else:				teams.append(newTeam)			# now apply to existing swims			for swim in newMeet.getSwims(newTeam):				if newTeamName:					swim.scoreTeam = newTeamName				meet.addSwim(swim)		if verbose: print meet		meet.reset(times=resetTimes)		if len(meet.teams) == 2:			if selectEvents:				meet.topEvents(25, 3, 4)				'''need to fix event selection for dual meets'''			meet.events = (commonEvents | includeEvents) - excludeEvents			meet.score(dual=True)		else:			if selectEvents:				meet.topEvents()			meet.events = eventsChamp3			meet.score()		return meet	'''	optimal lineup creator	'''	def lineup(self, teams, meet, resetTimes=False, events=None, gender='Men'):		if events:			meet.events = events		teamNames = []		for teamName in teams:			division = teams[teamName]['division']			if not 'season' in teams[teamName]:				season = thisSeason()			else:				season = teams[teamName]['season']			# add each team's top times to meet			team = TeamSeason.get(season=season, team=teamName, gender=gender, division=division)  # need division			topTimesMeet = team.topTimes(events=events)			# resolve duplicate names, first try season, then a number			newTeamName = None			if teamNames.count(teamName) > 0:				newTeamName = teamName + ' ' + season				if teamNames.count(newTeamName) > 0:					newTeamName += ' ' + str(teamNames.count(newTeamName))			if newTeamName:				teamNames.append(newTeamName)			else:				teamNames.append(teamName)			for swim in topTimesMeet.getSwims():				if newTeamName:					swim.scoreTeam = newTeamName				meet.addSwim(swim)		meet.reset(times=resetTimes)		meet.place()		# lineup optimize if creating lineup for just one team		if len(teamNames) == 1:			meet.lineup(teamNames.pop())		else:			meet.topEvents(17, indMax=3)		return meet	'''	top expected score for the whole team	'''	def topTeamScore(self, teamName, dual=True, season=thisSeason(), gender='Men', division='D3', weeksIn=None):		# convert the week to a date		simDate = week2date(weeksIn, season)		# cache off times?		if dual:			events = eventsDualS		else:			events = eventsChamp		team = TeamSeason.get(season=season, team=teamName, gender=gender, division=division)  # need division		topMeet = team.topTimes(events=events, dateStr=simDate)		topMeet.topEvents(teamMax=17, indMax=3)		if dual:			scores = topMeet.expectedScores(swimmers=6, division=division)		else:			scores = topMeet.expectedScores(swimmers=16, division=division)		if team in scores:			return scores[team]		return 0	'''	returns meet of average times	'''	def averageTimes(self, conf, season=None, gender='Men', division=None, date=None):		if type(date) == type(str):			date = Date(date)		if not season:			season = thisSeason()  # use current season		if not date:			date = Date.today()		topMeet = Meet()		if conf=='Nationals':			select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\				.where(TeamSeason.gender==gender, TeamSeason.division==division, TeamSeason.season==season, Swim.date < date)		else:			select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\				.where(TeamSeason.gender==gender, TeamSeason.conference==conf, TeamSeason.season==season, Swim.date < date)		qwery = select.select(Swim.name, Swim.event, fn.Avg(Swim.time), Swimmer.team, Swimmer.year).group_by(Swim.name,				Swim.event, Swimmer.team, Swimmer.year)		for swim in qwery:			time = swim.avg			if swim.event != '1000 Free':				newSwim = Swim(name=swim.name, event=swim.event, time=time, gender=gender, team=swim.swimmer.team,									  season=season, year=swim.swimmer.year, swimmer=swim.swimmer)				topMeet.addSwim(newSwim)		topMeet.place()		return topMeet	'''	returns meet of top times, start with top 75 in each event	'''	def topTimesNew(self, season, gender, conf, division=None, dateStr=None, limit=75):		transfers = False		if not dateStr:			meetDate = Date.today()			dateStr = str(meetDate.year) + '-' + str(meetDate.month) + '-' + str(meetDate.day)		newMeet = Meet()		if conf == 'Nationals':			'''				if transfers:					if swim.name == 'Ledecky, Katie': continue					if swim.name == 'Gonzalez, Hugo': swim.team='Virginia Tech'					if swim.name == 'Apple, Zachary': swim.team='Indiana'					if swim.name == 'Andison, Bailey': swim.team='Indiana'			'''			for swim in Swim.raw("SELECT event, time, name, team, date, year, meet, swimmer_id, rank FROM ( "					"SELECT event, time, name, team, date, year, meet, swimmer_id, division, season, gender, rank() "					"over (Partition BY event ORDER BY event, time) FROM top_swim "					"WHERE season=%s and gender=%s and division=%s and date<%s) ts WHERE rank<%s",					season, gender, division, dateStr, limit):				swim.gender = gender				swim.division = division				swim.conference = conf				swim.season = season				newMeet.addSwim(swim)		else:			for swim in Swim.raw("SELECT event, time, name, team, date, year, meet, swimmer_id, rank FROM ( "					"SELECT event, time, name, team, date, year, meet, swimmer_id, division, season, gender, rank() "					"over (Partition BY event ORDER BY event, time) "					"FROM top_swim WHERE season=%s and gender=%s and conference=%s and date<%s) ts WHERE rank<%s",					season, gender, conf, dateStr, limit):				swim.gender = gender				swim.division = division				swim.conference = conf				newMeet.addSwim(swim)		if '1000 Free' in newMeet.eventSwims:			del(newMeet.eventSwims['1000 Free'])		return newMeet	# simulates conference or national meet, must be real conference	def conference(self, season, gender, conf, division=None, dateStr=None, topTimes=True, update=False, taper=False,				   nextYear=False, teamMax=17):		if not season:			season = thisSeason()  # use current season		start = time.time()		if topTimes:			conference = self.topTimesNew(conf=conf, season=season, gender=gender, division=division, dateStr=dateStr)		else:  # use avg times			conference = self.averageTimes(conf=conf, season=season, gender=gender, division=division, date=dateStr)		if nextYear:  # estimate next year's results			conference.nextYear(self)			season += 1  # update the correct season		print time.time() - start		conference.events = eventsChamp3		conference.topEvents(teamMax=teamMax)		print time.time() - start		conference.score()		if taper:			conference.taper()		if update:			weeksIn = date2week(dateStr)			#print weeksIn			if conf == 'Nationals':				nats = True			else:				nats = False			conference.update(weeksIn=weeksIn, division=division, gender=gender, season=season, nats=nats)		return conference	'''	returns top 25 teams and caches ranking data	'''	def teamRank(self, division='D3', gender='Men', season=2016, num=25):		sentinelStr = division + gender + str(season) + str(num)		if sentinelStr in self.teamRankCache:			return self.teamRankCache[sentinelStr]		teamScores = {}		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.division==division,								TeamSeason.season==season):			teamScores[team.team] = team		teams = sorted(teamScores.values(), key=lambda t: t.getStrength(), reverse=True)[:num]		self.teamRankCache[sentinelStr] = teams		return teams	'''	Returns top swimmers in a conference by top 3 event ppts	'''	def swimmerRank(self, division='D3', gender='Men', season=2017, num=25, conference=None):		# make sure all ppts are saved to the db		if not conference:  # all conferences			for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,							TeamSeason.division==division, TeamSeason.season==season, Swimmer.ppts.is_null()):				swimmer.getPPTs()		else:			for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,					TeamSeason.division==division, TeamSeason.season==season, TeamSeason.conference==conference,					Swimmer.ppts.is_null()):				swimmer.getPPTs()		# return sorted list of top swimmers		swimmers = []		if not conference:  # all conferences			for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,					TeamSeason.division==division, TeamSeason.season==season,					Swimmer.ppts.is_null(False)).order_by(Swimmer.ppts.desc()).limit(num):				swimmers.append(swimmer)		else:			for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,					TeamSeason.division==division, TeamSeason.season==season, Swimmer.ppts.is_null(False),					TeamSeason.conference==conference).order_by(Swimmer.ppts.desc()).limit(num):				swimmers.append(swimmer)		return swimmers	# update the probabilities of winning conference	def updateConferenceProbs(self, division='D3', gender='Women', season=2017, weeksIn=None):		simDate = week2date(weeksIn, season)		if weeksIn == -1:  # pre-season			nextYear = True		else:			nextYear = False		print simDate		for conference in self.conferences[division][gender]:			if conference == '':				continue			self.conference(conf=conference, gender=gender, season=season, division=division, update=True,								dateStr=simDate, nextYear=nextYear)	def updateTeamStrength(self, division='D3', gender='Women', season=2017, weeksIn=None, update=True):		if not weeksIn:			weeksIn = 25		for team in TeamSeason.select().where(TeamSeason.division==division, TeamSeason.gender==gender,					TeamSeason.season==season):			team.getWeekStrength(update=True, weeksIn=weeksIn)	def updateTeamStats(self, division='D3', gender='Women', week=25, season=2018):		simDate = week2date(week)		if simDate > Date.today():			return  # would be a future week		# national meets probabilities		database.conference(conf='Nationals', gender=gender, division=division, season=season, update=True,							dateStr=simDate)		database.updateConferenceProbs(division=division, gender=gender, season=season, weeksIn=week)		database.updateTeamStrength(division=division, gender=gender, season=season, weeksIn=week, update=True)	def conferencePlace(self, division, gender, newSwims, year=2014):		newEvents = set()		for swim in newSwims:			newEvents.add(swim[0])		confMeets = {}		with open('./data/' + division + gender + '.csv') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet					confMeets[confName].addSwims(Meet(name=meetName, events=newEvents, gender=gender,													  topSwim=True).getSwims())				else:					confMeets[confName] = Meet(name=meetName, events=newEvents, gender=gender, topSwim=True,											   season=year)		confScores = {}		for conference in confMeets:			confMeet = confMeets[conference]			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScores	def taperMeets(self, year=2015, gender='Women', division='D1'):  # find meets where most best times come from		teamMeets = {}		#teams=['Univ of Utah', 'Stanford', 'California', 'Arizona', 'Southern Cali', 'Arizona St']		teams = self.allTeams[gender][division]		for team in teams:			for swim in Swim.raw("SELECT * FROM top_swim WHERE team=%s AND season=%s AND date > '%s-02-01' AND "								 "gender=%s) ", team, year, year, gender):				if not team in teamMeets:					teamMeets[team] = []				teamMeets[team].append(swim.meet)		taperMeets = {}		for team in teamMeets:			taperMeet = max(set(teamMeets[team]), key=teamMeets[team].count)			if taperMeet not in taperMeets:				taperMeets[taperMeet] = 0			taperMeets[taperMeet] += 1		bigTaperMeets = [i for i in taperMeets if taperMeets[i]>2]		return bigTaperMeets	# returns improvemnt data from db, from season1 to season2	def getImprovement(self, gender='Men', teams=['Carleton'], season1=thisSeason()-1, season2=thisSeason()-2):		posSeasons = [2017, 2016, 2015, 2014, 2013, 2012, 2011]		#print season1, season2		if season1 > season2 and season1 in posSeasons and season2 in posSeasons:			seasons = range(season2, season1)			#print seasons		teamImprovement = {}		for swim in Improvement.select().where(Improvement.fromseason << seasons, Improvement.gender==gender,									   Improvement.team << list(teams)):			if swim.team not in teamImprovement:				teamImprovement[swim.team] = []			teamImprovement[swim.team].append(swim.improvement)		if len(teams)==1 and teams[0] in teamImprovement:			return teamImprovement[teams[0]]		return teamImprovement	def storeImprovement(self, season=2018):		swims = []		for team in TeamSeason.select().where(TeamSeason.season==season):			preTeam = team.getPrevious()			if not preTeam:				continue			top1 = team.getTaperSwims(structured=True)			top2 = preTeam.getTaperSwims(structured=True)			for swimmer in top1:				if not swimmer in top2:					continue				for event in top1[swimmer]:					if not event in top2[swimmer]:						continue					swim1 = top1[swimmer][event]					swim2 = top2[swimmer][event]					time1 = swim1.time					time2 = swim2.time					drop = (time2-time1) / ((time1+time2) / 2) * 100					#print swimmer, event, time1, time2					if abs(drop) > 10:  # toss outliers						continue					newSwim = {'fromseason': season-1, 'toseason': season, 'name': swim1.name,							   'fromyear': swim2.year, 'toyear': swim1.year,							   'team': team.team, 'gender': team.gender, 'event': event,							   'improvement': drop,  # positive=faster							   'fromtime': swim2.time, 'totime': swim1.time,							   'conference': team.conference, 'division': team.division}					#print newSwim					swims.append(newSwim)		print len(swims)		db_proxy.connect()		for i in range(len(swims) / 100):			print i			with db_proxy.transaction():				Improvement.insert_many(swims[i*100:(i+1)*100]).execute()	def update_season_stats(self, season=2018, recalc=True):		if recalc:			print 'storing improvement'			self.storeImprovement(season)		for team in TeamSeason.select().where(TeamSeason.season==season):			print team.team			team.updateSeasonStats()	def taper_stats(self):		import pandas as pd		dates, drops, teams, names = [], [], [], []		for team in ['Stanford']: #, 'Texas', 'California', 'Michigan', 'Georgia', 'Florida', 'Auburn', 'Wisconsin',			#'Minnesota', 'Arizona', 'Northwestern']:			gender = 'Men'			for season in [2012]: #, 2013, 2014, 2015, 2016]:				texas = TeamSeason.get(season=season, gender=gender, team=team)				for taper_swim in texas.getTaperSwims():					for swim in Swim.select(Swim.time, Swim.name, Swim.date).where(Swim.swimmer==taper_swim.swimmer,													Swim.event==taper_swim.event, Swim.gender==gender):						ratio = swim.time/taper_swim.time						if ratio < 1.2:							drops.append(ratio)							dates.append(pd.Timestamp(swim.date))							teams.append(team)							names.append(swim.name)		#ts = pd.DataFrame({'y': drops, 'ds': dates})		print drops, dates, teams, names	# predict winning NCAA times for each year	def recordPrediction(self, event, division='D1', gender='Men', season=None):		from scipy.stats import skewnorm		season_adjust = False		record_season = season		p_season = season		if season > 2018:			season = 2018			season_adjust = True			record_season = None  # use all time records for future		record = self.get_record(event, division, gender, season=record_season)		# find top time dist		times = []		for swim in Swim.raw("(SELECT * FROM top_swim WHERE gender=%s and division=%s and event=%s and ts.season=%s))"								, gender, division, event, season):			times.append(swim.time)		#print event, division, gender, season, len(times)		if len(times) == 0:			return		times = rejectOutliers(times, l=4, r=4)		# best fit of data		(mu, sigma) = norm.fit(times)		(a, mu, sigma) = skewnorm.fit(times, max(times)-mu, loc=mu, scale=sigma)		plot = True		if plot:  # the histogram of the data			import matplotlib.pyplot as plt			n, bins, patches = plt.hist(times, 60, normed=1)			y = skewnorm.pdf(bins, a, mu, sigma)			plt.plot(bins, y)			plt.ylabel('% of times')			plt.xlabel('Time in seconds')			plt.savefig("100_free_men_dist.svg", format="svg")			plt.show()		# season adjustment if after current season		if season_adjust:			mu += self.season_imp(event, division, gender, p_season=p_season)		dist = skewnorm(a, mu, sigma)		sample = 1000		top_times = []		top = 0		for i in range(sample):			topTime = min(dist.rvs(size=int(len(times))))			top_times.append(topTime)			if topTime < record:				top += 1		mu = np.median(top_times)		if plot:  # the histogram of the data			import matplotlib.pyplot as plt			n, bins, patches = plt.hist(top_times, 60, normed=1)			plt.ylabel('% of times')			plt.xlabel('Time in seconds')			plt.savefig("100_free_men_winning_dist.svg", format="svg")			plt.show()		return swimTime(record), swimTime(mu), top / float(sample)	def get_record(self, event, division='D1', gender='Men', season=2018):		if season:			for swim in Swim.select(fn.min(Swim.time)).where(Swim.division==division, Swim.gender==gender,													 Swim.event==event, Swim.season==season):				return swim.min		else:			for swim in Swim.select(fn.min(Swim.time)).where(Swim.division==division, Swim.gender==gender,													 Swim.event==event):				return swim.min	def season_imp(self, event, division='D1', gender='Men', p_season=2019):		seasons, avg_times = [], []		time_2018 = None		for swim in Swim.raw("SELECT event, season, avg(time) from "			"(SELECT event, season, time FROM top_swim WHERE gender=%s and division=%s and event=%s and season>2009)) "			"GROUP BY season, event ", gender, division, event):			seasons.append(swim.season)			avg_times.append(swim.avg)			if swim.season == 2018:				time_2018 = swim.avg		slope, intercept, r_value, p_value, std_err = linregress(seasons, avg_times)		return intercept + slope * p_season - time_2018if __name__ == "__main__":	# database setup	urlparse.uses_netloc.append("postgres")	if "DATABASE_URL" in os.environ:  # production		url = urlparse.urlparse(os.environ["DATABASE_URL"])		db = PostgresqlDatabase(database=url.path[1:],								user=url.username,								password=url.password,								host=url.hostname,								port=url.port)	else:		db = PostgresqlDatabase('swimdb', user='hallmank')	database = SwimDatabase(db)	'''	cum_probs = {}	est_times = {}	for year in [2019, 2020, 2021, 2022, 2023, 2024, 2025]:		cum_probs[str(year)] = {}		est_times[str(year)] = {}		for event in allEvents:			if '1000' in event or 'Relay' in event: continue			record, est_time, prob = database.recordPrediction(event, season=year, gender='Women')			#print record, est_time, prob			est_times[str(year)][event] = est_time			if str(year - 1) not in cum_probs:				cum_probs[str(year)][event] = 1 - prob			else:				cum_probs[str(year)][event] = (1 - prob) * cum_probs[str(year - 1)][event]	for year in cum_probs:		for event in cum_probs[year]:			print year, event, cum_probs[year][event]	for year in est_times:		for event in est_times[year]:			print year, event, est_times[year][event]	'''	#print database.top_times_view(2018, 'Women', 'Nationals', 'D1')	#print database.recordPrediction(event='100 Free', season=2018)	#for season in range(2013, 2019):	#	database.update_season_stats(season=season)	#database.timePlacePPts()	#database.taperCluster()	#print database.storeImprovement()	#print database.testMeetPrediction()	#print database.nats_tapers()	'''	for division in ['D1', 'D2', 'D3']:		for gender in ['Men', 'Women']:			print division, gender			database.updateTeamStats(division=division, gender=gender, week=20)	'''