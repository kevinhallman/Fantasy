import reimport numpy as npimport operatorfrom operator import itemgetterfrom datetime import date, timedeltafrom peewee import *import os, urlparseimport heapqimport time as Timefrom swimdb import Improvement, Team, TeamStats, TeamSeason, Swimmer, Swimfrom swimdb import Meet as SMeetpointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]eventsDualS = ["200 Yard Medley Relay","1000 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsDualL = ["400 Yard Medley Relay","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","400 Yard Individual Medley","400 Yard Freestyle Relay"]eventsChamp = ["400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsChamp3 = ['1 mtr Diving','200 Yard Freestyle Relay','','500 Yard Freestyle','200 Yard Individual Medley', '50 Yard Freestyle','','400 Yard Medley Relay','','400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','800 Yard Freestyle Relay','','1650 Yard Freestyle','','200 Yard Medley Relay','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','','400 Yard Freestyle Relay','3 mtr Diving']#eventsChamp3 = ['500 Yard Freestyle','200 Yard Individual Medley', '50 Yard Freestyle','','400 Yard Individual# Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','1650 Yard Freestyle','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly']eventsDay1 = ['1 mtr Diving','200 Yard Freestyle Relay','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','400 Yard Medley Relay']eventsDay2 = ['400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','800 Yard Freestyle Relay']eventsDay3 = ['1650 Yard Freestyle','200 Yard Medley Relay','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','400 Yard Freestyle Relay','3 mtr Diving']allEvents={"400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay",'1000 Yard Freestyle','100 Yard Breastroke','200 Yard Breastroke'}eventsChampInd={"400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley",'100 Yard Breastroke','200 Yard Breastroke'}MIAC = ["Carleton","Augsburg","St. Olaf","Saint Mary's MN","Macalester","Gustavus","Saint Benedict","St. Kate's","Concordia","St. John's","St. Thomas","Hamline"]requiredEvents={"200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly"}eventOrder = ["50 Yard Freestyle","100 Yard Freestyle","200 Yard Freestyle","500 Yard Freestyle","1000 Yard Freestyle","1650 Yard Freestyle","100 Yard Butterfly","200 Yard Butterfly","100 Yard Backstroke","200 Yard Backstroke","100 Yard Breastroke","200 Yard Breastroke","200 Yard Individual Medley","400 Yard Individual Medley","200 Yard Medley Relay","400 Yard Medley Relay","200 Yard Freestyle Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay"]#setup database connectiondb_proxy = Proxy()db = Proxy()swimDatabase = None#make time look nicedef swimTime(time):	(seconds, point) = re.split("\.", str(time))	if int(seconds) < 60:		time = round(time, 2)		time = str(time)		while len(time) < 5:			time += '0'		return time	minutes = str(int(seconds) / 60)	seconds = str(int(seconds) % 60)	while len(seconds) < 2:		seconds = '0' + seconds	while len(point) < 2:		point = point + '0'	return  minutes + ":" + seconds + "." + point[:2]#convers to a time in secondsdef toTime(time):	try:		if time[0]=="X" or time[0]=="x":			time=time[1:]		if re.match(".*:.*",time) == None:			return float(time)		return float(re.split(":",time)[0])*60 +float(re.split(":",time)[1])	except TypeError:		return 0'''sees if one list contains another'''def contains(small, big):	for i in small:		if not i in big:			return False	return True'''events contained within a relay'''def relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']def thisSeason():	today = date.today()	if today.month > 6:		return today.year + 1	return today.yeardef rejectOutliers(dataX, dataY=None, l=5, r=6):	u = np.mean(dataX)	s = np.std(dataX)	if dataY:		data = zip(dataX, dataY)		newList = [i for i in data if (u - l*s < i[0] < u + r*s)]		newX, newY = zip(*newList)		return list(newX), list(newY)	else:		newList = [i for i in dataX if (u - l*s < i < u + r*s)]	#print swimTime(max(newList)), swimTime(min(newList))	#print "Num rejected: " + str(len(dataX)-len(newList))	return newListdef ECDF(data):	def cdf(num):		d = data		l = float(len(d))		return (sum(1 for i in d if i < num) + sum(.5 for i in d if i==num))/l	return cdfdef getConfs():	confs = {'D1': {'Men': {}, 'Women': {}}, 'D2': {'Men': {}, 'Women': {}}, 'D3': {'Men': {}, 'Women': {}}}	allTeams = {'Men': {'D1': [], 'D2': [], 'D3': []}, 'Women': {'D1': [], 'D2': [], 'D3': []}}	for newTeam in TeamSeason.select(TeamSeason.team, TeamSeason.conference, TeamSeason.division,									 TeamSeason.gender).distinct(TeamSeason.team):		if newTeam.conference not in confs[newTeam.division][newTeam.gender]:			confs[newTeam.division][newTeam.gender][newTeam.conference] = set()		confs[newTeam.division][newTeam.gender][newTeam.conference].add(newTeam.team)		allTeams[newTeam.gender][newTeam.division].append(newTeam.team)		for division in ['D1', 'D2', 'D3']:			allTeams['Men'][division].sort()			allTeams['Women'][division].sort()	return confs, allTeamsdef nextYear(year):	if year=='Freshman':		return 'Sophomore'	if year=='Sophomore':		return 'Junior'	if year=='Junior':		return 'Senior'	return Nonedef grad(f, x, y, h=0.0025):	dx = (f(x, y) - f(x+h, y))/h	dy = (f(x, y) - f(x, y+h))/h	return dx, dydef gradientDescent(f, x0, y0, step=.001):	for i in range(10):		dx, dy = grad(f, x0, y0)		length = ((dx**2 + dy**2) ** .5)		print 'delta:', dx, dy		x0 += step * dx / length		y0 += step * dy / length		if x0 < 0:			x0 = 0.001		if y0 < 0:			y0 = 0.001		#print x0, y0	return x0, y0def fun(x, y):	return (x-3)**2 + (y-2)**2 + 1def frange(x, y, jump):	while x < y:		yield x		x += jumpdef date2week(d):	if d > date.today():		d = date.today()	if d.month > 6:		season = d.year + 1	else:		season = d.year	startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017	weeksIn = int((date - startDate).days / 7)	return weeksIndef week2date(week, season=None):	if not season:		season = thisSeason()	startDate = date(season - 1, 10, 16)  # use Oct 15 as the start date, prolly good for 2017	if week == None:		return date.today()	simDate = startDate + timedelta(weeks=week)	if simDate > date.today():  # can't simulate with future data		simDate = date.today()	return simDate'''this class contains a swim meetscores itself'''class Meet:	def __init__(self, name=None, events=list(allEvents), gender=None, topSwim=True, teams=None, season=None):		self.gender = gender  # None means both		self.teams = []  # teams added as swims are		self.scores = None		self.eventSwims = {}		if type(allEvents) != list:			events = list(events)		self.events = events		self.name = name  # named meets are ones that actually happened		self.date = None		self.season = None		self.winMatrix = None		if isinstance(teams, basestring):			teams = [teams]		if not gender:			genders = ['Men', 'Women']		else:			genders = [gender]		if self.name:			query = Swim.select().where(Swim.meet==name, Swim.gender << genders, Swim.event << events)			if teams:				query = query.select().where(Swim.team << teams)			if season:				query = query.select().where(Swim.season==season)			if topSwim:				query = query.select(Swim.name, Swim.event, Swim.team, Swim.gender, fn.Min(Swim.time),					Swim.year).group_by(Swim.name, Swim.event, Swim.team, Swim.gender, Swim.year)			for swim in query:				if topSwim:					swim.time = swim.min					swim.meet = name				self.addSwim(swim)	def reset(self, teams=False, times=False):		for swim in self.getSwims():			if teams:				swim.scoreTeam = None			if times:				swim.scoreTime = None	# sees if any swims are in the meet	def isEmpty(self):		for event in self.eventSwims:			if not self.eventSwims[event]==[]:				return False		return True	def isDual(self):		return len(self.teams) == 2	def getSwims(self, team='all', relays=True, splits=False, ind=True):		swims=set()		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if ind and (swim.team == str(team) or team=='all') and (relays or not swim.relay):					swims.add(swim)				if splits and swim.relay and (team=='all' or swim.team == str(team)):					for split in swim.swims:						swims.add(split)		return swims	def addSwim(self, swim):		if not swim.getScoreTeam() in self.teams:			self.teams.append(swim.getScoreTeam())		if self.name and not self.date or not self.season:  # without a name, its a dummy meet			self.date=swim.date			self.season=swim.season		if not swim.event in self.eventSwims:			self.eventSwims[swim.event] = []		self.eventSwims[swim.event].append(swim)	def addSwims(self, swims):		for swim in swims:			self.addSwim(swim)	def removeSwimmer(self, name):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.name==name:					self.eventSwims[event].remove(swim)	def nextYear(self, database):		for event in self.eventSwims:			if 'Relay' in event:				continue			self.eventSwims[event] = [x.improve(database) for x in self.eventSwims[event] if x.year != 'Senior']	def getEvents(self, events=''):		myEvents = set(self.eventSwims.keys())		if events=='':			if self.events == None:				events = allEvents			else:				events = self.events		events = set(events) & set(myEvents)		return events	def eventVariance(self):		timeVar={}		self.place()		for event in self.eventSwims:			average=0			count=0			for i in range(len(self.eventSwims[event])-1):				timeDif=abs(self.eventSwims[event][i].time-self.eventSwims[event][i+1].time) #time dif between this and next place				average=(average*count+timeDif)/(count+1) #running average				count+=1			timeVar[event]=average		return timeVar	'''	decides top events for each swimmer	top swimmers are decided by highest scoring event right now	'''	def topEvents(self, teamMax=17, indMax=3, totalMax=4, adjEvents=False, debug=False):		self.place()		conference = Meet()		indSwims = {}		relaySwims = {}		teamSwimmers = {}		teamDivers = {}		drops = []		relayEvents = set()		events = self.eventSwims.keys()		for team in self.teams:			teamSwimmers[team] = 0			teamDivers[team] = 0		for event in self.eventSwims:  # we will keep relays as is, but count them towards total swims			if re.search('Relay', event):				relayEvents.add(event)				while not self.eventSwims[event] == []:  # move relays over to new meet					relay = self.eventSwims[event].pop()					conference.addSwim(relay)		for event in relayEvents:			events.remove(event)		#pare down		self.place()		for event in self.eventSwims:			if len(self.eventSwims[event]) > 100:				self.eventSwims[event] = self.eventSwims[event][:99]  # start with top 100 times		#now make sure that each person swims their top events		preEvent = None		nextEvent = None		if debug: print self		while not self.isEmpty():			for event in events:				#print event				drop = True  # just allow us to enter the loop				while drop and not self.eventSwims[event] == []:  # we need to loop on an event until we find				#someone who is actually in it					drop = False					#print self.eventSwims[event]					if self.events and type(self.events) == type([]) and event in self.events:						if not self.events.index(event) == 0:							preEvent = self.events[self.events.index(event)-1]						if not self.events.index(event)==len(self.events)-1:							nextEvent = self.events[self.events.index(event)+1]					newSwim = self.eventSwims[event].pop(0)					if preEvent in conference.eventSwims and not adjEvents:  # check to make sure no adjacent events						for swim in conference.eventSwims[preEvent]:							if newSwim.name == swim.name and newSwim.getScoreTeam() == swim.getScoreTeam():								drops.append(newSwim)								drop = True								if debug: print 'pre', swim.name, swim.event								if debug: print 'pre', newSwim.name, newSwim.event								break					if nextEvent in conference.eventSwims and not adjEvents:						for swim in conference.eventSwims[nextEvent]:							if newSwim.name == swim.name and newSwim.getScoreTeam() == swim.getScoreTeam():								drop = True								drops.append(newSwim)								if debug: print 'post', swim.name, swim.event								if debug: print 'post', newSwim.name, newSwim.event								break					if drop:  # already swimming previous or next event						continue					if not newSwim.name+newSwim.getScoreTeam() in indSwims:   # team max events						if teamSwimmers[newSwim.getScoreTeam()] < teamMax:							indSwims[newSwim.name + newSwim.getScoreTeam()] = 0  # count same person on two teams							# differently							teamSwimmers[newSwim.getScoreTeam()] += 1						else:							if debug: print 'team', swim.name, swim.event							if debug: print 'team', newSwim.name, newSwim.event							drops.append(newSwim)							continue # fixed to still add swim when all 18					if indSwims[newSwim.name + newSwim.getScoreTeam()] < indMax:  # individual max events						conference.addSwim(newSwim)						indSwims[newSwim.name + newSwim.getScoreTeam()] += 1					else:						if debug: print 'ind', swim.name, swim.event						if debug: print 'ind', newSwim.name, newSwim.event						drops.append(newSwim)						drop = True  # can't swim any more events		self.score()		if debug:			print teamSwimmers, indSwims, teamMax, indMax			for swim in drops:				print swim.name, swim.event, swim.getScoreTeam(), swim.time		self.eventSwims = conference.eventSwims		return drops	'''	adds top relays using same method in database	'''	def addTopRelays(self, number, team, database):		relays = [event for event in self.events if re.search('Relay',event)]		return database.topRelays(relays, team, self)	'''	creates the best lineup for the given team against another set lineup	no two person swapping instabilities	->must implement relay creation and switching	'''	def lineup(self, team, debug=False, splits=False, ppts=False):		team=str(team)		drops = self.topEvents(30, 3, 4)		self.place()		'''		now we have a starting point		'''		extras = {}  # double dictionary,swim:event		for swim in drops:  # + dropSplits			if not swim.name in extras:				extras[swim.name] = {}			extras[swim.name][swim.event]=swim		if debug: self.printout()		toCheck = self.getSwims(team, False, splits=splits)		while len(toCheck) > 0:  # double loop on all swims, trying to see if more points are scored if swapped			swim1=toCheck.pop()			swims=self.getSwims(team, False, splits=splits)			while len(swims) > 0:				swim2=swims.pop()				if swim1==swim2 or swim1.event==swim2.event:					continue				# make sure swims exist				if extras.has_key(swim2.name) and extras.has_key(swim1.name) and extras[swim1.name].has_key(swim2.event) and extras[swim2.name].has_key(swim1.event):					self.score()					if debug:						print self.score()						print team					if not ppts:  # normal scoring						oldScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]						(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)						self.score()						newScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]					else:  # optimize powerpoints						oldScore = self.expectedScores()						(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)						self.score()						newScore = self.expectedScores()					if oldScore < newScore:  # swap in new swims						if debug:							print "swap"							print newSwim1.name, newSwim1.event							print newSwim2.name, newSwim2.event						swims.add(newSwim1)						swims.add(newSwim2)						if swim1 in swims:							swims.remove(swim1)						if swim2 in swims:							swims.remove(swim2)						for swim in (newSwim1, newSwim2):							if swim.split:  # re-add swims in those events								for relay in self.eventSwims[newSwim1.fromRelay]:									if relay.team==team:										for split in relay.swims:											if not split in toCheck:												toCheck.add(split)							else:								for swim in self.eventSwims[newSwim1.event]:									if not swim in toCheck and swim.team==team:										toCheck.add(swim)						if swim2 in toCheck:  # make sure second swim is not checked again							toCheck.remove(swim2)						swim1 = toCheck.pop()  # start checking next swim					else:  # revert to old lineup						self.swap(newSwim1, newSwim2, extras)		self.score()	'''	given two old swims	will swap two swims, returns two new swims	'''	def swap(self, swim1, swim2, extras):		newSwim1=extras[swim1.name][swim2.event]		newSwim2=extras[swim2.name][swim1.event]		if self.eventSwims.has_key(swim2.event) and swim2 in self.eventSwims[swim2.event]: # ind swim			self.eventSwims[swim2.event].remove(swim2)			self.addSwim(newSwim1)		else: #gotta be a relay			self.relaySwap(swim2,newSwim1)		if self.eventSwims.has_key(swim1.event) and swim1 in self.eventSwims[swim1.event]: # ind swim			self.eventSwims[swim1.event].remove(swim1)			self.addSwim(newSwim2)		else: #gotta be a relay			self.relaySwap(swim1,newSwim2)		if not extras.has_key(swim1.name):			extras[swim1.name]={}		extras[swim1.name][swim1.event]=swim1		if not extras.has_key(swim2.name):			extras[swim2.name]={}		extras[swim2.name][swim2.event]=swim2		return (newSwim1,newSwim2)	'''	swaps someone into a relay	given old (swim1) and new (swim2) split	'''	def relaySwap(self, swim1, swim2):		for relay in self.eventSwims[swim1.fromRelay]:			if swim1 in relay.swims:				relay.changeSwimmer(swim1,swim2)				return	def taper(self, weeks=12):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				swim.taper(weeks=weeks)	def expectedScores(self, division='D3', swimmers=6, debug=False, nsigma=-1):		self.place()		scores = {}		teamSwims = {}		for event in self.eventSwims:			teamSwims[event] = {}			for swim in self.eventSwims[event]:				if not swim.team in scores:					scores[swim.team] = 0				if not swim.team in teamSwims[event]:					teamSwims[event][swim.team] = 0				else:					teamSwims[event][swim.team] += 1				losses = teamSwims[event][swim.team]				swim.division = division				points = swim.expectedPoints(numSwimmers=swimmers, losses=losses)				swim.score = points				if points:					scores[swim.team] += points				if debug: print swim.event, swim.time, points, int(round(scores[swim.team])), losses		for team in scores:			scores[team] = int(round(scores[team]))		return scores	def place(self, events='', storePlace=False):		events=self.getEvents(events)		for event in events:			if not event in self.eventSwims or len(self.eventSwims[event]) == 0:				continue			self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=False)			if storePlace:				for idx, swim in enumerate(self.eventSwims[event]):					swim.place = idx+1	def score(self, dual=None, events='', heatSize=8, heats=2):		events = self.getEvents(events)		self.place(events)		self.assignPoints(heats=heats, heatSize=heatSize, dual=dual, events=events)		return self.teamScores(events)	'''	assigns points to the swims	'''	def assignPoints(self, heats=2, heatSize=8, dual=None, events=allEvents):		if dual is None:			if len(self.teams)==2:				dual=True			else:				dual=False		max = 16		if heats == 3:			pointsI = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif heats == 2:			pointsI = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		if heatSize == 6:			pointsI = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		pointsR = [x*2 for x in pointsI]		if dual:			max = 3			pointsI = [9, 4, 3, 2, 1]			pointsR = [11, 4, 2]		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0			else:				place = 1				teamSwims = {}				for swim in self.eventSwims[event]:					swim.score = None  # reset score					if not 'Relay' in swim.event:  # should use real relay var						team = swim.getScoreTeam()						if place > len(pointsI) or (team in teamSwims) and teamSwims[team] >= max:							swim.score = 0						else:							swim.score = pointsI[place-1]							if not team in teamSwims:								teamSwims[team] = 0							teamSwims[team] += 1							place += 1					else:						team = swim.getScoreTeam()						if place > len(pointsR) or (team in teamSwims) and teamSwims[team] >= max:							swim.score = 0						else:							swim.score = pointsR[place-1]							if not team in teamSwims:								teamSwims[team] = 0							teamSwims[team] += 1							place += 1	def scoreMonteCarlo(self, dual=None, events='', heatSize=8, heats=2, sigma=.02, runs=500, teamSigma=.02,						weeksOut=4):		# default the sigma if we just know the date		if weeksOut == -1:			sigma = 0.045			teamSigma = .02		elif weeksOut <= 4:			teamSigma = .01			sigma = 0.025		elif weeksOut <= 8:			teamSigma = .015			sigma = 0.035		elif weeksOut <= 12:			teamSigma = 0.015			sigma = 0.0425		elif weeksOut <= 16:			teamSigma = 0.025			sigma = 0.045		elif weeksOut > 16:			teamSigma = .0325			sigma = 0.0375		events = self.getEvents(events)		#print teamSigma, sigma, weeksOut		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0		teamScoresDist = []		for iternation in range(runs):  # run runs # of times			teamTapers = {}  # team noise			for team in self.teams:				teamTapers[team] = np.random.normal(0, teamSigma)			for event in self.eventSwims:  # individual swim noise				for swim in self.eventSwims[event]:					if swim.time:						noise = np.random.normal(0, sigma) * swim.getTaperTime()						teamNoise = teamTapers[swim.team] * swim.getTaperTime()						swim.scoreTime = swim.getTaperTime() + noise + teamNoise			#place again			self.place(events)			#now score			self.assignPoints(dual=dual, heats=heats, heatSize=heatSize, events=events)			teamScoresDist.append(self.teamScores(events))		self.reset(times=True)  # reset the times to normal		places = {}  # stores the number of times each team was 1st, 2nd, ect.		for score in teamScoresDist:			for idx, (team, score) in enumerate(score):				if not team in places:					places[team] = []				places[team].append(idx)		#print places		probMatrix = {}		for team in places:			probMatrix[team] = [0 for _ in range(len(places))]			for place in places[team]:				probMatrix[team][place] += 1.0/len(places[team])  # add in each individual result		winMatrix = {}		for team in probMatrix:			winMatrix[team] = probMatrix[team][0]		self.winMatrix = winMatrix		return probMatrix	def getTeamWinProb(self, team):		if not self.winMatrix:			self.scoreMonteCarlo(dual=False)		if not team in self.winMatrix:			return None		return self.winMatrix[team]	def getWinProb(self):		if not self.winMatrix:			self.scoreMonteCarlo(dual=False)		return self.winMatrix	def teamScores(self, events='', sorted=True):		events = self.getEvents(events)		teams = {}		for team in self.teams:  # make sure all the teams get some score			teams[team] = 0		for event in events:			if not event in self.eventSwims: continue			for swim in self.eventSwims[event]:				team = swim.getScoreTeam()				if not team in teams:					teams[team] = 0				teams[team] += swim.getScore()		self.scores = teams		if not sorted:			return teams		#now sort		scores = []		for team in teams:			scores.append([team, teams[team]])		scores.sort(key=lambda team: team[1], reverse=True)		return scores	def getTeamScore(self, team):		if not self.scores:			self.teamScores()		if not team in self.scores:			return None		return self.scores[team]	def getScores(self):		if not self.scores:			return self.teamScores()		return self.scores	def winningTeam(self):		if not self.scores: self.teamScores()		if len(self.scores)<1 or len(self.scores[0])<1: return None		return self.scores[0][0]	'''	lists swimmers by team and by points scored	'''	def scoreReport(self, repressSwim=False, repressTeam=False):		scores={}		for team in self.teams:			scores[team]={'total': 0, 'year': {}, 'swimmer': {}, 'event': {}}		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.relay:					name = 'Relays'				else:					name = swim.name				if repressSwim and swim.score == 0:					continue   # repess zero scores				team = swim.getScoreTeam()				if not name in scores[team]['swimmer']:					scores[team]['swimmer'][name] = 0				if not event in scores[team]['event']:					scores[team]['event'][event]=0				scores[team]['swimmer'][name] += swim.score				scores[team]['total'] += swim.score				scores[team]['event'][event] += swim.score				if swim.year:					if not swim.year in scores[team]['year']:						scores[team]['year'][swim.year] = 0					scores[team]['year'][swim.year] += swim.score		if repressTeam:			zeroTeams=set()			for team in scores:				if scores[team]['total'] == 0:					zeroTeams.add(team)			for team in zeroTeams:				del(scores[team])		return scores	def printout(self, events=''):		events=self.getEvents(events)		for event in events:			if event not in self.eventSwims: continue			print "-------------------------------------------------------------------------------------"			print "Event: " + event			for swim in self.eventSwims[event]:				if swim.score:					print swim.printScore().lstrip()+"\t"+str(swim.score)				else:					print swim.printScore().lstrip()		print self.scores	def scoreString(self, showNum='all', showScores=True, showPlace=False):		self.score()		string = {}		events = self.getEvents('')		for event in events:			if event not in self.eventSwims: continue			string[event] = []			# determine last scoring place			if showNum != 'all':				lastScoring = showNum				place = 0				for swim in self.eventSwims[event]:					place += 1					if swim.getScore() != 0 and place > lastScoring:						lastScoring = place			place = 0			for swim in self.eventSwims[event]:				place += 1				if showNum != 'all':					if place > lastScoring:						break				swimAry = re.split('\t', swim.printScore(gender=False).strip())				if showPlace:					swimAry.insert(0, place)				if swim.score and showScores:					swimAry.append(str(swim.score))					string[event].append(swimAry)				else:					string[event].append(swimAry)		string["scores"] = self.teamScores()		return string	def __str__(self):		if self.name:			return self.name		self.printout()		return ''	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name and self.date==s.date	def __hash__(self):		return hash(self.name)^hash(self.date)'''conference level information'''class conference:	def __init__(self, name, gender, season, division):		self.conference = name		self.gender = gender		self.season = season		self.teams = set()		self.division = division		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.season==season,									TeamSeason.conference==name):			self.teams.add(team)	def meet(self, topTimes=True, date=None, update=False, taper=False, weeksIn=10, nextYear=False):		events = eventsChamp3		swimmerLimit = 17		weeksOut = 16 - weeksIn		base = SwimDatabase('')		conference = base.topTimes(events=events, teams=list(self.teams), season=self.season, gender=self.gender,								   topTimes=topTimes, divisions=self.division, date=date)		season = self.season		if nextYear:			conference.nextYear(self)			season += 1  # update the correct season			weeksOut = '-1'			weeksIn = '-1'		if taper: conference.taper()		conference.topEvents(swimmerLimit)		conference.score()		# update stored win probabilities		if update:			conference.scoreMonteCarlo(weeksOut=weeksOut)			teamProb = conference.getWinProb()			for team in teamProb:				teamSeason = TeamSeason.get(team=team, division=self.division, gender=self.gender, season=season)				try:					stats = TeamStats.get(teamseasonid=teamSeason.id, week=weeksIn)					stats.winconf = teamProb[team]					print team, season, stats.winconf, weeksIn, date, teamSeason.id, stats.id					print stats.save()				except TeamStats.DoesNotExist:					print 'AB:', team, season, teamProb[team], weeksIn, date					print TeamStats.create(teamseasonid=teamSeason.id, week=weeksIn, winconf=teamProb[team], date=date)	def getStats(self):		teamStats = {}		for team in self.teams:			teamStats[team.name] = {}			teamStats[team.name]['winNats'] = team.getWinnats()			teamStats[team.name]['winConf'] = team.getWinconf()			# team development			# print team, session.gender, session.division			try:				stats = Team.get(Team.name==team.name, Team.gender==self.gender, Team.division==self.division)				teamStats[team.name]['strinv'] = stats.strengthinvite				teamStats[team.name]['attrition'] = stats.attrition				teamStats[team.name]['imp'] = stats.improvement			except Team.DoesNotExist:				teamStats[team.name]['strinv'] = None				teamStats[team.name]['attrition'] = None				teamStats[team.name]['imp'] = None			(medtaper, stdtaper) = team.getTaperStats()			teamStats[team.name]['medtaper'] = medtaper			teamStats[team.name]['stdtaper'] = stdtaper	def getTopSwimmers(self, num=10):		swimmers = []		for team in self.teams:			for swimmer in Swimmer.select().where(Swimmer.teamid==team.id):				if 'Relay' in swimmer.name: continue				heapq.heappush(swimmers, (swimmer.getPPTs(), swimmer))		return heapq.nlargest(num, swimmers)'''full database methods'''class SwimDatabase:	def __init__(self, database):		global swimDatabase		swimDatabase = self		db_proxy.initialize(database)		self.database = database		self.dist = {}		self.results = {}  # cache dual results		self.teams = {}		self.meetCache = {}		self.eventImpCache = {}		self.topScoreCache = {}		self.conferences, self.allTeams = getConfs()	def topDual(self, season=thisSeason(), events=requiredEvents, debug=False, teams='all', gender='Men'):		if teams == 'all':			teams = self.teams		meets = {}		wins = {}		losses = {}		for team in teams:			if not team in self.teams:				self.teams[team] = Team(team, self)			if not self.teams[team].topDual(season, debug=debug, gender=gender):				continue			meets[team] = self.teams[team].topDual(season, debug=debug, gender=gender)  # its cached			wins[team] = 0			losses[team] = 0			#if debug: print team, '\t\t', meets[team]		if debug: print '-----------'		for team1 in meets:			for team2 in meets:				if team1 == team2:					continue				if not team1 in self.results:					self.results[team1] = {}				if not team2 in self.results:					self.results[team2] = {}				if team2 in self.results[team1] or team1 in self.results[team2]:  # reverse meet already swum					continue				newMeet = self.swimMeet([[team1, meets[team1]], [team2, meets[team2]]], includeEvents=events,									  selectEvents=False)  # should convert to dual form				self.results[team1][team2] = newMeet.winningTeam()				self.results[team2][team1] = newMeet.winningTeam()				if debug: print team1, team2, newMeet.winningTeam()				if self.results[team1][team2] == team1: # team1 wins					wins[team1] += 1					losses[team2] += 1				elif self.results[team1][team2] == team2:  # team2 wins, otherwise no points					wins[team2] += 1					losses[team1] += 1		if debug:			for (index, team) in enumerate(sorted(wins.items(), key=operator.itemgetter(1), reverse=True)):				print str(index)+'.',team[0]+':',team[1],'-',losses[team[0]]		return meets, wins, losses	'''	creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	'''	def swimMeet(self, teamMeets, gender=None, debug=False, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False):		if debug: print teamMeets		meet = Meet()		teams = []		if includeEvents == 'all':			includeEvents = allEvents		commonEvents = allEvents		for teamMeet in teamMeets:			newTeamName = None			newTeam = teamMeet[0]			newMeet = teamMeet[1]			if len(teamMeet) >= 3 and teamMeet[2]:  # maybe pass in new team name				newTeamName = teamMeet[2]			if len(teamMeet) == 4:				season = teamMeet[3]			else:				season = None			if isinstance(newMeet, basestring):  # just a name				newMeet = Meet(name=newMeet, gender=gender, teams=[newTeam], season=season)			commonEvents = commonEvents & set(newMeet.eventSwims.keys())			if debug:				print set(newMeet.eventSwims.keys())				newMeet.printout()			duplicates = None			if not newTeamName:				duplicates = teams.count(newTeam)				teams.append(newTeam)			else:				teams.append(newTeamName)			for swim in newMeet.getSwims(newTeam):				if duplicates:					swim.scoreTeam = swim.getScoreTeam() + ' ' + str(duplicates + 1)				if newTeamName:					swim.scoreTeam = newTeamName				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		if len(meet.teams) == 2:			if selectEvents:				meet.topEvents(25, 3, 4)				'''need to fix event selection for dual meets'''			meet.events = (commonEvents | includeEvents) - excludeEvents			meet.score(dual=True)		else:			if selectEvents:				meet.topEvents()			meet.score()		if debug: meet.printout()		return meet	'''	optimal lineup creator	'''	def lineup(self, teamsSeasons, meet, debug=False, resetTimes=False, events=eventsDualS, gender='Men'):		meet.events = events		teams = []		print teamsSeasons		if debug:			print meet.getEvents(), events		for team in teamsSeasons:			teams.append(team)			if not teamsSeasons[team]:				season = thisSeason()			else:				season = teamsSeasons[team]			# handle duplicate teams			newMeet = self.topTimes(events=events, teams=[team], season=season, gender=gender, topTimes=True).getSwims()			duplicates = teams.count(team) - 1			if debug: print team, season, teams, duplicates			for swim in newMeet:				if duplicates > 0:					swim.scoreTeam = swim.getScoreTeam() + ' ' + str(duplicates + 1)					# print swim.getScoreTeam() + ' ' + str(duplicates + 1)				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		meet.place()		teams = teamsSeasons.keys()		if debug:			meet.printout()		# lineup optimize if creating linup for just one team		if len(teams) == 1:			meet.lineup(teams.pop(), debug=debug)		else:			meet.topEvents(17, indMax=3, totalMax=4)		return meet	'''	top expected score for the whole team	'''	def topTeamScore(self, team, dual=True, season=thisSeason(), gender='Men', division='D3', nsigma=-2, weeksIn=None):		# conver the week to a date		startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017		endDate = date(season, 2, 15)  # and Feb 15 as an end date, 16 week season		if weeksIn == None:  # can't simulate with future data			simDate = date.today()			weeksIn = int((simDate - startDate).days / 7)		else:			simDate = startDate + timedelta(weeks=weeksIn)		if simDate > date.today():  # can't simulate with future data			simDate = date.today()			weeksIn = int((simDate - startDate).days / 7)		# cache off times?		if dual:			events = eventsDualS		else:			events = eventsChamp		topMeet = self.topTimes(teams=[team], season=season, gender=gender, events=events, divisions=[division],								date=simDate)		topMeet.topEvents(teamMax=17, indMax=3)		if dual:			scores = topMeet.expectedScores(swimmers=6, division=division, nsigma=nsigma)		else:			scores = topMeet.expectedScores(swimmers=16, division=division, nsigma=nsigma)		if team in scores:			return scores[team]		return 0	'''	returns meet of top times	'''	def topTimes(self, events=None, teams=MIAC, season=None, gender='Men', topTimes=True, meetForm=True,				divisions='all', date=None):		if not events:			events = allEvents		if teams == 'all':			teams = self.teams		if divisions == 'all':			divisions = ['D1', 'D2', 'D3']		if not season:			season = thisSeason()  # use current season		topMeet = Meet(events=events)		swimmers = {}		select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\				.where(TeamSeason.gender==gender, TeamSeason.team << list(teams), TeamSeason.division << list(divisions),			   	TeamSeason.season==season, Swim.event << list(events))		if topTimes:			if date:				qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swimmer.team, Swimmer.year).group_by(					Swim.name, Swim.event, Swimmer.team, Swimmer.year).where(Swim.date < date)			else:				qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swimmer.team, Swimmer.year).group_by(Swim.name,					Swim.event, Swimmer.team, Swimmer.year)		else:  # mean time for the season			qwery = select.select(Swim.name, Swim.event, fn.Avg(Swim.time), Swimmer.team, Swimmer.year).group_by(Swim.name,				Swim.event, Swimmer.team, Swimmer.year)		for swim in qwery:			if topTimes:				time = swim.min			else:				time = swim.avg			newSwim = Swim(name=swim.name, event=swim.event, time=time, gender=gender, team=swim.swimmer.team,									  season=season, year=swim.swimmer.year, swimmer=swim.swimmer)			if meetForm:				topMeet.addSwim(newSwim)			else:				if not swim.team in swimmers:					swimmers[swim.team] = {}				if not swim.name in swimmers[swim.team]:						swimmers[swim.team][swim.name] = {}				swimmers[swim.team][swim.name][swim.event] = newSwim		if meetForm:			topMeet.place()			return topMeet		return swimmers	def conference(self, teams=MIAC, season=None, topTimes=True, gender='Men', divisions='D3', date=None,				   update=False, taper=False, weeksIn=10, nextYear=False, nats=False):		events = eventsChamp3		if not season:			season = thisSeason()  # use current season		conference = self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=topTimes,								   divisions=[divisions], date=date)		if nextYear:			conference.nextYear(self)			season += 1  # update the correct season		if taper:			conference.taper()		swimmerLimit = 17		conference.topEvents(swimmerLimit)		conference.score()		# update stored win probabilities		weeksOut = 16 - weeksIn		if nextYear:			weeksOut = '-1'			weeksIn = '-1'		if update:			conference.scoreMonteCarlo(weeksOut=weeksOut)			teamProb = conference.getWinProb()			for team in teamProb:				teamSeason = TeamSeason.get(team=team, division=divisions, gender=gender, season=season)				try:					stats = TeamStats.get(teamseasonid=teamSeason.id, week=weeksIn)					if nats:						stats.winnats = teamProb[team]					else:						stats.winconf = teamProb[team]					print 'Existing:', team, season, stats.winconf, weeksIn, date, teamSeason.id, stats.id					print stats.save()				except TeamStats.DoesNotExist:					print 'New:', team, season, teamProb[team], weeksIn, date					if nats:						TeamStats.create(teamseasonid=teamSeason.id, week=weeksIn, winnats=teamProb[team], date=date)					else:						TeamStats.create(teamseasonid=teamSeason.id, week=weeksIn, winconf=teamProb[team], date=date)		return conference	def nationals(self, season=None, topTimes=True, gender='Men', division='D3', simDate=None, update=False,				  nextYear=False, weeksIn=4):		teams = self.allTeams[gender][division]		print season		startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017		print startDate		if weeksIn:			simDate = week2date(weeksIn, season)		print simDate		meet = self.conference(teams=teams, season=season, topTimes=topTimes, gender=gender, divisions=division,							   date=simDate, nextYear=nextYear, nats=True, update=update, weeksIn=weeksIn)		meet.scoreMonteCarlo(dual=False, weeksOut=16-weeksIn)		# update db with win probs		print meet.getWinProb()		if update:			teamProb = meet.getWinProb()			for team in teamProb:				print team, teamProb[team]				TeamSeason.update(winnats=teamProb[team]).where(TeamSeason.team==team, TeamSeason.season==season+1,											TeamSeason.gender==gender, TeamSeason.division==division).execute()		return meet	'''	returns top 25 teams and caches ranking data	'''	def teamRank(self, division='D3', gender='Men', season=2016, num=25):		teamScores = {}		# populate if null for nats win probs		#if TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.division==division,		#							TeamSeason.season==season, TeamSeason.winnats >> None).count() > 0:		#	self.nationals(season=season, division=division, gender=gender, update=True)		# populate null values for team strength		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.division==division,								TeamSeason.season==season, TeamSeason.strengthdual >> None):			dual = self.topTeamScore(team.team, season=season, gender=gender, division=division, dual=True)			invite = self.topTeamScore(team.team, season=season, gender=gender, division=division, dual=False)			#print team.team, invite, team.strengthinvite			TeamSeason.update(strengthinvite=invite, strengthdual=dual).where(TeamSeason.id == team.id).execute()		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.season==season,				TeamSeason.division==division).order_by(TeamSeason.strengthinvite.desc()).limit(num):			teamScores[team.team] = team		return sorted(teamScores.values(), key=lambda t: t.strengthinvite, reverse=True)	# update the probabilities of winning conference	def updateConferenceProbs(self, division='D3', gender='Women', season=2017, weeksIn=None, forceUpdate=False):		simDate = week2date(weeksIn, season)		startDate = week2date(0, season)		print simDate		for team in TeamSeason.select().where(TeamSeason.division==division, TeamSeason.gender==gender,					TeamSeason.season==season):			try:				stats = TeamStats.get(teamseasonid=team.id, week=weeksIn)				if stats.winconf is not None and not forceUpdate:  # we already have data					continue				print stats.winconf, team.team				teams = self.conferences[division][gender][team.conference]				if weeksIn == -1:  # pre-season					self.conference(teams=teams, gender=gender, season=season-1, divisions=division, update=True,								nextYear=True, date=startDate)				self.conference(teams=teams, gender=gender, season=season, divisions=division, update=True,								weeksIn=weeksIn, date=simDate)			except TeamStats.DoesNotExist:				teams = self.conferences[division][gender][team.conference]				if weeksIn == -1:  # pre-season					self.conference(teams=teams, gender=gender, season=season-1, divisions=division, update=True,								nextYear=True, date=startDate)				self.conference(teams=teams, gender=gender, season=season, divisions=division, update=True,								weeksIn=weeksIn, date=simDate)	def updateTeamStrength(self, division='D3', gender='Women', season=2017, weeksIn=None, update=True):		simDate = week2date(weeksIn, season)		print simDate		for team in TeamSeason.select().where(TeamSeason.division==division, TeamSeason.gender==gender,					TeamSeason.season==season):			try:				stats = TeamStats.get(teamseasonid=team.id, week=weeksIn)				if stats.strengthinvite is None or update:					scoreInv = self.topTeamScore(team.team, dual=False, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)					stats.strengthinvite = scoreInv				if stats.strengthdual is None or update:					scoreDual = self.topTeamScore(team.team, dual=True, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)					stats.strengthdual = scoreDual				print team.team, scoreInv, scoreDual				stats.save()			except TeamStats.DoesNotExist:				scoreInv = self.topTeamScore(team.team, dual=False, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)				scoreDual = self.topTeamScore(team.team, dual=True, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)				TeamStats.create(teamseasonid=team.id, week=weeksIn, strengthinvite=scoreInv, strengthdual=scoreDual,								 date=simDate)	def updateTeamStats(self, division='D3', gender='Women', week=6):		if week2date(week) == date.today():			return  # would be a future week		database.nationals(nextYear=False, gender=gender, division=division, season=2017, update=True, weeksIn=week)		database.updateConferenceProbs(division=division, gender=gender, season=2017, weeksIn=week)		database.updateTeamStrength(division=division, gender=gender, season=2017, weeksIn=week, update=True)	def conferencePlace(self, division, gender, newSwims, year=2014):		newEvents = set()		for swim in newSwims:			newEvents.add(swim[0])		confMeets = {}		with open('./data/' + division + gender + '.csv') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet					confMeets[confName].addSwims(Meet(name=meetName, events=newEvents, gender=gender,													  topSwim=True).getSwims())				else:					confMeets[confName] = Meet(name=meetName, events=newEvents, gender=gender, topSwim=True,											   season=year)		confScores = {}		for conference in confMeets:			confMeet = confMeets[conference]			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScores	def taperMeets(self, year=2015, gender='Women', division='D1'):  #find meets where most best times come from		teamMeets = {}		#teams=['Univ of Utah', 'Stanford', 'California', 'Arizona', 'Southern Cali', 'Arizona St']		teams = self.allTeams[gender][division]		for team in teams:			for swim in Swim.raw("WITH topTimes AS (SELECT name, event, meet, time, row_number() OVER (PARTITION BY event,name "					 "ORDER BY time) AS rnum "					 "FROM Swim "					 "WHERE team=%s AND season=%s AND date > '%s-02-01' AND gender=%s) "					 "SELECT name,event,meet,time FROM topTimes WHERE rnum=1",					 team, year, year, gender):				if not team in teamMeets:					teamMeets[team] = []				teamMeets[team].append(swim.meet)		#print teamMeets.keys()		taperMeets = {}		for team in teamMeets:			taperMeet = max(set(teamMeets[team]), key=teamMeets[team].count)			#print team, taperMeet			if taperMeet not in taperMeets:				taperMeets[taperMeet] = 0			taperMeets[taperMeet] += 1		bigTaperMeets = [i for i in taperMeets if taperMeets[i]>2]		return bigTaperMeets	def taperSwims(self, teams, gender, conference, season=None, numTimes=3):		if season == None:			season = thisSeason()		teamSwims = {}		for team in teams:			teamSwims[team] = {}			for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(TeamSeason.team==team,					TeamSeason.gender==gender, TeamSeason.conference==conference, TeamSeason.season==season):					teamSwims[team][swimmer.name] = {}					times = []					#print team, gender					#print swimmer.name, swimmer.team					for swim in Swim.raw("WITH topTimes as "							"(SELECT name, gender, meet, event, time, year, division, swimmer_id, row_number() OVER "							"(PARTITION BY event, name ORDER BY time) as rnum "							"FROM Swim WHERE swimmer_id=%s) "							"SELECT name, event, meet, time, gender, division, year, swimmer_id FROM topTimes WHERE "										 "rnum=1",							swimmer.id):						if swim.event == '1000 Yard Freestyle': continue						cdf = self.getTimeCDF(gender, swim.division, swim.event, 100)						points = 1 - cdf(swim.time)						#print swim.time, swim.gender, swim.division, swim.event, points						heapq.heappush(times, (points, swim))					for (points, swim) in heapq.nlargest(numTimes, times):  #take three best times						#print team, swimmer.name, swim.event, points, swim.time						teamSwims[team][swimmer.name][swim.event] = swim		return teamSwims	def taperStats(self, division='D1', gender='Women', season=2016, weeks=10):		print weeks		drops = []		teamDrops = {}		startDate = date(season-1, 10, 15)  # use Oct 15 as a hard-coded start date		newDate = startDate + timedelta(weeks=weeks)		for conference in self.conferences[division][gender]:			for team in self.conferences[division][gender][conference]:				taperSwims = set()				#if not team in 'Carleton':				#	continue				topTimes = self.taperSwims(teams=[team], gender=gender, season=season, conference=conference)				for team in topTimes:					for swimmer in topTimes[team]:						for event in topTimes[team][swimmer]:							taperSwims.add(topTimes[team][swimmer][event])							#print event, swimmer				for taperSwim in taperSwims:					#print taperSwim.swimmer.season					for earlySwim in Swim.select(fn.min(Swim.time)).where(Swim.swimmer==taperSwim.swimmer,							Swim.event==taperSwim.event, Swim.date < newDate):						if earlySwim.min:							dropPer = 100 * (earlySwim.min - taperSwim.time)/taperSwim.time							drops.append(dropPer)							if team not in teamDrops:								teamDrops[team] = []							teamDrops[team].append(dropPer)							#print taperSwim.event, taperSwim.swimmer.name, earlySwim.min, taperSwim.time, dropPer		#print np.mean(drops), np.std(drops)		allStats = []		for team in teamDrops:			meanDrop = np.mean(teamDrops[team])			stdDrop = np.std(teamDrops[team])			#print team, round(meanDrop, 2), round(stdDrop, 2), len(teamDrops[team])			#print gender, division, team			try:				oldTeam = TeamSeason.get(TeamSeason.gender==gender, TeamSeason.division==division, TeamSeason.team==team,									 TeamSeason.season==season)				newStats = {'week': weeks, 'date': newDate, 'teamseasonid': oldTeam.id,						'toptaper': meanDrop, 'toptaperstd': stdDrop}				allStats.append(newStats)			except:				pass		print allStats		if len(allStats)==0:			return		# now insert into database		db_proxy.connect()		with db_proxy.transaction():			TeamStats.insert_many(allStats).execute()	def getImprovement(self, gender='Men', teams=MIAC, season1=thisSeason()-1, season2=thisSeason()-2):		posSeasons = [2016, 2015, 2014, 2013, 2012, 2011]		#print season1, season2		if season1 > season2 and season1 in posSeasons and season2 in posSeasons:			seasons = range(season2, season1)			#print seasons		teamImprovement = {}		for swim in Improvement.select().where(Improvement.fromseason << seasons, Improvement.gender==gender,									   Improvement.team << list(teams)):			if swim.team not in teamImprovement:				teamImprovement[swim.team] = []			teamImprovement[swim.team].append(swim.improvement)		if len(teams)==1 and teams[0] in teamImprovement:			return teamImprovement[teams[0]]		return teamImprovementif __name__ == "__main__":	# database setup	urlparse.uses_netloc.append("postgres")	if "DATABASE_URL" in os.environ:  # production		url = urlparse.urlparse(os.environ["DATABASE_URL"])		db = PostgresqlDatabase(database=url.path[1:],								user=url.username,								password=url.password,								host=url.hostname,								port=url.port)	else:		db = PostgresqlDatabase('swimdb', user='hallmank')	database = SwimDatabase(db)	for division in ['D1', 'D2', 'D3']:		for gender in ['Women', 'Men']:			database.updateTeamStats(division, gender, week=7)