import reimport numpy as npimport operatorfrom datetime import date as Date, timedeltafrom peewee import *import os, urlparse, time#from scipy.stats import norm, linregress#simport matplotlib.pyplot as pltfrom swimdb import Improvement, Team, TeamStats, TeamSeason, Swimmer, Swim, TeamMeet, swimTime, getSkewDistfrom swimdb import TempMeet as Meetfrom events import eventOrderInd, eventsChamp3, eventsChamp, eventsDualS, requiredEvents, allEvents, eventOrderfrom math import logpointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]# setup database connectiondb_proxy = Proxy()db = Proxy()def thisSeason():	today = Date.today()	if today.month > 6:		return today.year + 1	return today.yeardef rejectOutliers(dataX, dataY=None, l=5, r=6):	u = np.mean(dataX)	s = np.std(dataX)	if dataY:		data = zip(dataX, dataY)		newList = [i for i in data if (u - l*s < i[0] < u + r*s)]		newX, newY = zip(*newList)		return list(newX), list(newY)	else:		newList = [i for i in dataX if (u - l*s < i < u + r*s)]	return newListdef ECDF(data):	def cdf(num):		d = data		l = float(len(d))		return (sum(1 for i in d if i < num) + sum(.5 for i in d if i==num))/l	return cdf# retrieves all conference affiliationsdef getConfs():	confs = {'D1': {'Men': {}, 'Women': {}}, 'D2': {'Men': {}, 'Women': {}}, 'D3': {'Men': {}, 'Women': {}}}	allTeams = {'Men': {'D1': set(), 'D2': set(), 'D3': set()}, 'Women': {'D1': set(), 'D2': set(), 'D3': set()}}	for newTeam in TeamSeason.select(TeamSeason.team, TeamSeason.conference, TeamSeason.division,									 TeamSeason.gender).distinct(TeamSeason.team):		if newTeam.conference not in confs[newTeam.division][newTeam.gender]:			confs[newTeam.division][newTeam.gender][newTeam.conference] = set()		confs[newTeam.division][newTeam.gender][newTeam.conference].add(newTeam.team.strip())		allTeams[newTeam.gender][newTeam.division].add(newTeam.team.strip())	for division in ['D1', 'D2', 'D3']:		allTeams['Men'][division] = list(allTeams['Men'][division])		allTeams['Men'][division].sort()		allTeams['Women'][division] = list(allTeams['Women'][division])		allTeams['Women'][division].sort()	return confs, allTeamsdef nextYear(year):	if year=='Freshman':		return 'Sophomore'	if year=='Sophomore':		return 'Junior'	if year=='Junior':		return 'Senior'	return Nonedef grad(f, x, y, h=0.0025):	dx = (f(x, y) - f(x+h, y))/h	dy = (f(x, y) - f(x, y+h))/h	return dx, dydef gradientDescent(f, x0, y0, step=.001):	for i in range(10):		dx, dy = grad(f, x0, y0)		length = ((dx**2 + dy**2) ** .5)		print 'delta:', dx, dy		x0 += step * dx / length		y0 += step * dy / length		if x0 < 0:			x0 = 0.001		if y0 < 0:			y0 = 0.001		#print x0, y0	return x0, y0def frange(x, y, jump):	while x < y:		yield x		x += jumpdef date2week(d=None):	if not d:		d = Date.today()	if d > Date.today():		d = Date.today()	if d.month > 6:		season = d.year + 1	else:		season = d.year	startDate = Date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017	weeksIn = int((d - startDate).days / 7)	last_week = 25	if weeksIn > last_week:		return last_week	return weeksIndef week2date(week, season=None):	if not season:		season = thisSeason()	startDate = Date(season - 1, 10, 16)  # use Oct 15 as the start date, prolly good for 2017	if week == None:		return Date.today()	simDate = startDate + timedelta(weeks=week)	if simDate > Date.today():  # can't simulate with future data		simDate = Date.today()	return simDate'''full database methods''''''creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]'''def swimMeet(teamMeets, gender=None, includeEvents='all', excludeEvents=set(),			 selectEvents=True, resetTimes=False, verbose=False):	meet = Meet()	teams = []	if includeEvents == 'all':		includeEvents = allEvents	commonEvents = allEvents  # start with all events and whittle down	for teamMeet in teamMeets:		newTeam = teamMeet['team']		newMeet = teamMeet['meet']		if 'season' in teamMeet:			season = teamMeet['season']		else:			season = None		if verbose: print isinstance(newMeet, basestring)		if isinstance(newMeet, basestring):  # just a name			newMeet = Meet(name=newMeet, gender=gender, teams=[newTeam], season=season, topSwim=True)		commonEvents = commonEvents & set(newMeet.eventSwims.keys())		if verbose: print season, newMeet, newTeam		if verbose: print newMeet.eventSwims		# resolve duplicate names, first try season, then a number		newTeamName = None		if teams.count(newTeam) > 0:			newTeamName = newTeam + ' ' + season			if teams.count(newTeamName) > 0:				newTeamName += ' ' + str(teams.count(newTeamName))		if newTeamName:			teams.append(newTeamName)		else:			teams.append(newTeam)		# now apply to existing swims		for swim in newMeet.getSwims(newTeam):			if newTeamName:				swim.scoreTeam = newTeamName			meet.addSwim(swim)	if verbose: print meet	meet.reset(times=resetTimes)	if len(meet.teams) == 2:		if selectEvents:			meet.topEvents(25, 3, 4)			'''need to fix event selection for dual meets'''		meet.events = (commonEvents | includeEvents) - excludeEvents		meet.score(dual=True)	else:		if selectEvents:			meet.topEvents()		meet.events = eventsChamp3		meet.score()	return meet'''optimal lineup creator'''def lineup(teams, meet, resetTimes=False, events=None, gender='Men'):	if events:		meet.events = events	teamNames = []	for teamName in teams:		division = teams[teamName]['division']		if not 'season' in teams[teamName]:			season = thisSeason()		else:			season = teams[teamName]['season']		# add each team's top times to meet		team = TeamSeason.get(season=season, team=teamName, gender=gender, division=division)  # need division		topTimesMeet = team.topTimes(events=events)		# resolve duplicate names, first try season, then a number		newTeamName = None		if teamNames.count(teamName) > 0:			newTeamName = teamName + ' ' + season			if teamNames.count(newTeamName) > 0:				newTeamName += ' ' + str(teamNames.count(newTeamName))		if newTeamName:			teamNames.append(newTeamName)		else:			teamNames.append(teamName)		for swim in topTimesMeet.getSwims():			if newTeamName:				swim.scoreTeam = newTeamName			meet.addSwim(swim)	meet.reset(times=resetTimes)	meet.place()	# lineup optimize if creating lineup for just one team	if len(teamNames) == 1:		meet.lineup(teamNames.pop())	else:		meet.topEvents(17, indMax=3)	return meet'''top expected score for the whole team'''def topTeamScore(teamName, dual=True, season=thisSeason(), gender='Men', division='D3', weeksIn=None):	# convert the week to a date	simDate = week2date(weeksIn, season)	# cache off times?	if dual:		events = eventsDualS	else:		events = eventsChamp	team = TeamSeason.get(season=season, team=teamName, gender=gender, division=division)  # need division	topMeet = team.topTimes(events=events, dateStr=simDate)	topMeet.topEvents(teamMax=17, indMax=3)	if dual:		scores = topMeet.expectedScores(swimmers=6, division=division)	else:		scores = topMeet.expectedScores(swimmers=16, division=division)	if team in scores:		return scores[team]	return 0'''returns meet of average times'''def averageTimes(conf, season=None, gender='Men', division=None, date=None):	if type(date) == type(str):		date = Date(date)	if not season:		season = thisSeason()  # use current season	if not date:		date = Date.today()	topMeet = Meet()	if conf=='Nationals':		select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\			.where(TeamSeason.gender==gender, TeamSeason.division==division, TeamSeason.season==season, Swim.date < date)	else:		select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\			.where(TeamSeason.gender==gender, TeamSeason.conference==conf, TeamSeason.season==season, Swim.date < date)	query = select.select(Swim.name, Swim.event, fn.Avg(Swim.time), Swim.team, Swimmer.year).group_by(Swim.name,			Swim.event, Swim.team, Swimmer.year)	for swim in query:		time = swim.avg		if swim.event != '1000 Free':			newSwim = Swim(name=swim.name, event=swim.event, time=time, gender=gender, team=swim.team,				season=season, year=swim.swimmer.year, swimmer=swim.swimmer)			topMeet.addSwim(newSwim)	topMeet.place()	return topMeet'''returns meet of top times, start with top 75 in each event'''def topTimes(season, gender, conf, division=None, dateStr=None, limit=75):	if not dateStr:		meetDate = Date.today()		dateStr = str(meetDate.year) + '-' + str(meetDate.month) + '-' + str(meetDate.day)	newMeet = Meet()	if conf == 'Nationals':		'''			if transfers:				if swim.name == 'Ledecky, Katie': continue				if swim.name == 'Gonzalez, Hugo': swim.team='Virginia Tech'				if swim.name == 'Apple, Zachary': swim.team='Indiana'				if swim.name == 'Andison, Bailey': swim.team='Indiana'		'''		for swim in Swim.raw("SELECT event, time, name, team, date, year, meet, swimmer_id, rank FROM ( "				"SELECT event, time, name, team, date, year, meet, swimmer_id, division, season, gender, rank() "				"over (Partition BY event ORDER BY event, time) FROM top_swim "				"WHERE season=%s and gender=%s and division=%s and date<%s) ts WHERE rank<%s",				season, gender, division, dateStr, limit):			swim.gender = gender			swim.division = division			swim.conference = conf			swim.season = season			newMeet.addSwim(swim)	else:		for swim in Swim.raw("SELECT event, time, name, team, date, year, meet, swimmer_id, rank FROM ( "				"SELECT event, time, name, team, date, year, meet, swimmer_id, division, season, gender, rank() "				"over (Partition BY event ORDER BY event, time) "				"FROM top_swim WHERE season=%s and gender=%s and conference=%s and date<%s) ts WHERE rank<%s",				season, gender, conf, dateStr, limit):			swim.gender = gender			swim.division = division			swim.conference = conf			newMeet.addSwim(swim)	if '1000 Free' in newMeet.eventSwims:		del(newMeet.eventSwims['1000 Free'])	return newMeet# simulates conference or national meet, must be real conferencedef sim_conference(season, gender, conf, division=None, dateStr=None, top=True, update=False, taper=False,			   nextYear=False, teamMax=17):	if not season:		season = thisSeason()  # use current season	start = time.time()	if top:		conf_meet = topTimes(conf=conf, season=season, gender=gender, division=division, dateStr=dateStr)	else:  # use avg times		conf_meet = averageTimes(conf=conf, season=season, gender=gender, division=division, date=dateStr)	if nextYear:  # estimate next year's results		conf_meet.nextYear()		season += 1  # update the correct season	print time.time() - start	conf_meet.events = eventsChamp3	conf_meet.topEvents(teamMax=teamMax)	print time.time() - start	conf_meet.score()	if taper:		conf_meet.taper()	if update:		weeksIn = date2week(dateStr)		# print weeksIn		if conf_meet == 'Nationals':			nats = True		else:			nats = False		conf_meet.update(weeksIn=weeksIn, division=division, gender=gender, season=season, nats=nats)	return conf_meet'''returns top 25 teams and caches ranking data'''def teamRank(division='D3', gender='Men', season=2016, num=25):	#sentinelStr = division + gender + str(season) + str(num)	#if sentinelStr in self.teamRankCache:	#	return self.teamRankCache[sentinelStr]	teamScores = {}	for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.division==division,							TeamSeason.season==season):		teamScores[team.team] = team	teams = sorted(teamScores.values(), key=lambda t: t.getStrength(), reverse=True)[:num]	#self.teamRankCache[sentinelStr] = teams	return teams'''Returns top swimmers in a conference by top 3 event ppts'''def swimmerRank(division='D3', gender='Men', season=2019, num=25, conference=None):	# make sure all ppts are saved to the db	if not conference:  # all conferences		for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,						TeamSeason.division==division, TeamSeason.season==season, Swimmer.ppts.is_null()):			swimmer.getPPTs()	else:		for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,				TeamSeason.division==division, TeamSeason.season==season, TeamSeason.conference==conference,				Swimmer.ppts.is_null()):			swimmer.getPPTs()	# return sorted list of top swimmers	swimmers = []	if not conference:  # all conferences		for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,				TeamSeason.division==division, TeamSeason.season==season,				Swimmer.ppts.is_null(False)).order_by(Swimmer.ppts.desc()).limit(num):			swimmers.append(swimmer)	else:		for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(Swimmer.gender==gender,				TeamSeason.division==division, TeamSeason.season==season, Swimmer.ppts.is_null(False),				TeamSeason.conference==conference).order_by(Swimmer.ppts.desc()).limit(num):			swimmers.append(swimmer)	return swimmersdef update_weekly_stats(week=None, division='D3', gender='Women', season=2018):	if not week:		week = date2week()	simDate = week2date(week)	print simDate	if simDate > Date.today():		return  # would be a future week	# national meets probabilities	sim_conference(conf='Nationals', gender=gender, division=division, season=season, update=True, dateStr=simDate)	# conf meet odds	conferences, _ = getConfs()	for conference in conferences[division][gender]:		if conference == '':			continue		sim_conference(conf=conference, gender=gender, season=season, division=division, update=True, dateStr=simDate)	# update team strengths	for team in TeamSeason.select().where(TeamSeason.division==division, TeamSeason.gender==gender,			TeamSeason.season==season):		team.getWeekStrength(update=True, weeksIn=week)'''returns which meets were likely tapers'''def taperMeets(year=2015, gender='Women', division='D1'):  # find meets where most best times come from	teamMeets = {}	#teams=['Univ of Utah', 'Stanford', 'California', 'Arizona', 'Southern Cali', 'Arizona St']	_, allTeams = getConfs()	teams = allTeams[gender][division]	for team in teams:		for swim in Swim.raw("SELECT * FROM top_swim WHERE team=%s AND season=%s AND date > '%s-02-01' AND "							 "gender=%s) ", team, year, year, gender):			if not team in teamMeets:				teamMeets[team] = []			teamMeets[team].append(swim.meet)	# count number of teams tapered at each meet	taperMeets = {}	for team in teamMeets:		taperMeet = max(set(teamMeets[team]), key=teamMeets[team].count)		if taperMeet not in taperMeets:			taperMeets[taperMeet] = 0		taperMeets[taperMeet] += 1	bigTaperMeets = [i for i in taperMeets if taperMeets[i]>2]	return bigTaperMeets'''returns improvemnt data from db, from season1 to season2'''def getImprovement(gender='Men', teams=['Carleton'], season1=thisSeason()-1, season2=thisSeason()-2):	posSeasons = [2018, 2017, 2016, 2015, 2014, 2013, 2012, 2011]	#print season1, season2	if season1 > season2 and season1 in posSeasons and season2 in posSeasons:		seasons = range(season2, season1)		#print seasons	else:		return 	teamImprovement = {}	for swim in Improvement.select().where(Improvement.fromseason << seasons, Improvement.gender==gender,								   Improvement.team << list(teams)):		if swim.team not in teamImprovement:			teamImprovement[swim.team] = []		teamImprovement[swim.team].append(swim.improvement)	if len(teams)==1 and teams[0] in teamImprovement:		return teamImprovement[teams[0]]	return teamImprovement'''calculates and stores improvement data for a season'''def storeImprovement(season=2018):	swims = []	for team in TeamSeason.select().where(TeamSeason.season==season):		preTeam = team.getPrevious()		if not preTeam:			continue		top1 = team.getTaperSwims(structured=True)		top2 = preTeam.getTaperSwims(structured=True)		for swimmer in top1:			if not swimmer in top2:				continue			for event in top1[swimmer]:				if not event in top2[swimmer]:					continue				swim1 = top1[swimmer][event]				swim2 = top2[swimmer][event]				time1 = swim1.time				time2 = swim2.time				drop = (time2-time1) / ((time1+time2) / 2) * 100				#print swimmer, event, time1, time2				if abs(drop) > 10:  # toss outliers					continue				newSwim = {'fromseason': season-1, 'toseason': season, 'name': swim1.name,						   'fromyear': swim2.year, 'toyear': swim1.year,						   'team': team.team, 'gender': team.gender, 'event': event,						   'improvement': drop,  # positive=faster						   'fromtime': swim2.time, 'totime': swim1.time,						   'conference': team.conference, 'division': team.division}				#print newSwim				swims.append(newSwim)	print len(swims)	db_proxy.connect()	for i in range(len(swims) / 100):		print i		with db_proxy.transaction():			Improvement.insert_many(swims[i*100:(i+1)*100]).execute()def update_season_stats(season=2018, recalc=True):	if recalc:		print 'storing improvement'		storeImprovement(season)	for team in TeamSeason.select().where(TeamSeason.season==season):		print team.team		team.updateSeasonStats()if __name__ == "__main__":	# database setup	urlparse.uses_netloc.append("postgres")	if "DATABASE_URL" in os.environ:  # production		url = urlparse.urlparse(os.environ["DATABASE_URL"])		db = PostgresqlDatabase(database=url.path[1:],								user=url.username,								password=url.password,								host=url.hostname,								port=url.port)	else:		db = PostgresqlDatabase('swimdb', user='hallmank')