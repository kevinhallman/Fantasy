import reimport numpy as npimport operatorfrom operator import itemgetterfrom datetime import date, timedeltafrom peewee import *import os, urlparseimport heapqimport time as Timefrom sympy import binomialfrom swimdb import Improvement, TeamMeet, Timedist, Team, TeamStats, TeamSeason, Swimmer, Swimfrom swimdb import Meet as SMeetfrom math import logfrom itertools import permutations, product, combinations#import statsmodels.api as smfrom scipy.stats import norm, truncnorm, skewnormfrom scipy.interpolate import UnivariateSpline#from scipy.interpolate import interp1d#from numpy.linalg import lstsq#from scipy import polyfit, polyvalfrom scipy.stats import linregress#import matplotlib.mlab as mlabfrom math import erf, sqrtpointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]eventsDualS = ["200 Yard Medley Relay","1000 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsDualL = ["400 Yard Medley Relay","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","400 Yard Individual Medley","400 Yard Freestyle Relay"]eventsChamp = ["400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsChamp3 = ['1 mtr Diving','200 Yard Freestyle Relay','','500 Yard Freestyle','200 Yard Individual Medley', '50 Yard Freestyle','','400 Yard Medley Relay','','400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','800 Yard Freestyle Relay','','1650 Yard Freestyle','','200 Yard Medley Relay','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','','400 Yard Freestyle Relay','3 mtr Diving']#eventsChamp3 = ['500 Yard Freestyle','200 Yard Individual Medley', '50 Yard Freestyle','','400 Yard Individual# Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','1650 Yard Freestyle','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly']eventsDay1 = ['1 mtr Diving','200 Yard Freestyle Relay','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','400 Yard Medley Relay']eventsDay2 = ['400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','800 Yard Freestyle Relay']eventsDay3 = ['1650 Yard Freestyle','200 Yard Medley Relay','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','400 Yard Freestyle Relay','3 mtr Diving']allEvents={"400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay",'1000 Yard Freestyle','100 Yard Breastroke','200 Yard Breastroke'}eventsChampInd={"400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley",'100 Yard Breastroke','200 Yard Breastroke'}MIAC = ["Carleton","Augsburg","St. Olaf","Saint Mary's MN","Macalester","Gustavus","Saint Benedict","St. Kate's","Concordia","St. John's","St. Thomas","Hamline"]requiredEvents={"200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly"}eventOrder = ["50 Yard Freestyle","100 Yard Freestyle","200 Yard Freestyle","500 Yard Freestyle","1000 Yard Freestyle","1650 Yard Freestyle","100 Yard Butterfly","200 Yard Butterfly","100 Yard Backstroke","200 Yard Backstroke","100 Yard Breastroke","200 Yard Breastroke","200 Yard Individual Medley","400 Yard Individual Medley","200 Yard Medley Relay","400 Yard Medley Relay","200 Yard Freestyle Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay"]#setup database connectiondb_proxy = Proxy()db = Proxy()swimDatabase = None#make time look nicedef swimTime(time):	(seconds, point) = re.split("\.", str(time))	if int(seconds) < 60:		time = round(time, 2)		time = str(time)		while len(time) < 5:			time += '0'		return time	minutes = str(int(seconds) / 60)	seconds = str(int(seconds) % 60)	while len(seconds) < 2:		seconds = '0' + seconds	while len(point) < 2:		point = point + '0'	return  minutes + ":" + seconds + "." + point[:2]#convers to a time in secondsdef toTime(time):	try:		if time[0]=="X" or time[0]=="x":			time=time[1:]		if re.match(".*:.*",time) == None:			return float(time)		return float(re.split(":",time)[0])*60 +float(re.split(":",time)[1])	except TypeError:		return 0'''sees if one list contains another'''def contains(small, big):	for i in small:		if not i in big:			return False	return True'''events contained within a relay'''def relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']def thisSeason():	today = date.today()	if today.month > 6:		return today.year + 1	return today.yeardef rejectOutliers(dataX, dataY=None, l=5, r=6):	u = np.mean(dataX)	s = np.std(dataX)	if dataY:		data = zip(dataX, dataY)		newList = [i for i in data if (u - l*s < i[0] < u + r*s)]		newX, newY = zip(*newList)		return list(newX), list(newY)	else:		newList = [i for i in dataX if (u - l*s < i < u + r*s)]	#print swimTime(max(newList)), swimTime(min(newList))	#print "Num rejected: " + str(len(dataX)-len(newList))	return newListdef ECDF(data):	def cdf(num):		d = data		l = float(len(d))		return (sum(1 for i in d if i < num) + sum(.5 for i in d if i==num))/l	return cdfdef getConfs():	confs = {'D1': {'Men': {}, 'Women': {}}, 'D2': {'Men': {}, 'Women': {}}, 'D3': {'Men': {}, 'Women': {}}}	allTeams = {'Men': {'D1': [], 'D2': [], 'D3': []}, 'Women': {'D1': [], 'D2': [], 'D3': []}}	for newTeam in TeamSeason.select(TeamSeason.team, TeamSeason.conference, TeamSeason.division,									 TeamSeason.gender).distinct(TeamSeason.team):		if newTeam.conference not in confs[newTeam.division][newTeam.gender]:			confs[newTeam.division][newTeam.gender][newTeam.conference] = set()		confs[newTeam.division][newTeam.gender][newTeam.conference].add(newTeam.team)		allTeams[newTeam.gender][newTeam.division].append(newTeam.team)		for division in ['D1', 'D2', 'D3']:			allTeams['Men'][division].sort()			allTeams['Women'][division].sort()	return confs, allTeamsdef nextYear(year):	if year=='Freshman':		return 'Sophomore'	if year=='Sophomore':		return 'Junior'	if year=='Junior':		return 'Senior'	return Nonedef grad(f, x, y, h=0.0025):	dx = (f(x, y) - f(x+h, y))/h	dy = (f(x, y) - f(x, y+h))/h	return dx, dydef gradientDescent(f, x0, y0, step=.001):	for i in range(10):		dx, dy = grad(f, x0, y0)		length = ((dx**2 + dy**2) ** .5)		print 'delta:', dx, dy		x0 += step * dx / length		y0 += step * dy / length		if x0 < 0:			x0 = 0.001		if y0 < 0:			y0 = 0.001		#print x0, y0	return x0, y0def fun(x, y):	return (x-3)**2 + (y-2)**2 + 1def frange(x, y, jump):	while x < y:		yield x		x += jumpdef date2week(d):	if d > date.today():		d = date.today()	if d.month > 6:		season = d.year + 1	else:		season = d.year	startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017	weeksIn = int((date - startDate).days / 7)	return weeksIndef week2date(week, season=None):	if not season:		season = thisSeason()	startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017	if week == None:		return date.today()	simDate = startDate + timedelta(weeks=week)	if simDate > date.today():  # can't simulate with future data		simDate = date.today()	return simDate'''this class contains a swim meetscores itself'''class Meet:	def __init__(self, name=None, events=list(allEvents), gender=None, topSwim=True, teams=None, season=None):		self.gender = gender  # None means both		self.teams = []  # teams added as swims are		self.scores = None		self.eventSwims = {}		if type(allEvents) != list:			events = list(events)		self.events = events		self.name = name  # named meets are ones that actually happened		self.date = None		self.season = None		self.winMatrix = None		if isinstance(teams, basestring):			teams = [teams]		if not gender:			genders = ['Men', 'Women']		else:			genders = [gender]		if self.name:			query = Swim.select().where(Swim.meet==name, Swim.gender << genders, Swim.event << events)			if teams:				query = query.select().where(Swim.team << teams)			if season:				query = query.select().where(Swim.season==season)			if topSwim:				query = query.select(Swim.name, Swim.event, Swim.team, Swim.gender, fn.Min(Swim.time),					Swim.year).group_by(Swim.name, Swim.event, Swim.team, Swim.gender, Swim.year)			for swim in query:				if topSwim:					swim.time = swim.min					swim.meet = name				self.addSwim(swim)	def reset(self, teams=False, times=False):		for swim in self.getSwims():			if teams:				swim.scoreTeam = None			if times:				swim.scoreTime = None	#sees if any swims are in the meet	def isEmpty(self):		for event in self.eventSwims:			if not self.eventSwims[event]==[]:				return False		return True	def isDual(self):		return len(self.teams) == 2	def getSwims(self, team='all', relays=True, splits=False, ind=True):		swims=set()		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if ind and (swim.team == str(team) or team=='all') and (relays or not swim.relay):					swims.add(swim)				if splits and swim.relay and (team=='all' or swim.team == str(team)):					for split in swim.swims:						swims.add(split)		return swims	def addSwim(self, swim):		if not swim.getScoreTeam() in self.teams:			self.teams.append(swim.getScoreTeam())		if self.name and not self.date or not self.season:  # without a name, its a dummy meet			self.date=swim.date			self.season=swim.season		if not swim.event in self.eventSwims:			self.eventSwims[swim.event] = []		self.eventSwims[swim.event].append(swim)	def addSwims(self, swims):		for swim in swims:			self.addSwim(swim)	def removeSwimmer(self, name):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.name==name:					self.eventSwims[event].remove(swim)	def nextYear(self, database):		for event in self.eventSwims:			if 'Relay' in event:				continue			self.eventSwims[event] = [x.improve(database) for x in self.eventSwims[event] if x.year != 'Senior']	def getEvents(self, events=''):		myEvents = set(self.eventSwims.keys())		if events=='':			if self.events == None:				events = allEvents			else:				events = self.events		events = set(events) & set(myEvents)		return events	def eventVariance(self):		timeVar={}		self.place()		for event in self.eventSwims:			average=0			count=0			for i in range(len(self.eventSwims[event])-1):				timeDif=abs(self.eventSwims[event][i].time-self.eventSwims[event][i+1].time) #time dif between this and next place				average=(average*count+timeDif)/(count+1) #running average				count+=1			timeVar[event]=average		return timeVar	'''	decides top events for each swimmer	top swimmers are decided by highest scoring event right now	'''	def topEvents(self, teamMax=17, indMax=3, totalMax=4, adjEvents=False, debug=False):		self.place()		conference = Meet()		indSwims = {}		relaySwims = {}		teamSwimmers = {}		teamDivers = {}		drops = []		relayEvents = set()		events = self.eventSwims.keys()		for team in self.teams:			teamSwimmers[team] = 0			teamDivers[team] = 0		for event in self.eventSwims:  # we will keep relays as is, but count them towards total swims			if re.search('Relay', event):				relayEvents.add(event)				while not self.eventSwims[event] == []:  # move relays over to new meet					relay = self.eventSwims[event].pop()					conference.addSwim(relay)		for event in relayEvents:			events.remove(event)		#pare down		self.place()		for event in self.eventSwims:			if len(self.eventSwims[event]) > 100:				self.eventSwims[event] = self.eventSwims[event][:99]  # start with top 100 times		#now make sure that each person swims their top events		preEvent = None		nextEvent = None		if debug: print self		while not self.isEmpty():			for event in events:				#print event				drop = True  # just allow us to enter the loop				while drop and not self.eventSwims[event] == []:  # we need to loop on an event until we find				#someone who is actually in it					drop = False					#print self.eventSwims[event]					if self.events and type(self.events) == type([]) and event in self.events:						if not self.events.index(event) == 0:							preEvent = self.events[self.events.index(event)-1]						if not self.events.index(event)==len(self.events)-1:							nextEvent = self.events[self.events.index(event)+1]					newSwim = self.eventSwims[event].pop(0)					if preEvent in conference.eventSwims and not adjEvents:  # check to make sure no adjacent events						for swim in conference.eventSwims[preEvent]:							if newSwim.name == swim.name and newSwim.getScoreTeam() == swim.getScoreTeam():								drops.append(newSwim)								drop = True								if debug: print 'pre', swim.name, swim.event								if debug: print 'pre', newSwim.name, newSwim.event								break					if nextEvent in conference.eventSwims and not adjEvents:						for swim in conference.eventSwims[nextEvent]:							if newSwim.name == swim.name and newSwim.getScoreTeam() == swim.getScoreTeam():								drop = True								drops.append(newSwim)								if debug: print 'post', swim.name, swim.event								if debug: print 'post', newSwim.name, newSwim.event								break					if drop:  # already swimming previous or next event						continue					if not newSwim.name+newSwim.getScoreTeam() in indSwims:   # team max events						if teamSwimmers[newSwim.getScoreTeam()] < teamMax:							indSwims[newSwim.name + newSwim.getScoreTeam()] = 0  # count same person on two teams							# differently							teamSwimmers[newSwim.getScoreTeam()] += 1						else:							if debug: print 'team', swim.name, swim.event							if debug: print 'team', newSwim.name, newSwim.event							drops.append(newSwim)							continue # fixed to still add swim when all 18					if indSwims[newSwim.name + newSwim.getScoreTeam()] < indMax:  # individual max events						conference.addSwim(newSwim)						indSwims[newSwim.name + newSwim.getScoreTeam()] += 1					else:						if debug: print 'ind', swim.name, swim.event						if debug: print 'ind', newSwim.name, newSwim.event						drops.append(newSwim)						drop = True  # can't swim any more events		self.score()		if debug:			print teamSwimmers, indSwims, teamMax, indMax			for swim in drops:				print swim.name, swim.event, swim.getScoreTeam(), swim.time		self.eventSwims = conference.eventSwims		return drops	'''	adds top relays using same method in database	'''	def addTopRelays(self, number, team, database):		relays = [event for event in self.events if re.search('Relay',event)]		return database.topRelays(relays, team, self)	'''	creates the best lineup for the given team against another set lineup	no two person swapping instabilities	->must implement relay creation and switching	'''	def lineup(self, team, debug=False, splits=False, division=False, ppts=False):		team=str(team)		drops = self.topEvents(30, 3, 4)		self.place()		'''		now we have a starting point		'''		extras = {}  # double dictionary,swim:event		for swim in drops:  # + dropSplits			if not swim.name in extras:				extras[swim.name] = {}			extras[swim.name][swim.event]=swim		if debug: self.printout()		toCheck = self.getSwims(team, False, splits=splits)		while len(toCheck) > 0:  # double loop on all swims, trying to see if more points are scored if swapped			swim1=toCheck.pop()			swims=self.getSwims(team, False, splits=splits)			while len(swims) > 0:				swim2=swims.pop()				if swim1==swim2 or swim1.event==swim2.event:					continue				# make sure swims exist				if extras.has_key(swim2.name) and extras.has_key(swim1.name) and extras[swim1.name].has_key(swim2.event) and extras[swim2.name].has_key(swim1.event):					self.score()					if debug:						print self.score()						print team					if not ppts:  # normal scoring						oldScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]						(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)						self.score()						newScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]					else:  # optimize powerpoints						oldScore = self.expectedScores()						(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)						self.score()						newScore = self.expectedScores()					if oldScore < newScore:  # swap in new swims						if debug:							print "swap"							print newSwim1.name, newSwim1.event							print newSwim2.name, newSwim2.event						swims.add(newSwim1)						swims.add(newSwim2)						if swim1 in swims:							swims.remove(swim1)						if swim2 in swims:							swims.remove(swim2)						for swim in (newSwim1, newSwim2):							if swim.split:  # re-add swims in those events								for relay in self.eventSwims[newSwim1.fromRelay]:									if relay.team==team:										for split in relay.swims:											if not split in toCheck:												toCheck.add(split)							else:								for swim in self.eventSwims[newSwim1.event]:									if not swim in toCheck and swim.team==team:										toCheck.add(swim)						if swim2 in toCheck:  # make sure second swim is not checked again							toCheck.remove(swim2)						swim1 = toCheck.pop()  # start checking next swim					else:  # revert to old lineup						self.swap(newSwim1, newSwim2, extras)		self.score()	'''	given two old swims	will swap two swims, returns two new swims	'''	def swap(self, swim1, swim2, extras):		newSwim1=extras[swim1.name][swim2.event]		newSwim2=extras[swim2.name][swim1.event]		if self.eventSwims.has_key(swim2.event) and swim2 in self.eventSwims[swim2.event]: # ind swim			self.eventSwims[swim2.event].remove(swim2)			self.addSwim(newSwim1)		else: #gotta be a relay			self.relaySwap(swim2,newSwim1)		if self.eventSwims.has_key(swim1.event) and swim1 in self.eventSwims[swim1.event]: # ind swim			self.eventSwims[swim1.event].remove(swim1)			self.addSwim(newSwim2)		else: #gotta be a relay			self.relaySwap(swim1,newSwim2)		if not extras.has_key(swim1.name):			extras[swim1.name]={}		extras[swim1.name][swim1.event]=swim1		if not extras.has_key(swim2.name):			extras[swim2.name]={}		extras[swim2.name][swim2.event]=swim2		return (newSwim1,newSwim2)	'''	swaps someone into a relay	given old (swim1) and new (swim2) split	'''	def relaySwap(self, swim1, swim2):		for relay in self.eventSwims[swim1.fromRelay]:			if swim1 in relay.swims:				relay.changeSwimmer(swim1,swim2)				return	def taper(self, weeks=12):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				swim.taper(weeks=weeks)	def expectedScores(self, division='D3', swimmers=6, debug=False, nsigma=-1):		self.place()		scores = {}		teamSwims = {}		for event in self.eventSwims:			teamSwims[event] = {}			for swim in self.eventSwims[event]:				if not swim.team in scores:					scores[swim.team] = 0				if not swim.team in teamSwims[event]:					teamSwims[event][swim.team] = 0				else:					teamSwims[event][swim.team] += 1				losses = teamSwims[event][swim.team]				points = swimDatabase.expectedPoints(time=swim.time, event=event, gender=swim.gender,									division=division, numSwimmers=swimmers, losses=losses, numsigma=nsigma)				swim.score = points				if points:					scores[swim.team] += points				if debug: print swim.event, swim.time, points, int(round(scores[swim.team])), losses		for team in scores:			scores[team] = int(round(scores[team]))		return scores	def place(self, events='', storePlace=False):		events=self.getEvents(events)		for event in events:			if not event in self.eventSwims or len(self.eventSwims[event]) == 0:				continue			self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=False)			if storePlace:				for idx, swim in enumerate(self.eventSwims[event]):					swim.place = idx+1	def score(self, dual=None, events='', heatSize=8, heats=2):		events = self.getEvents(events)		self.place(events)		self.assignPoints(heats=heats, heatSize=heatSize, dual=dual, events=events)		return self.teamScores(events)	'''	assigns points to the swims	'''	def assignPoints(self, heats=2, heatSize=8, dual=None, events=allEvents):		if dual is None:			if len(self.teams)==2:				dual=True			else:				dual=False		max = 16		if heats == 3:			pointsI = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif heats == 2:			pointsI = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		if heatSize == 6:			pointsI = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		pointsR = [x*2 for x in pointsI]		if dual:			max = 3			pointsI = [9, 4, 3, 2, 1]			pointsR = [11, 4, 2]		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0			else:				place = 1				teamSwims = {}				for swim in self.eventSwims[event]:					swim.score = None  # reset score					if not 'Relay' in swim.event:  # should use real relay var						team = swim.getScoreTeam()						if place > len(pointsI) or (team in teamSwims) and teamSwims[team] >= max:							swim.score = 0						else:							swim.score = pointsI[place-1]							if not team in teamSwims:								teamSwims[team] = 0							teamSwims[team] += 1							place += 1					else:						team = swim.getScoreTeam()						if place > len(pointsR) or (team in teamSwims) and teamSwims[team] >= max:							swim.score = 0						else:							swim.score = pointsR[place-1]							if not team in teamSwims:								teamSwims[team] = 0							teamSwims[team] += 1							place += 1	def scoreMonteCarlo(self, dual=None, events='', heatSize=8, heats=2, sigma=.02, runs=500, teamSigma=.02,						weeksOut=4):		# default the sigma if we just know the date		if weeksOut == -1:			sigma = 0.045			teamSigma = .02		elif weeksOut <= 4:			teamSigma = .01			sigma = 0.025		elif weeksOut <= 8:			teamSigma = .015			sigma = 0.035		elif weeksOut <= 12:			teamSigma = 0.015			sigma = 0.0425		elif weeksOut <= 16:			teamSigma = 0.025			sigma = 0.045		elif weeksOut > 16:			teamSigma = .0325			sigma = 0.0375		events = self.getEvents(events)		#print teamSigma, sigma, weeksOut		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0		teamScoresDist = []		for iternation in range(runs):  # run runs # of times			teamTapers = {}  # team noise			for team in self.teams:				teamTapers[team] = np.random.normal(0, teamSigma)			for event in self.eventSwims:  # individual swim noise				for swim in self.eventSwims[event]:					if swim.time:						noise = np.random.normal(0, sigma) * swim.getTaperTime()						teamNoise = teamTapers[swim.team] * swim.getTaperTime()						swim.scoreTime = swim.getTaperTime() + noise + teamNoise			#place again			self.place(events)			#now score			self.assignPoints(dual=dual, heats=heats, heatSize=heatSize, events=events)			teamScoresDist.append(self.teamScores(events))		self.reset(times=True)  # reset the times to normal		places = {}  # stores the number of times each team was 1st, 2nd, ect.		for score in teamScoresDist:			for idx, (team, score) in enumerate(score):				if not team in places:					places[team] = []				places[team].append(idx)		#print places		probMatrix = {}		for team in places:			probMatrix[team] = [0 for _ in range(len(places))]			for place in places[team]:				probMatrix[team][place] += 1.0/len(places[team])  # add in each individual result		winMatrix = {}		for team in probMatrix:			winMatrix[team] = probMatrix[team][0]		self.winMatrix = winMatrix		return probMatrix	def getTeamWinProb(self, team):		if not self.winMatrix:			self.scoreMonteCarlo(dual=False)		if not team in self.winMatrix:			return None		return self.winMatrix[team]	def getWinProb(self):		if not self.winMatrix:			self.scoreMonteCarlo(dual=False)		return self.winMatrix	def teamScores(self, events='', sorted=True):		events = self.getEvents(events)		teams = {}		for team in self.teams:  # make sure all the teams get some score			teams[team] = 0		for event in events:			if not event in self.eventSwims: continue			for swim in self.eventSwims[event]:				team = swim.getScoreTeam()				if not team in teams:					teams[team] = 0				teams[team] += swim.getScore()		self.scores = teams		if not sorted:			return teams		#now sort		scores = []		for team in teams:			scores.append([team, teams[team]])		scores.sort(key=lambda team: team[1], reverse=True)		return scores	def getTeamScore(self, team):		if not self.scores:			self.teamScores()		if not team in self.scores:			return None		return self.scores[team]	def getScores(self):		if not self.scores:			return self.teamScores()		return self.scores	def winningTeam(self):		if not self.scores: self.teamScores()		if len(self.scores)<1 or len(self.scores[0])<1: return None		return self.scores[0][0]	'''	lists swimmers by team and by points scored	'''	def scoreReport(self, repressSwim=False, repressTeam=False):		scores={}		for team in self.teams:			scores[team]={'total': 0, 'year': {}, 'swimmer': {}, 'event': {}}		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.relay:					name = 'Relays'				else:					name = swim.name				if repressSwim and swim.score == 0:					continue   # repess zero scores				team = swim.getScoreTeam()				if not name in scores[team]['swimmer']:					scores[team]['swimmer'][name] = 0				if not event in scores[team]['event']:					scores[team]['event'][event]=0				scores[team]['swimmer'][name] += swim.score				scores[team]['total'] += swim.score				scores[team]['event'][event] += swim.score				if swim.year:					if not swim.year in scores[team]['year']:						scores[team]['year'][swim.year] = 0					scores[team]['year'][swim.year] += swim.score		if repressTeam:			zeroTeams=set()			for team in scores:				if scores[team]['total'] == 0:					zeroTeams.add(team)			for team in zeroTeams:				del(scores[team])		return scores	def printout(self, events=''):		events=self.getEvents(events)		for event in events:			if event not in self.eventSwims: continue			print "-------------------------------------------------------------------------------------"			print "Event: " + event			for swim in self.eventSwims[event]:				if swim.score:					print swim.printScore().lstrip()+"\t"+str(swim.score)				else:					print swim.printScore().lstrip()		print self.scores	def scoreString(self, showNum='all', showScores=True, showPlace=False):		self.score()		string = {}		events = self.getEvents('')		for event in events:			if event not in self.eventSwims: continue			string[event] = []			# determine last scoring place			if showNum != 'all':				lastScoring = showNum				place = 0				for swim in self.eventSwims[event]:					place += 1					if swim.getScore() != 0 and place > lastScoring:						lastScoring = place			place = 0			for swim in self.eventSwims[event]:				place += 1				if showNum != 'all':					if place > lastScoring:						break				swimAry = re.split('\t', swim.printScore(gender=False).strip())				if showPlace:					swimAry.insert(0, place)				if swim.score and showScores:					swimAry.append(str(swim.score))					string[event].append(swimAry)				else:					string[event].append(swimAry)		string["scores"]=self.teamScores()		return string	def __str__(self):		if self.name:			return self.name		self.printout()		return ''	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name and self.date==s.date	def __hash__(self):		return hash(self.name)^hash(self.date)'''conference level information'''class conference:	def __init__(self, name, gender, season, division):		self.conference = name		self.gender = gender		self.season = season		self.teams = set()		self.division = division		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.season==season,									TeamSeason.conference==name):			self.teams.add(team)	def meet(self, topTimes=True, date=None, update=False, taper=False, weeksIn=10, nextYear=False):		events = eventsChamp3		swimmerLimit = 17		weeksOut = 16 - weeksIn		base = SwimDatabase('')		conference = base.topTimes(events=events, teams=list(self.teams), season=self.season, gender=self.gender,								   topTimes=topTimes, divisions=self.division, date=date)		season = self.season		if nextYear:			conference.nextYear(self)			season += 1  # update the correct season			weeksOut = '-1'			weeksIn = '-1'		if taper: conference.taper()		conference.topEvents(swimmerLimit)		conference.score()		# update stored win probabilities		if update:			conference.scoreMonteCarlo(weeksOut=weeksOut)			teamProb = conference.getWinProb()			for team in teamProb:				teamSeason = TeamSeason.get(team=team, division=self.division, gender=self.gender, season=season)				try:					stats = TeamStats.get(teamseasonid=teamSeason.id, week=weeksIn)					stats.winconf = teamProb[team]					print team, season, stats.winconf, weeksIn, date, teamSeason.id, stats.id					print stats.save()				except TeamStats.DoesNotExist:					print 'AB:', team, season, teamProb[team], weeksIn, date					print TeamStats.create(teamseasonid=teamSeason.id, week=weeksIn, winconf=teamProb[team], date=date)	def getStats(self):		teamStats = {}		for team in self.teams:			teamStats[team.name] = {}			teamStats[team.name]['winNats'] = team.getWinnats()			teamStats[team.name]['winConf'] = team.getWinconf()			# team development			# print team, session.gender, session.division			try:				stats = Team.get(Team.name==team.name, Team.gender==self.gender, Team.division==self.division)				teamStats[team.name]['strinv'] = stats.strengthinvite				teamStats[team.name]['attrition'] = stats.attrition				teamStats[team.name]['imp'] = stats.improvement			except Team.DoesNotExist:				teamStats[team.name]['strinv'] = None				teamStats[team.name]['attrition'] = None				teamStats[team.name]['imp'] = None			(medtaper, stdtaper) = team.getTaperStats()			teamStats[team.name]['medtaper'] = medtaper			teamStats[team.name]['stdtaper'] = stdtaper	def getTopSwimmers(self, num=10):		swimmers = []		for team in self.teams:			for swimmer in Swimmer.select().where(Swimmer.teamid==team.id):				if 'Relay' in swimmer.name: continue				heapq.heappush(swimmers, (swimmer.getPPTs(), swimmer))		return heapq.nlargest(num, swimmers)'''full database methods'''class SwimDatabase:	def __init__(self, database):		global swimDatabase		swimDatabase = self		db_proxy.initialize(database)		self.database = database		self.dist = {}		self.results = {}  # cache dual results		self.teams = {}		self.meetCache = {}		self.eventImpCache = {}		self.topScoreCache = {}		self.conferences, self.allTeams = getConfs()	def topDual(self, season=thisSeason(), events=requiredEvents, debug=False, teams='all', gender='Men'):		if teams == 'all':			teams = self.teams		meets = {}		wins = {}		losses = {}		for team in teams:			if not team in self.teams:				self.teams[team] = Team(team, self)			if not self.teams[team].topDual(season, debug=debug, gender=gender):				continue			meets[team] = self.teams[team].topDual(season, debug=debug, gender=gender)  # its cached			wins[team] = 0			losses[team] = 0			#if debug: print team, '\t\t', meets[team]		if debug: print '-----------'		for team1 in meets:			for team2 in meets:				if team1 == team2:					continue				if not team1 in self.results:					self.results[team1] = {}				if not team2 in self.results:					self.results[team2] = {}				if team2 in self.results[team1] or team1 in self.results[team2]:  # reverse meet already swum					continue				newMeet = self.swimMeet([[team1, meets[team1]], [team2, meets[team2]]], includeEvents=events,									  selectEvents=False)  # should convert to dual form				self.results[team1][team2] = newMeet.winningTeam()				self.results[team2][team1] = newMeet.winningTeam()				if debug: print team1, team2, newMeet.winningTeam()				if self.results[team1][team2] == team1: # team1 wins					wins[team1] += 1					losses[team2] += 1				elif self.results[team1][team2] == team2:  # team2 wins, otherwise no points					wins[team2] += 1					losses[team1] += 1		if debug:			for (index, team) in enumerate(sorted(wins.items(), key=operator.itemgetter(1), reverse=True)):				print str(index)+'.',team[0]+':',team[1],'-',losses[team[0]]		return meets, wins, losses	'''	creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	'''	def swimMeet(self, teamMeets, gender=None, debug=False, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False):		if debug: print teamMeets		meet = Meet()		teams = []		if includeEvents == 'all':			includeEvents = allEvents		commonEvents = allEvents		for teamMeet in teamMeets:			newTeamName = None			newTeam = teamMeet[0]			newMeet = teamMeet[1]			if len(teamMeet) >= 3 and teamMeet[2]:  # maybe pass in new team name				newTeamName = teamMeet[2]			if len(teamMeet) == 4:				season = teamMeet[3]			else:				season = None			if isinstance(newMeet, basestring):  # just a name				newMeet = Meet(name=newMeet, gender=gender, teams=[newTeam], season=season)			commonEvents = commonEvents & set(newMeet.eventSwims.keys())			if debug:				print set(newMeet.eventSwims.keys())				newMeet.printout()			duplicates = None			if not newTeamName:				duplicates = teams.count(newTeam)				teams.append(newTeam)			else:				teams.append(newTeamName)			for swim in newMeet.getSwims(newTeam):				if duplicates:					swim.scoreTeam = swim.getScoreTeam() + ' ' + str(duplicates + 1)				if newTeamName:					swim.scoreTeam = newTeamName				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		if len(meet.teams) == 2:			if selectEvents:				meet.topEvents(25, 3, 4)				'''need to fix event selection for dual meets'''			meet.events = (commonEvents | includeEvents) - excludeEvents			meet.score(dual=True)		else:			if selectEvents:				meet.topEvents()			meet.score()		if debug: meet.printout()		return meet	'''	optimal lineup creator	'''	def lineup(self, teamsSeasons, meet, debug=False, resetTimes=False, events=eventsDualS, gender='Men'):		meet.events = events		teams = []		print teamsSeasons		if debug:			print meet.getEvents(), events		for team in teamsSeasons:			teams.append(team)			if not teamsSeasons[team]:				season = thisSeason()			else:				season = teamsSeasons[team]			# handle duplicate teams			newMeet = self.topTimes(events=events, teams=[team], season=season, gender=gender, topTimes=True).getSwims()			duplicates = teams.count(team) - 1			if debug: print team, season, teams, duplicates			for swim in newMeet:				if duplicates > 0:					swim.scoreTeam = swim.getScoreTeam() + ' ' + str(duplicates + 1)					# print swim.getScoreTeam() + ' ' + str(duplicates + 1)				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		meet.place()		teams = teamsSeasons.keys()		if debug:			meet.printout()		# lineup optimize if creating linup for just one team		if len(teams) == 1:			meet.lineup(teams.pop(), debug=debug)		else:			meet.topEvents(17, indMax=3, totalMax=4)		return meet	'''	top expected score for the whole team	'''	def topTeamScore(self, team, dual=True, season=thisSeason(), gender='Men', division='D3', nsigma=-2, weeksIn=None):		# conver the week to a date		startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017		endDate = date(season, 2, 15)  # and Feb 15 as an end date, 16 week season		if weeksIn == None:  # can't simulate with future data			simDate = date.today()			weeksIn = int((simDate - startDate).days / 7)		else:			simDate = startDate + timedelta(weeks=weeksIn)		if simDate > date.today():  # can't simulate with future data			simDate = date.today()			weeksIn = int((simDate - startDate).days / 7)		# cache off times?		if dual:			events = eventsDualS		else:			events = eventsChamp		topMeet = self.topTimes(teams=[team], season=season, gender=gender, events=events, divisions=[division],								date=simDate)		topMeet.topEvents(teamMax=17, indMax=3)		if dual:			scores = topMeet.expectedScores(swimmers=6, division=division, nsigma=nsigma)		else:			scores = topMeet.expectedScores(swimmers=16, division=division, nsigma=nsigma)		if team in scores:			return scores[team]		return 0	'''	returns meet of top times	'''	def topTimes(self, events=None, teams=MIAC, season=None, gender='Men', topTimes=True, meetForm=True,				divisions='all', date=None):		if not events:			events = allEvents		if teams == 'all':			teams = self.teams		if divisions == 'all':			divisions = ['D1', 'D2', 'D3']		if not season:			season = thisSeason()  # use current season		topMeet = Meet(events=events)		swimmers = {}		select = Swim.select(Swim, Swimmer, TeamSeason).join(Swimmer).join(TeamSeason)\				.where(TeamSeason.gender==gender, TeamSeason.team << list(teams), TeamSeason.division << list(divisions),			   	TeamSeason.season==season, Swim.event << list(events))		if topTimes:			if date:				qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swimmer.team, Swimmer.year).group_by(					Swim.name, Swim.event, Swimmer.team, Swimmer.year).where(Swim.date < date)			else:				qwery = select.select(Swim.name, Swim.event, fn.Min(Swim.time), Swimmer.team, Swimmer.year).group_by(Swim.name,					Swim.event, Swimmer.team, Swimmer.year)		else:  # mean time for the season			qwery = select.select(Swim.name, Swim.event, fn.Avg(Swim.time), Swimmer.team, Swimmer.year).group_by(Swim.name,				Swim.event, Swimmer.team, Swimmer.year)		for swim in qwery:			if topTimes:				time = swim.min			else:				time = swim.avg			newSwim = Swim(name=swim.name, event=swim.event, time=time, gender=gender, team=swim.swimmer.team,									  season=season, year=swim.swimmer.year, swimmer=swim.swimmer)			if meetForm:				topMeet.addSwim(newSwim)			else:				if not swim.team in swimmers:					swimmers[swim.team] = {}				if not swim.name in swimmers[swim.team]:						swimmers[swim.team][swim.name] = {}				swimmers[swim.team][swim.name][swim.event] = newSwim		if meetForm:			topMeet.place()			return topMeet		return swimmers	def conference(self, teams=MIAC, season=None, topTimes=True, gender='Men', divisions='D3', date=None,				   update=False, taper=False, weeksIn=10, nextYear=False, nats=False):		events = eventsChamp3		if not season:			season = thisSeason()  # use current season		conference = self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=topTimes,								   divisions=[divisions], date=date)		if nextYear:			conference.nextYear(self)			season += 1  # update the correct season		if taper:			conference.taper()		swimmerLimit = 17		conference.topEvents(swimmerLimit)		conference.score()		# update stored win probabilities		weeksOut = 16 - weeksIn		if nextYear:			weeksOut = '-1'			weeksIn = '-1'		if update:			conference.scoreMonteCarlo(weeksOut=weeksOut)			teamProb = conference.getWinProb()			for team in teamProb:				teamSeason = TeamSeason.get(team=team, division=divisions, gender=gender, season=season)				try:					stats = TeamStats.get(teamseasonid=teamSeason.id, week=weeksIn)					if nats:						stats.winnats = teamProb[team]					else:						stats.winconf = teamProb[team]					print 'Existing:', team, season, stats.winconf, weeksIn, date, teamSeason.id, stats.id					print stats.save()				except TeamStats.DoesNotExist:					print 'New:', team, season, teamProb[team], weeksIn, date					if nats:						TeamStats.create(teamseasonid=teamSeason.id, week=weeksIn, winnats=teamProb[team], date=date)					else:						TeamStats.create(teamseasonid=teamSeason.id, week=weeksIn, winconf=teamProb[team], date=date)		return conference	def nationals(self, season=None, topTimes=True, gender='Men', division='D3', simDate=None, update=False,				  nextYear=False, weeksIn=4):		teams = self.allTeams[gender][division]		print season		startDate = date(season - 1, 10, 15)  # use Oct 15 as the start date, prolly good for 2017		print startDate		if weeksIn:			simDate = week2date(weeksIn, season)		print simDate		meet = self.conference(teams=teams, season=season, topTimes=topTimes, gender=gender, divisions=division,							   date=simDate, nextYear=nextYear, nats=True, update=update, weeksIn=weeksIn)		meet.scoreMonteCarlo(dual=False, weeksOut=16-weeksIn)		# update db with win probs		print meet.getWinProb()		if update:			teamProb = meet.getWinProb()			for team in teamProb:				print team, teamProb[team]				TeamSeason.update(winnats=teamProb[team]).where(TeamSeason.team==team, TeamSeason.season==season+1,											TeamSeason.gender==gender, TeamSeason.division==division).execute()		return meet	'''	returns top 25 teams and caches ranking data	'''	def teamRank(self, division='D3', gender='Men', season=2016, num=25):		teamScores = {}		# populate if null for nats win probs		#if TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.division==division,		#							TeamSeason.season==season, TeamSeason.winnats >> None).count() > 0:		#	self.nationals(season=season, division=division, gender=gender, update=True)		# populate null values for team strength		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.division==division,								TeamSeason.season==season, TeamSeason.strengthdual >> None):			dual = self.topTeamScore(team.team, season=season, gender=gender, division=division, dual=True)			invite = self.topTeamScore(team.team, season=season, gender=gender, division=division, dual=False)			#print team.team, invite, team.strengthinvite			TeamSeason.update(strengthinvite=invite, strengthdual=dual).where(TeamSeason.id == team.id).execute()		for team in TeamSeason.select().where(TeamSeason.gender==gender, TeamSeason.season==season,				TeamSeason.division==division).order_by(TeamSeason.strengthinvite.desc()).limit(num):			teamScores[team.team] = team		return sorted(teamScores.values(), key=lambda t: t.strengthinvite, reverse=True)	# update the probabilities of winning conference	def updateConferenceProbs(self, division='D3', gender='Women', season=2017, weeksIn=None, forceUpdate=False):		simDate = week2date(weeksIn, season)		startDate = week2date(0, season)		print simDate		for team in TeamSeason.select().where(TeamSeason.division==division, TeamSeason.gender==gender,					TeamSeason.season==season):			try:				stats = TeamStats.get(teamseasonid=team.id, week=weeksIn)				if stats.winconf is not None and not forceUpdate:  # we already have data					continue				print stats.winconf, team.team				teams = self.conferences[division][gender][team.conference]				if weeksIn == -1:  # pre-season					self.conference(teams=teams, gender=gender, season=season-1, divisions=division, update=True,								nextYear=True, date=startDate)				self.conference(teams=teams, gender=gender, season=season, divisions=division, update=True,								weeksIn=weeksIn, date=simDate)			except TeamStats.DoesNotExist:				teams = self.conferences[division][gender][team.conference]				if weeksIn == -1:  # pre-season					self.conference(teams=teams, gender=gender, season=season-1, divisions=division, update=True,								nextYear=True, date=startDate)				self.conference(teams=teams, gender=gender, season=season, divisions=division, update=True,								weeksIn=weeksIn, date=simDate)	def updateTeamStrength(self, division='D3', gender='Women', season=2017, weeksIn=None, update=True):		simDate = week2date(weeksIn, season)		print simDate		for team in TeamSeason.select().where(TeamSeason.division==division, TeamSeason.gender==gender,					TeamSeason.season==season):			try:				stats = TeamStats.get(teamseasonid=team.id, week=weeksIn)				if stats.strengthinvite is None or update:					scoreInv = self.topTeamScore(team.team, dual=False, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)					stats.strengthinvite = scoreInv				if stats.strengthdual is None or update:					scoreDual = self.topTeamScore(team.team, dual=True, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)					stats.strengthdual = scoreDual				print team.team, scoreInv, scoreDual				stats.save()			except TeamStats.DoesNotExist:				scoreInv = self.topTeamScore(team.team, dual=False, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)				scoreDual = self.topTeamScore(team.team, dual=True, season=season, gender=gender, division=division,										 weeksIn=weeksIn, nsigma=0)				TeamStats.create(teamseasonid=team.id, week=weeksIn, strengthinvite=scoreInv, strengthdual=scoreDual,								 date=simDate)	def updateTeamStats(self, division='D3', gender='Women', week=6):		if week2date(week) == date.today():			return  # would be a future week		database.nationals(nextYear=False, gender=gender, division=division, season=2017, update=True, weeksIn=week)		database.updateConferenceProbs(division=division, gender=gender, season=2017, weeksIn=week)		database.updateTeamStrength(division=division, gender=gender, season=2017, weeksIn=week, update=True)	def improvement(self, gender='Men', teams=MIAC, events=allEvents, season1=thisSeason()-1, season2=thisSeason()-2,					season3=None, season4=None):		# get top times for the seasons		top1 = self.taperSwims(teams=teams, gender=gender, season=season1)		top2 = self.taperSwims(teams=teams, gender=gender, season=season2)		if season3:			top3 = self.topTimes(gender=gender, events=events, teams=teams, season=season3, meetForm=False)		if season4:			top4 = self.topTimes(gender=gender, events=events, teams=teams, season=season4, meetForm=False)		# finds improvement between two seasons		def calcImprovement(top1, top2):			allImprovement = {}			teamImprovement = {}			for team in top1:				if not team in top2:					continue				if not team in allImprovement:					allImprovement[team] = {}					teamImprovement[team] = []				for swimmer in top1[team]:					if not swimmer in top2[team]:						continue					if not swimmer in allImprovement:						allImprovement[team][swimmer] = {}					for event in top1[team][swimmer]:						if not event in top2[team][swimmer]:							continue						time1 = top1[team][swimmer][event].time						time2 = top2[team][swimmer][event].time						drop = (time2-time1) / ((time1+time2) / 2) * 100						print swimmer, event, time1, time2						if abs(drop) > 10:  # toss outliers							continue						allImprovement[team][swimmer][event] = drop						teamImprovement[team].append(drop)			return allImprovement, teamImprovement		allImprovement, teamImprovement = calcImprovement(top1, top2)		if season3:  # combine in optional season 3			allImprovement2, teamImprovement2 = calcImprovement(top2, top3)			combined = teamImprovement.copy()			for team in teamImprovement2:				if team in combined:					combined[team].extend(teamImprovement2[team])				else:					combined[team] = teamImprovement2[team]			teamImprovement = combined		if season4 and season3: # combine in optional season 4			allImprovement2, teamImprovement2 = calcImprovement(top3, top4)			combined = teamImprovement.copy()			for team in teamImprovement2:				if team in combined:					combined[team].extend(teamImprovement2[team])				else:					combined[team] = teamImprovement2[team]			teamImprovement = combined		return teamImprovement, allImprovement	def improvement2(self, gender='Men', teams=MIAC, season1=thisSeason()-1, season2=thisSeason()-2):		posSeasons = [2016, 2015, 2014, 2013, 2012, 2011]		#print season1, season2		if season1 > season2 and season1 in posSeasons and season2 in posSeasons:			seasons = range(season2, season1)			#print seasons		teamImprovement = {}		for swim in Improvement.select().where(Improvement.fromseason << seasons, Improvement.gender==gender,									   Improvement.team << list(teams)):			if swim.team not in teamImprovement:				teamImprovement[swim.team] = []			teamImprovement[swim.team].append(swim.improvement)		if len(teams)==1 and teams[0] in teamImprovement:			return teamImprovement[teams[0]]		return teamImprovement	def conferencePlace(self, division, gender, newSwims, year=2014):		newEvents = set()		for swim in newSwims:			newEvents.add(swim[0])		confMeets = {}		with open('./data/' + division + gender + '.csv') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet					confMeets[confName].addSwims(Meet(name=meetName, events=newEvents, gender=gender,													  topSwim=True).getSwims())				else:					confMeets[confName] = Meet(name=meetName, events=newEvents, gender=gender, topSwim=True,											   season=year)		confScores = {}		for conference in confMeets:			confMeet = confMeets[conference]			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScores	def expectedPoints(self, time, gender, division, event, numSwimmers=6, losses=0, numsigma=-1):		scoresR = None		if numSwimmers == 24:			scores = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif numSwimmers == 16:			scores = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif numSwimmers == 12:			scores = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		else:			if not 'Relay' in event:				if losses > 2:					return 0			else:				if losses < 1:					return 0			scores = [9, 4, 3, 2, 1]			scoresR = [11, 4, 2]		if 'Relay' in event:			if scoresR:				scores = scoresR			else:				scores = [x*2 for x in scores]		scores = scores[losses:]  # people who you know you will lose to		cdf = self.getTimeCDF(gender, division, event, numsigma=numsigma)		lose = 1 - cdf(time)		win = cdf(time)		num = numSwimmers - 1 - losses  # other swimmers		totalScore = 0		for place, score in enumerate(scores):			comb = binomial(num, place)			totalScore += score * comb * (lose**(num-place) * win**(place))		return totalScore	'''	used to find the the full distribution of times in a single event and a divsion, gender	'''	def getTimeCDF(self, gender, division, event, numsigma=-1):  # grabs to cdf for a particular segment of times		# creates a frozen truncated normal distribution		def makeCDF(mu, sigma, clip):  # returns a frozen truncated normal CDF				a = -100  # arbitrarily fast times				b = (clip - mu) / sigma				def defaultCDF(x):					return truncnorm.cdf(x, a, b, mu, sigma)				return defaultCDF		# first check db		try:			dist = Timedist.get(Timedist.gender==gender, Timedist.division==division, Timedist.event==event)			clipR = dist.mu + dist.sigma * numsigma			ecdf = makeCDF(dist.mu, dist.sigma, clipR)			return ecdf		except Timedist.DoesNotExist:			times = []  # 2016 is the only full season right now			for swim in Swim.select(Swim.time).where(Swim.division==division, Swim.gender==gender, Swim.event==event,													 Swim.season==2016):				if swim.time > 15:					times.append(swim.time)			if len(times) == 0:				return			times = rejectOutliers(times, l=5, r=5)			# best fit of data			(mu, sigma) = norm.fit(times)			'''top 10,1 percent'''			clipR = mu + sigma * numsigma  # slowest time to allow			fastTimes = [i for i in times if i< clipR]			#ecdfold = ECDF(fastTimes)			ecdf = makeCDF(mu, sigma, clipR)			newDist = Timedist(gender=gender, division=division, event=event, percent=numsigma, mu=mu, sigma=sigma)			newDist.save()		return ecdf	def getTimeMode(self, gender, division, event):		import matplotlib.pyplot as plt		#from scipy.stats import skewnorm		times = []		for swim in Swim.select(Swim.time).where(Swim.division==division, Swim.gender==gender, Swim.event==event,												 Swim.season==2016):			if swim.time > 15:				times.append(swim.time)		if len(times) == 0:			return		times = rejectOutliers(times, l=4, r=4)		(mu, sigma) = norm.fit(times)		topNums = (0, 0)		topCount = 0		#print mu, sigma		for i in range(50):			hi = mu - mu*(24.5-i)/250			lo = mu - mu*(25.5-i)/250			count = Swim.select(fn.COUNT(Swim.id)).where(Swim.division==division, Swim.gender==gender,							Swim.event==event, Swim.time<hi, Swim.time>lo, Swim.season==2016).scalar()			#print hi, lo, count			if count > topCount:				topCount = count				topNums = (lo, hi)		mode = (topNums[0] + topNums[1])/2		print event, mu, sigma, max(times)		fit = skewnorm.fit(times, max(times)-mu, loc=mu, scale=sigma)		print fit		# fit2 = (-mu, fit[1], fit[2], sigma		# mun, sigman = mode, sigma		# fit2 = (-mu, (max(times)-mun)/(sigman), mun, sigman)		# print fit2		r = skewnorm(*fit)		plt.hist(r.rvs(100000), bins=50, normed=True)		plt.hist(times, bins=50, normed=True, alpha=0.5)		plt.show()	def taperMeets(self, year=2015, gender='Women', division='D1'):  #find meets where most best times come from		teamMeets = {}		#teams=['Univ of Utah', 'Stanford', 'California', 'Arizona', 'Southern Cali', 'Arizona St']		teams = self.allTeams[gender][division]		for team in teams:			for swim in Swim.raw("WITH topTimes AS (SELECT name, event, meet, time, row_number() OVER (PARTITION BY event,name "					 "ORDER BY time) AS rnum "					 "FROM Swim "					 "WHERE team=%s AND season=%s AND date > '%s-02-01' AND gender=%s) "					 "SELECT name,event,meet,time FROM topTimes WHERE rnum=1",					 team, year, year, gender):				if not team in teamMeets:					teamMeets[team] = []				teamMeets[team].append(swim.meet)		#print teamMeets.keys()		taperMeets = {}		for team in teamMeets:			taperMeet = max(set(teamMeets[team]), key=teamMeets[team].count)			#print team, taperMeet			if taperMeet not in taperMeets:				taperMeets[taperMeet] = 0			taperMeets[taperMeet] += 1		bigTaperMeets = [i for i in taperMeets if taperMeets[i]>2]		return bigTaperMeets	def taperSwims(self, teams, gender, conference, season=None, numTimes=3):		if season == None:			season = thisSeason()		teamSwims = {}		for team in teams:			teamSwims[team] = {}			for swimmer in Swimmer.select(Swimmer, TeamSeason).join(TeamSeason).where(TeamSeason.team==team,					TeamSeason.gender==gender, TeamSeason.conference==conference, TeamSeason.season==season):					teamSwims[team][swimmer.name] = {}					times = []					#print team, gender					#print swimmer.name, swimmer.team					for swim in Swim.raw("WITH topTimes as "							"(SELECT name, gender, meet, event, time, year, division, swimmer_id, row_number() OVER "							"(PARTITION BY event, name ORDER BY time) as rnum "							"FROM Swim WHERE swimmer_id=%s) "							"SELECT name, event, meet, time, gender, division, year, swimmer_id FROM topTimes WHERE "										 "rnum=1",							swimmer.id):						if swim.event == '1000 Yard Freestyle': continue						cdf = self.getTimeCDF(gender, swim.division, swim.event, 100)						points = 1 - cdf(swim.time)						#print swim.time, swim.gender, swim.division, swim.event, points						heapq.heappush(times, (points, swim))					for (points, swim) in heapq.nlargest(numTimes, times):  #take three best times						#print team, swimmer.name, swim.event, points, swim.time						teamSwims[team][swimmer.name][swim.event] = swim		return teamSwims	def taperStats(self, division='D1', gender='Women', season=2016, weeks=10):		print weeks		drops = []		teamDrops = {}		startDate = date(season-1, 10, 15)  # use Oct 15 as a hard-coded start date		newDate = startDate + timedelta(weeks=weeks)		for conference in self.conferences[division][gender]:			for team in self.conferences[division][gender][conference]:				taperSwims = set()				#if not team in 'Carleton':				#	continue				topTimes = self.taperSwims(teams=[team], gender=gender, season=season, conference=conference)				for team in topTimes:					for swimmer in topTimes[team]:						for event in topTimes[team][swimmer]:							taperSwims.add(topTimes[team][swimmer][event])							#print event, swimmer				for taperSwim in taperSwims:					#print taperSwim.swimmer.season					for earlySwim in Swim.select(fn.min(Swim.time)).where(Swim.swimmer==taperSwim.swimmer,							Swim.event==taperSwim.event, Swim.date < newDate):						if earlySwim.min:							dropPer = 100 * (earlySwim.min - taperSwim.time)/taperSwim.time							drops.append(dropPer)							if team not in teamDrops:								teamDrops[team] = []							teamDrops[team].append(dropPer)							#print taperSwim.event, taperSwim.swimmer.name, earlySwim.min, taperSwim.time, dropPer		#print np.mean(drops), np.std(drops)		allStats = []		for team in teamDrops:			meanDrop = np.mean(teamDrops[team])			stdDrop = np.std(teamDrops[team])			#print team, round(meanDrop, 2), round(stdDrop, 2), len(teamDrops[team])			#print gender, division, team			try:				oldTeam = TeamSeason.get(TeamSeason.gender==gender, TeamSeason.division==division, TeamSeason.team==team,									 TeamSeason.season==season)				newStats = {'week': weeks, 'date': newDate, 'teamseasonid': oldTeam.id,						'toptaper': meanDrop, 'toptaperstd': stdDrop}				allStats.append(newStats)			except:				pass		print allStats		if len(allStats)==0:			return		# now insert into database		db_proxy.connect()		with db_proxy.transaction():			TeamStats.insert_many(allStats).execute()	def storeImprovement(self):		seasons = [2016, 2015]		swims = []		confs = getConfs()		for division in confs:			for gender in confs[division]:				for conference in confs[division][gender]:					for team in confs[division][gender][conference]:						for season in seasons:							top1 = self.taperSwims(teams=[team], gender=gender, season=season, conference=conference)							top2 = self.taperSwims(teams=[team], gender=gender, season=season-1, conference=conference)							if not team in top2 and team in top2:								continue							for swimmer in top1[team]:								if not swimmer in top2[team]:									continue								for event in top1[team][swimmer]:									if not event in top2[team][swimmer]:										continue									swim1 = top1[team][swimmer][event]									swim2 = top2[team][swimmer][event]									time1 = swim1.time									time2 = swim2.time									drop = (time2-time1) / ((time1+time2) / 2) * 100									#print swimmer, event, time1, time2									if abs(drop) > 10:  # toss outliers										continue									newSwim = {'fromseason': season-1, 'toseason': season, 'name': swim1.name,											   'fromyear': swim2.year, 'toyear': swim1.year,											   'team': team, 'gender': gender, 'event': event,											   'improvement': drop,  # positive=faster											   'fromtime': swim2.time, 'totime': swim1.time,											   'conference': conference, 'division': division}									#print newSwim									swims.append(newSwim)		print len(swims)		db_proxy.connect()		for i in range(len(swims) / 100):			print i			with db_proxy.transaction():				Improvement.insert_many(swims[i*100:(i+1)*100]).execute()	def attrition(self, teams=MIAC, seasons=[2016, 2015, 2014, 2013, 2012], gender='Men'):		teamDrops = {}		teamSwims = {}		for team in teams:			teamDrops[team] = 0			teamSwims[team] = 0			for season in seasons:				try:					# make sure there was a team both years					seasonID = TeamSeason.get(TeamSeason.team==team, TeamSeason.gender==gender,											  TeamSeason.season==season).id					seasonID2 = TeamSeason.get(TeamSeason.team==team, TeamSeason.gender==gender,											 TeamSeason.season==season+1).id					for swimmer in Swimmer.select(Swimmer.name, Swimmer.teamid, Swimmer.year).where(									Swimmer.year!='Senior', Swimmer.teamid==seasonID):						teamSwims[team] += 1  # total number of swimmers						try:							Swimmer.get(Swimmer.name==swimmer.name, Swimmer.season==season+1,										Swimmer.teamid==seasonID2)  # swam the next year						except Swimmer.DoesNotExist:							teamDrops[team] += 1				except TeamSeason.DoesNotExist:					pass		dropRate = {}		for team in teamDrops:			if teamSwims[team] > 0:				dropRate[team] = float(teamDrops[team]) / float(teamSwims[team])		if len(teams)==1 and teams[0] in dropRate:			return dropRate[teams[0]]		return dropRate	def meetPrediction(self, sigmat=.01, sigmai=.01, gender='Women', division='D3', week=4):		# evaluates the error on meet simulations		print sigmat, sigmai, week		# prediction categories, 10%, 20%...		lumpedPre = {}		lumps = range(0, 110, 10)		for i in lumps:			lumpedPre[str(i)] = []		for season in [2016]:#, 2015, 2014, 2013, 2012]:			# first find the taper meets and			meetNames = self.taperMeets(season, division=division)			#meetNames = ["2016 Women's NESCAC Championsh"]			meetTeams = {}			meetDates = {}			for meet in SMeet.select(SMeet, TeamMeet, TeamSeason).where(SMeet.meet<<meetNames, SMeet.gender==gender,								SMeet.season==season).join(TeamMeet).join(TeamSeason):				if meet.meet not in meetTeams:					meetTeams[meet.meet] = []					meetDates[meet.meet] = meet.date				meetTeams[meet.meet].append(meet.teammeet.team.team)			for meetName in meetTeams:				finalMeet = Meet(name=meetName, gender='Women', season=season)				#finalMeet = self.conference(teams=meetTeams[meetName], gender=gender, divisions=division,				# season=season)				finalMeet.score()				finalScores = finalMeet.teamScores()				finalPlaces = [i[0] for i in finalScores]				if week==-1:					newMeet = self.conference(teams=meetTeams[meetName], gender=gender, divisions=division,									season=season-1, nextYear=True)					probScores = newMeet.scoreMonteCarlo(sigma=sigmai, teamSigma=sigmat)				else:					newDate = meetDates[meetName] - timedelta(weeks=week)					newMeet = self.conference(teams=meetTeams[meetName], gender=gender, divisions=division, season=season,										  date=newDate)					newMeet.taper(weeks=16 - week)					probScores = newMeet.scoreMonteCarlo(sigma=sigmai, teamSigma=sigmat)					newMeet.reset(times=True)				# evaluate the predictions				for team in probScores:					for idx, prob in enumerate(probScores[team]):						rProb = str(int(round(prob, 1) * 100))						if prob >= 1:  # make sure 0 predictions don't blow up							prob = .99						if prob <= 0:							prob = .01						if finalPlaces[idx] == team:  # correct prediction, log-based score							score = log(prob)						else:  # wrong							score = log(1 - prob)						lumpedPre[rProb].append(score)		# now aggregate		totalError = 0		for percent in lumpedPre:			totalError += sum(lumpedPre[percent])		print 'Error:', totalError		return -totalError	'''	statistical methods	'''	def eventProjection(self, event, time, gender, year, threshold=.002, division=None):		if year not in {'Freshman', 'Sophomore', 'Junior'}: return		# first find similar times done same year		uBound = time + time * threshold		lBound = time - time * threshold		print time, division  #uBound, lBound		similarSwims = []		for swim in Swim.select().where(Swim.event==event, Swim.gender==gender, Swim.year==year, Swim.time>lBound,										Swim.time<uBound, Swim.division==division):			# check to see if thats a top time for that swimmer			topSwims = self.topSwims(swim.swimmer, n=10)			if swim in topSwims:				similarSwims.append(swim)				#print swim.event, swim.name, swim.time				if len(similarSwims) > 200: break		# now see how those swimmers did next season		def project(year):			times = []			for swim in similarSwims:				try:					nextSwimmer = Swimmer.get(Swimmer.name==swim.name, Swimmer.team==swim.team, Swimmer.year==year)					swims = self.topSwims(nextSwimmer.id, event=event, n=5)  # get best event time in top swims					for swim in swims:						times.append(swim.time)				except Swimmer.DoesNotExist:					pass			return times		times1 = project(nextYear(year))		times2 = project(nextYear(nextYear(year)))		times3 = project(nextYear(nextYear(nextYear(year))))		print len(times1), len(times2), len(times3)		print np.mean(times1), np.std(times1)		print np.mean(times2), np.std(times2)		print np.mean(times3), np.std(times3)	def eventProjection2(self, event, time, gender, year='Freshman', threshold=.005, division='D1'):		uLimit = time + time*threshold		lLimit = time - time*threshold		times = []		#print time, event, gender		for imp in Improvement.select().where(Improvement.event==event,				Improvement.gender==gender, Improvement.fromtime<uLimit, Improvement.fromtime>lLimit,							Improvement.division==division, Improvement.fromyear==year):			times.append(imp.totime-imp.fromtime)		#print times		if len(times) > 5:			return np.mean(times), np.std(times), len(times)			#n, bins, patches = plt.hist(times, 60, normed=1, alpha=0.75)			#plt.show()	# returns an improvement function	def getExtrapEvent(self, event, gender, year='Freshman', division='D1'):		sentinelString = event+gender+year+division		if sentinelString in self.eventImpCache:			return self.eventImpCache[sentinelString]		# get fastest, slowest times		timeStart, timeEnd = None, None		for swim in Swim.select(fn.Min(Swim.time), fn.Max(Swim.time)).where(Swim.event==event, Swim.gender==gender,								Swim.division==division, Swim.year==year):			timeStart, timeEnd = swim.min, swim.max		if not timeStart or not timeEnd:			return		if '1650' in event or '1000' in event:			interval = 2		elif '100' in event or '50' in event:			interval =.25		elif '200' in event:			interval =.5		elif '400' in event or '500' in event:			interval = 1		else:			interval = 1		timeCurve, x, y, w = [], [], [], []		for time in np.arange(timeStart, timeEnd, interval):			data = self.eventProjection2(event, time, gender)			if data:				mu, sigma, n = data				timeCurve.append((time, round(mu, 2), round(sigma,2)))				x.append(time)				y.append(mu)				w.append(1/sigma)		f = UnivariateSpline(x, y, w)		self.eventImpCache[sentinelString] = f		return f	def fitEvent(self, event, gender, division=None, plot=True):		timesX = []		timesY = []		dif = []		timesXW, timesYW, difW = [], [], []		if division:			improvementsMen = Improvement.select().where(Improvement.event==event, Improvement.gender=='Men',													  Improvement.division==division)			improvementsWomen = Improvement.select().where(Improvement.event==event, Improvement.gender=='Women',													  Improvement.division==division)		else:			improvementsMen = Improvement.select().where(Improvement.event==event, Improvement.gender=='Men')			improvementsWomen = Improvement.select().where(Improvement.event==event, Improvement.gender=='Women')		for time in improvementsMen:			timesX.append(time.fromtime)			timesY.append(time.totime)			dif.append((time.fromtime - time.totime) / ((time.fromtime + time.totime) / 2) * 100)		for time in improvementsWomen:			timesXW.append(time.fromtime)			timesYW.append(time.totime)			difW.append((time.fromtime - time.totime) / ((time.fromtime + time.totime) / 2) * 100)		if len(timesX)<10: return		print event		slope, intercept, r_value, p_value, std_err = linregress(timesX, timesY)		print slope, intercept, r_value, p_value, std_err, event		timesX, dif = rejectOutliers(timesX, dif, l=10, r=3)		timesXW, difW = rejectOutliers(timesXW, difW, l=10, r=3)		timeStart = min(timesX)		timeEnd = max(timesX)		timeStartW = min(timesXW)		timeEndW = max(timesXW)		print timeStart, timeEnd		newX = np.arange(timeStart, timeEnd, .25)		# 2nd degree fix on the time, absolute time dropped		fit, res, _, _, _= np.polyfit(timesX, dif, 1, full=True)		fitW, resW, _, _, _= np.polyfit(timesXW, difW, 1, full=True)		#print res, np.mean(dif), np.std(dif)		fit_fn = np.poly1d(fit)		fit_fnW = np.poly1d(fitW)		if plot:			figure = {  				"data": [					go.Scatter(						x=timesX,						y=dif,						mode='markers',						name='Men'					),					go.Scatter(						x=timesXW,						y=difW,						mode='markers',						name='Women'					),					go.Scatter(						x=[timeStart, timeEnd],						y=[fit_fn(timeStart), fit_fn(timeEnd)],						mode='line',						name='Men Fit'					),					go.Scatter(						x=[timeStartW, timeEndW],						y=[fit_fnW(timeStartW), fit_fnW(timeEndW)],						mode='line',						name='Women Fit'					)				],    			"layout": go.Layout(title=event)			}			py.iplot(figure, filename=event)	def eventCombos(self, topNum=20000):  # find most commonly swum event combinations, returns correlation matrix		# find rates of each combo, powerpoints for each combo and the correlation matrix		combos = {}		pptCombos = {}		corrMatrix = {}		n = 0		for swimmer in Swimmer.select(Swimmer.id).where(Swimmer.season==2016):			swims = self.topSwims(swimmer.id, season=2016, n=3, distinctEvents=True)  # get their top three swims in			# different events			if len(swims) < 3: continue			n+=1			if n >topNum:				break			events = []			for swim in swims:				events.append(swim.event)			#print events			events.sort()			eventStr = ''			for event in events:				eventStr+=' - ' + event			combos[eventStr] = combos.get(eventStr, 0) + 1			cdf = self.getTimeCDF(swim.gender, swim.division, swim.event, 100)			points = 1 - cdf(swim.time)			pptCombos[eventStr] = pptCombos.get(eventStr, 0) + points			for perm in permutations(events, 2):				if perm[0] not in corrMatrix:					corrMatrix[perm[0]] = {}				corrMatrix[perm[0]][perm[1]] = corrMatrix[perm[0]].get(perm[1], 0) + 1		comboMatrix = [['Event Combination', '% of All Combinations', 'Power Ranking']]		totalNum = sum(combos.values())		for combo, value in sorted(combos.items(), key=itemgetter(1)):			comboMatrix.append([combo[3:], round(value / float(totalNum), 2), round(pptCombos[combo] / float(value),2)])			print combo[3:], round(value / float(totalNum), 2), round(pptCombos[combo] / float(value), 2)		'''		eventHeader = ''		for event in corrMatrix:			eventHeader += event + '\t'		print eventHeader		for event in corrMatrix:			eventLine = event			for event2 in corrMatrix:  # some of these events might not be in inner matrix				if event2 in corrMatrix[event]:					eventLine += '\t' + str(corrMatrix[event][event2])				else:					eventLine += '\t' + '0'			print eventLine		'''		dataMatrix = []		for idx1, event1 in enumerate(corrMatrix):			dataMatrix.append([])			for idx2, event2 in enumerate(corrMatrix):				try:					total = sum(corrMatrix[event1].values())					# normalize					dataMatrix[idx1].append(float(corrMatrix[event1][event2])/total)				except KeyError:					dataMatrix[idx1].append(0)		figure = {  			"data": [				go.Heatmap(					z=dataMatrix,        			x=corrMatrix.keys(),        			y=corrMatrix.keys()				)			],    		"layout": go.Layout(title="Event Correlations", margin={'l': 175, 'b': 150})		}		py.plot(figure, filename="teamDropFitWomen.html")		return corrMatrix	def bestMeet(self, corrMatrix, topNum=10):		# first get all possible 3-day meet formats		events = list(eventsChampInd) #['100 Yard Freestyle', '200 Yard Freestyle', '100 Yard Butterfly']#		possMeets = []		# all possible ways to split events into three groups		flaglist = product([1, 2, 3], repeat=len(events))		for n, flags in enumerate(flaglist):  # now apply partitions to events			l1 = [events[i] for i, flag in enumerate(flags) if flag==1]			l2 = [events[i] for i, flag in enumerate(flags) if flag==2]			l3 = [events[i] for i, flag in enumerate(flags) if flag==3]			possMeets.append((l1, l2, l3))		# add correlations for events that are on the same day		meetScores = {}		lineupCombos = set()		for meet in possMeets:			doubled = 0			meetStrings = []			for day in meet:				str = ''				for event in sorted(day):					str += event				if not str == '':					meetStrings.append(str)				for combo in combinations(day, 2):					if combo[0] in corrMatrix and combo[1] in corrMatrix[combo[0]]:						doubled += corrMatrix[combo[0]][combo[1]]			meetString = ''			for day in sorted(meetStrings):				meetString += day + ' -  '			if meetString not in lineupCombos:				meetScores[meetString] = doubled				lineupCombos.add(meetString)		#return the top n		n=0		for lineup in sorted(meetScores.items(), key=operator.itemgetter(1)):			n+=1			if n >topNum: break			print lineup	def impStats(self, division='D1', gender='Women', season=2016):		teamStr = []		teamNames = []		teamImp = {}		teamImpOrdered = []		# top 25 teams		for stats in Team.select().where(Team.gender==gender, Team.division==division).order_by(				Team.strengthinvite.desc()).limit(25):			strength = self.topTeamScore(stats.name, dual=False, division=division, gender=gender, season=season)			teamNames.append(stats.name)			teamStr.append(strength)			teamImpOrdered.append(stats.improvement)		# get all the improvement data for each team		boxes = []		teamImpMeans = []		for team in teamNames:			teamImp[team] = []			for stats in Improvement.select().where(Improvement.team==team, Improvement.gender==gender):				teamImp[team].append(stats.percentImp())			boxes.append(go.Box(y=teamImp[team], name=team))			teamImpMeans.append(np.mean(teamImp[team]))		print np.mean(stats.improvement), division, gender		slope, intercept, r_value, p_value, std_err = linregress(teamStr, teamImpMeans)		print slope, intercept, r_value, p_value, std_err		fit, res, _, _, _= np.polyfit(teamStr, teamImpMeans, 1, full=True)		print res		fit_fn = np.poly1d(fit)		start = min(teamStr)		end = max(teamStr)		boxes.append(go.Scatter(					x=[start, end],					y=[fit_fn(start), fit_fn(end)],					name="Best Fit",				))		#offline.plot({'data': boxes}, filename='teamDropsMen.html')		print teamStr, teamImpOrdered		figure = {  			"data": [				go.Scatter(					x=teamStr,					y=teamImpOrdered,					mode='markers+text',					name="Women's Teams",					text=teamNames,					textposition='top'				)#,				#go.Scatter(				#	x=[start, end],				#	y=[fit_fn(start), fit_fn(end)],				#	name="Best Fit",				#)			],    		"layout": go.Layout()		}		py.plot(figure, filename="teamDropFitWomen.html")if __name__ == "__main__":	#import plotly.plotly as py	#import plotly.tools	#import plotly.graph_objs as go	#import plotly.offline as offline	#from plotly.tools import FigureFactory as FF	#plotly.tools.set_credentials_file(username='khallman', api_key='y6h7gxd725')	# database setup	urlparse.uses_netloc.append("postgres")	if "DATABASE_URL" in os.environ:  # production		url = urlparse.urlparse(os.environ["DATABASE_URL"])		db = PostgresqlDatabase(database=url.path[1:],								user=url.username,								password=url.password,								host=url.hostname,								port=url.port)	else:		db = PostgresqlDatabase('swimdb', user='hallmank')	database = SwimDatabase(db)	for division in ['D1', 'D2', 'D3']:		for gender in ['Women', 'Men']:			database.updateTeamStats(division, gender, week=6)	#		database.getTimeMode(gender, division, '50 Yard Freestyle')	#gradientDescent(database.meetPrediction, .01, .03)	#database.updateConferenceProbs(gender='Men', weeksIn=12)	#for st in [.005, .0075, .01, .0125, .015]:	#	for si in [.005, .0075, .01, .0125, .015]:	#		print database.meetPrediction(sigmat=st, sigmai=si+.01, gender='Men', week=-1)	#print database.similarSwimmers('Hallman, Mark', 'Sophomore', 'Pomona-Pitzer', 5)	#print database.conference(nextYear=True, season=2016)	#for event in ['100 Yard Breastroke' ,'200 Yard Breastroke', '100 Yard Freestyle', '1650 Yard Freestyle']:	#	database.fitEvent(event, 'Men')	#database.eventCombos(20000)	#database.bestMeet(database.eventCombos())	#print database.impStats()