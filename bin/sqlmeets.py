import reimport numpy as npimport operatorfrom datetime import datefrom peewee import *#import scipy.stats, scipy.misc#, pylabimport time as TimepointsChampionship = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]pointsDualI = [9, 4, 3, 2, 1]pointsDualR = [11, 4, 2]eventsDualS = ["200 Yard Medley Relay","1000 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsDualL = ["400 Yard Medley Relay","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","400 Yard Individual Medley","400 Yard Freestyle Relay"]eventsChamp = ["400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsChamp3 = ['1 mtr Diving','200 Yard Freestyle Relay','','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','','400 Yard Medley Relay','','400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','800 Yard Freestyle Relay','','1650 Yard Freestyle','','200 Yard Medley Relay','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','','400 Yard Freestyle Relay','3 mtr Diving']eventsDay1 = ['1 mtr Diving','200 Yard Freestyle Relay','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','400 Yard Medley Relay']eventsDay2 = ['400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','800 Yard Freestyle Relay']eventsDay3 = ['1650 Yard Freestyle','200 Yard Medley Relay','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','400 Yard Freestyle Relay','3 mtr Diving']allEvents={"400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay",'1000 Yard Freestyle','100 Yard Breastroke','200 Yard Breastroke'}eventsHS = ["200 Yard Medley Relay","200 Yard Individual Medley","200 Yard Freestyle","50 Yard Freestyle","1 mtr Diving","100 Yard Butterfly","100 Yard Freestyle","500 Yard Freestyle","200 Yard Freestyle Relay","100 Yard Backstroke","100 Yard Breastroke","400 Yard Freestyle Relay"]MIAC = ["Carleton","Augsburg","St. Olaf","Saint Mary's MN","Macalester","Gustavus","Saint Benedict","St. Kate's","Concordia","St. John's","St. Thomas","Hamline"]requiredEvents={"200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly"}eventOrder = ["50 Yard Freestyle","100 Yard Freestyle","200 Yard Freestyle","500 Yard Freestyle","1000 Yard Freestyle","1650 Yard Freestyle","100 Yard Butterfly","200 Yard Butterfly","100 Yard Backstroke","200 Yard Backstroke","100 Yard Breastroke","200 Yard Breastroke","200 Yard Individual Medley","400 Yard Individual Medley","200 Yard Medley Relay","400 Yard Medley Relay","200 Yard Freestyle Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay"]#setup database connectiondb_proxy = Proxy()swimDatabase = None#make time look nicedef swimTime(time):	(seconds,point) = re.split("\.",str(time))	if int(seconds) < 60:		time=round(time,2)		time=str(time)		while len(time) < 5:			time += '0'		return time	minutes=str(int(seconds)/60)	seconds=str(int(seconds)%60)	while len(seconds) < 2:		seconds='0'+seconds	while len(point) < 2:		point=point+'0'	return  minutes + ":" + seconds + "." + point[:2]#convers to a time in secondsdef toTime(time):	if time[0]=="X" or time[0]=="x":		time=time[1:]	if re.match(".*:.*",time) == None:		return float(time)	return float(re.split(":",time)[0])*60 +float(re.split(":",time)[1])#sees if one list contains anotherdef contains(small, big):	for i in small:		if not i in big:			return False	return Truedef relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']def getConfs(fileName='data/conferences.txt'):	try:		with open(fileName, 'r') as file:			divisions = {'D1': {}, 'D2': {}, 'D3': {}}			teams = {}			for line in file:				parts = re.split('\t', line.strip())				division = parts[0]				conf = parts[1]				team = parts[2]				if not conf in divisions[division]:					divisions[division][conf] = set()				divisions[division][conf].add(team)				if not team in teams:					teams[team] = (conf, division)		return divisions	except IOError:		return Nonedef getTeamMeets(fileName='data/teammeets.txt'):	try:		with open(fileName, 'r') as file:			teams = {}			for line in file:				parts = re.split('\t', line.strip())				(team, season, meet) = (parts[0], int(parts[1]), parts[2])				if not team in teams:					teams[team] = {}				if not season in teams[team]:					teams[team][season] = set()				teams[team][season].add(meet)		return teams	except IOError:		return Nonedef storeTeamMeets(teamMeets, fileName='data/teammeets.txt'):	with open(fileName, 'w') as file:		for team in teamMeets:			for season in teamMeets[team]:				for meet in teamMeets[team][season]:					file.write(team + '\t' + str(season) + '\t' + meet + '\n')def thisSeason():	today = date.today()	if today.month > 6:		return today.year + 1	return today.yeardef rejectOutliers(data, l=2, r=4):	u = np.mean(data)	s = np.std(data)	newList = [i for i in data if (u - l*s < i < u + r*s)]	#print swimTime(max(data)), swimTime(min(data))	#print "Num rejected: " + str(len(data)-len(newList))	return newListclass Swim(Model):	name = CharField()	event = CharField()	date = DateField()	time = FloatField()	season = IntegerField()	team = CharField()	meet = CharField()	gender = CharField()	conference = CharField()	division = CharField()	relay = BooleanField()	year = CharField()	place = None	score = None	scoreTeam = None	scoreTime = None	split = False	def getScoreTeam(self):		if self.scoreTeam:			return self.scoreTeam		if self.team:			return self.team		return ''	def getScoreTime(self):		if self.scoreTime:			return	self.scoreTime		return self.time	def getScore(self):		if self.score:			return self.score		return 0	def printScore(self, br='\t', gender=True):		time = swimTime(self.getScoreTime())		if gender:			genderStr = br + self.gender		else:			genderStr = ''		if self.relay:			name = 'Relay'		else:			name = self.name		if self.meet:			meet = str(self.meet)		else:			meet = ''		return name+br+self.getScoreTeam()+genderStr+br+self.event+br+time+br+meet	class Meta:		database = db_proxy		indexes = ('name', 'meet')'''stores a team's data'''class Team:	def __init__(self, name, database):		self.database = database		self.name = name		if self.name in database.teamMeets:			self.meets = database.teamMeets[self.name]		else:			self.meets = {}		self.topRelays = {}		self.swimmers = {}		self.relays = {}		self.topDuals = {} #cache top duals		self.averageImprovement = {}		self.averageTaper = None		self.totalAverageImprovement = None	def topDual(self, season, debug=False, includeEvents=requiredEvents, gender='Men'):		if debug: print self.name, self.meets		if season in self.topDuals:			if debug: print 'cached'			return self.topDuals[season]		#now we will swim the season's meets against each other		topMeet = None		if not season in self.meets:			return None		for meetName in self.meets[season]:			meet = Meet(meetName, gender=gender, teams=[self.name])  # this will actually load the data			if not meet.isDual():				continue			if debug:				print 'testing ' + meet.name			if not topMeet:				topMeet = meet				continue			result = self.database.swimMeet([[self.name, topMeet, 'old'], [self.name, meet, 'new']],									   includeEvents=includeEvents, selectEvents=True)  # token names			score = result.teamScores()			if debug:				print score				result.printout()			if score and score[0][0]=='new':				topMeet = meet			meet.reset(teams=True)			topMeet.reset(teams=True)		if not topMeet:			self.topDuals[season] = None			return None		self.topDuals[season] = topMeet		if debug: print 'top '+ self.topDuals[season].name		return self.topDuals[season]	def getAverageImprovement(self, season=None):		if season==None and self.totalAverageImprovement: return self.totalAverageImprovement		elif season in self.averageImprovement: return self.averageImprovement		countTotal=0		averageTotal=0		for season in self.swimmers:			#print 'a-----------------------------------------------'			#print season			countSeason=0			averageSeason=0			for swimmer in self.swimmers[season]:				#print '-------------------'				#print swimmer				improvement=swimmer.getAverageImprovement(season)				if improvement:					countTotal+=1					averageTotal=(averageTotal*(countTotal-1)+improvement)/countTotal					countSeason+=1					averageSeason=(averageSeason*(countSeason-1)+improvement)/countSeason			self.averageImprovement[season]=averageSeason		self.totalAverageImprovement=averageTotal		if season==None: return averageTotal		if season in self.averageImprovement: return self.averageImprovement[season]		return None	def getAverageTaper(self, season='all', top=False):		if self.averageTaper: return self.averageTaper		count=0		average=0		if season=='all':			for season in self.swimmers:				for swimmer in self.swimmers[season]:					tapers=swimmer.getTapers(top=top)					for season in tapers:						for event in tapers[season]:							average=(average*count+tapers[season][event])/(count+1)							count=count+1		return average	def __str__(self):		return self.name	def __eq__(self, s):		if self.name == s:			return True		if not type(s)==type(self): return False #not called on a season		return self.name==s.name	def __hash__(self):		return hash(self.name)'''this class contains a swim meetscores itself'''class Meet:	def __init__(self, name=None, events=allEvents, gender=None, topSwim=True, teams=None):		self.gender = gender  # None means both		self.teams = []  # teams added as swims are		self.scores = None		self.eventSwims = {}		self.events = events		self.name = name  # named meets are ones that actually happened		self.date = None		self.season = None		if self.name:			if not gender:				genders = ['Men', 'Women']			else:				genders = [gender]			if topSwim:				if self.teams:					for swim in Swim.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team).where(Swim.meet==name,																					Swim.gender << genders,																					Swim.event << list(events),																					Swim.team << list(teams)).group_by(						Swim.name, Swim.event, Swim.team):						self.addSwim(Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender, meet=name,									  team=swim.team))				else:					for swim in Swim.select(Swim.name, Swim.event, fn.Min(Swim.time), Swim.team).where(Swim.meet==name,																					Swim.gender << genders,																					Swim.event << list(events),																					Swim.team << list(teams)).group_by(						Swim.name, Swim.event, Swim.team):						self.addSwim(Swim(name=swim.name, event=swim.event, time=swim.min, gender=gender, meet=name,									  team=swim.team))			else:				for swim in Swim.select().where(Swim.meet==name, Swim.event << list(events), Swim.gender << genders,												Swim.team << list(teams)):					self.addSwim(swim)	def reset(self, teams=False, times=False):		for swim in self.getSwims():			if teams:				swim.scoreTeam = None			if times:				swim.scoreTime = None	#sees if any swims are in the meet	def isEmpty(self):		for event in self.eventSwims:			if not self.eventSwims[event]==[]:				return False		return True	def isDual(self):		return len(self.teams) == 2	def getSwims(self, team='all', relays=True, splits=False, ind=True):		swims=set()		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if ind and (swim.team == str(team) or team=='all') and (relays or not swim.relay):					swims.add(swim)				if splits and swim.relay and (team=='all' or swim.team == str(team)):					for split in swim.swims:						swims.add(split)		return swims	def addSwim(self, swim):		if not swim.getScoreTeam() in self.teams:			self.teams.append(swim.getScoreTeam())		if self.name and not self.date or not self.season:  # without a name, its a dummy meet			self.date=swim.date			self.season=swim.season		if not swim.event in self.eventSwims:			self.eventSwims[swim.event] = []		self.eventSwims[swim.event].append(swim)	def addSwims(self, swims):		for swim in swims:			self.addSwim(swim)	def removeSwimmer(self, name):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.name==name:					self.eventSwims[event].remove(swim)	def getEvents(self, events=''):		myEvents = set(self.eventSwims.keys())		if events=='':			if self.events == None:				events = allEvents			else:				events = self.events		events = set(events) & set(myEvents)		return events	def eventVariance(self):		timeVar={}		self.place()		for event in self.eventSwims:			average=0			count=0			for i in range(len(self.eventSwims[event])-1):				timeDif=abs(self.eventSwims[event][i].time-self.eventSwims[event][i+1].time) #time dif between this and next place				average=(average*count+timeDif)/(count+1) #running average				count+=1			timeVar[event]=average		return timeVar	'''	decides top events for each swimmer	top swimmers are decided by highest scoring event right now	unlimited divers	'''	def topEvents(self, teamMax=17, indMax=3, totalMax=8, events=''):		self.place()		conference = Meet()		indSwims = {}		relaySwims = {}		teamSwimmers = {}		teamDivers = {}		drops = []		relayEvents = set()		events = self.getEvents(events)		for team in self.teams:			teamSwimmers[team]=0			teamDivers[team]=0		for event in events:  # we will keep relays as is, but count them towards total swims			if re.search('Relay', event):				relayEvents.add(event)				while not self.eventSwims[event] == []:  # move relays over to new meet					relay = self.eventSwims[event].pop()					conference.addSwim(relay)					#for swim in relay.swims:					#	if swim.name in relaySwims:					#		relaySwims[swim.name]+=1					#	else:					#		relaySwims[swim.name]=1		for event in relayEvents:			events.remove(event)		#pare down		self.place()		for event in self.eventSwims:			if len(self.eventSwims[event]) > 100:				self.eventSwims[event] = self.eventSwims[event][:99] #start with top 100 times		#now make sure that each person swims their top events		preEvent = None		nextEvent = None		while not self.isEmpty():			for event in events:				drop=True  # just allow us to enter the loop				while drop == True and not self.eventSwims[event]==[]:  # we need to loop on an event until we find				# someone who is actually in it					drop = False					#print self.eventSwims[event]					if self.events and type(self.events) == type([]):						if not self.events.index(event) == 0:							preEvent = self.events[self.events.index(event)-1]						if not self.events.index(event)==len(self.events)-1:							nextEvent = self.events[self.events.index(event)+1]					newSwim = self.eventSwims[event].pop(0)					if preEvent in conference.eventSwims:						for swim in conference.eventSwims[preEvent]:							if newSwim.name==swim.name:								drops.append(newSwim)								drop=True								break					if nextEvent in conference.eventSwims:						for swim in conference.eventSwims[nextEvent]:							if newSwim.name==swim.name:								drop=True								drops.append(newSwim)								break					if drop:  # already swimming previous or next event						continue					if not newSwim.name in indSwims:  # fixed to still add swim when all 18 swimmers there						if teamSwimmers[newSwim.getScoreTeam()] < teamMax:							indSwims[newSwim.name]=0							teamSwimmers[newSwim.getScoreTeam()]+=1						else:							drops.append(newSwim)							continue					if indSwims[newSwim.name]<indMax and ((not newSwim.name in relaySwims) or indSwims[newSwim.name]+relaySwims[newSwim.name] < totalMax):						conference.addSwim(newSwim)						indSwims[newSwim.name]+=1					else:						drops.append(newSwim)						drop = True  # can't swim any more events		self.eventSwims=conference.eventSwims		return drops	'''	adds top relays using same method in database	'''	def addTopRelays(self, number, team, database):		relays = [event for event in self.events if re.search('Relay',event)]		return database.topRelays(relays, team, self)	'''	creates the best lineup for the given team against another set lineup	no two person swapping instabilities	->must implement relay creation and switching	'''	def lineup(self, team, database=None, debug=False, splits=False):		team=str(team)		#take top three relays in each event		#if database:		#	dropSplits = database.topTimes()		#	dropSplits = [split for split in dropSplits if split.split]		drops = self.topEvents(30, 3, 4)		self.place()		'''		now we have a starting point		'''		extras = {}  # double dictionary,swim:event		for swim in drops:  # + dropSplits			if not swim.name in extras:				extras[swim.name] = {}			extras[swim.name][swim.event]=swim		if debug: self.printout()		toCheck = self.getSwims(team, False, splits=splits)		while len(toCheck) > 0:  # double loop on all swims, trying to see if more points are scored if swapped			swim1=toCheck.pop()			swims=self.getSwims(team, False, splits=splits)			while len(swims) > 0:				swim2=swims.pop()				if swim1==swim2 or swim1.event==swim2.event:					continue				#make sure swims exist				if extras.has_key(swim2.name) and extras.has_key(swim1.name) and extras[swim1.name].has_key(swim2.event) and extras[swim2.name].has_key(swim1.event):					self.score()					if debug:						print self.score()						print team					oldScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]					(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)					self.score()					newScore = self.teamScores(sorted=False)[team] # [swim1.event,swim2.event]					if oldScore < newScore: # swap in new swims						if debug:							print "swap"							print newSwim1.name, newSwim1.event							print newSwim2.name, newSwim2.event						swims.add(newSwim1)						swims.add(newSwim2)						if swim1 in swims:							swims.remove(swim1)						if swim2 in swims:							swims.remove(swim2)						for swim in (newSwim1, newSwim2):							if newSwim1.split: #re-add swims in those events								for relay in self.eventSwims[newSwim1.fromRelay]:									if relay.team==team:										for split in relay.swims:											if not split in toCheck:												toCheck.add(split)							else:								for swim in self.eventSwims[newSwim1.event]:									if not swim in toCheck and swim.team==team:										toCheck.add(swim)						if swim2 in toCheck: #make sure second swim is not checked again							toCheck.remove(swim2)						swim1=toCheck.pop() #start checking next swim					else: # revert to old lineup						self.swap(newSwim1,newSwim2,extras)		self.score()	'''	given two old swims	will swap two swims, returns two new swims	'''	def swap(self, swim1, swim2, extras):		newSwim1=extras[swim1.name][swim2.event]		newSwim2=extras[swim2.name][swim1.event]		if self.eventSwims.has_key(swim2.event) and swim2 in self.eventSwims[swim2.event]: # ind swim			self.eventSwims[swim2.event].remove(swim2)			self.addSwim(newSwim1)		else: #gotta be a relay			self.relaySwap(swim2,newSwim1)		if self.eventSwims.has_key(swim1.event) and swim1 in self.eventSwims[swim1.event]: # ind swim			self.eventSwims[swim1.event].remove(swim1)			self.addSwim(newSwim2)		else: #gotta be a relay			self.relaySwap(swim1,newSwim2)		if not extras.has_key(swim1.name):			extras[swim1.name]={}		extras[swim1.name][swim1.event]=swim1		if not extras.has_key(swim2.name):			extras[swim2.name]={}		extras[swim2.name][swim2.event]=swim2		return (newSwim1,newSwim2)	'''	swaps someone into a relay	given old (swim1) and new (swim2) split	'''	def relaySwap(self, swim1, swim2):		for relay in self.eventSwims[swim1.fromRelay]:			if swim1 in relay.swims:				relay.changeSwimmer(swim1,swim2)				return	def taper(self):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				swim.taper()	def expectedScores(self):		self.place()		scores = {}		teamSwims = {}		for event in self.eventSwims:			teamSwims[event] = {}			for swim in self.eventSwims[event]:				if not swim.team in scores:					scores[swim.team] = 0				if not swim.team in teamSwims[event]:					teamSwims[event][swim.team] = 0				else:					teamSwims[event][swim.team] += 1				losses = teamSwims[event][swim.team]				points = swimDatabase.expectedPoints(time=swim.time, event=event, gender=swim.gender, numSwimmers=16,														division='D3', losses=losses)				scores[swim.team] += points				#print swim.event, swim.time, points, int(round(scores[swim.team])), losses		for team in scores:			scores[team] = int(round(scores[team]))		return scores	'''	places the meet	'''	def place(self, events='', storePlace=False):		events=self.getEvents(events)		for event in events:			if not event in self.eventSwims or len(self.eventSwims[event]) == 0:				continue			self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=False)			#else:  #diving			#	self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(),			# reverse=True)			if storePlace:				for idx, swim in enumerate(self.eventSwims[event]):					swim.place = idx+1	'''	scores the meet	'''	def score(self, dual=None, events='', heatSize=8, heats=2, debug=False):		events = self.getEvents(events)		if debug:			print events		if dual is None:			if len(self.teams)==2:				dual=True			else:				dual=False		self.place(events)		max = 16		if heats == 3:			pointsI = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif heats == 2:			pointsI = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		if heatSize == 6:			pointsI = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		pointsR = [x*2 for x in pointsI]		if dual:			max = 3			pointsI = [9, 4, 3, 2, 1]			pointsR = [11, 4, 2]		for event in self.eventSwims:  # Assign scores to the swims			if not event in events and self.eventSwims[event]:  # set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score = 0			if debug:				print 'scoring', event			place = 1			teamSwims = {}			for swim in self.eventSwims[event]:				swim.score = None  # reset score				if not 'Relay' in swim.event:  # should use real relay var					team = swim.getScoreTeam()					if place > len(pointsI) or (team in teamSwims) and teamSwims[team] >= max:						swim.score = 0					else:						swim.score = pointsI[place-1]						if not team in teamSwims:							teamSwims[team] = 0						teamSwims[team] += 1						place += 1				else:					team = swim.team					if place > len(pointsR) or (team in teamSwims) and teamSwims[team] >= max:						swim.score = 0					else:						swim.score = pointsR[place-1]						if not team in teamSwims:							teamSwims[team] = 0						teamSwims[team] += 1						place += 1		return self.teamScores(events)	def teamScores(self, events='', sorted=True):		events = self.getEvents(events)		teams = {}		for event in events:			if not event in self.eventSwims: continue			for swim in self.eventSwims[event]:				team = swim.getScoreTeam()				if not team in teams:					teams[team] = 0				teams[team] += swim.getScore()		if not sorted:			return teams		scores = []		for team in teams:			scores.append([team, teams[team]])		scores.sort(key=lambda team: team[1], reverse=True)		self.scores = scores		return scores	def winningTeam(self):		if not self.scores: self.teamScores()		if len(self.scores)<1 or len(self.scores[0])<1: return None		return self.scores[0][0]	'''	lists swimmers by team and by points scored	'''	def scoreReport(self, printout=True, repressSwim=False, repressTeam=False):		scores={}		for team in self.teams:			scores[team]={'total': 0, 'year': {}, 'swimmer': {}, 'event': {}}		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.relay:					name = 'Relays'				else:					name = swim.name				if repressSwim and swim.score == 0:					continue   # repess zero scores				if not name in scores[swim.team]['swimmer']:					scores[swim.team]['swimmer'][name] = 0				if not event in scores[swim.team]['event']:					scores[swim.team]['event'][event]=0				scores[swim.team]['swimmer'][name] += swim.score				scores[swim.team]['total'] += swim.score				scores[swim.team]['event'][event] += swim.score				if swim.year:					if not swim.year in scores[swim.team]['year']:						scores[swim.team]['year'][swim.year] = 0					scores[swim.team]['year'][swim.year] += swim.score		if printout:			for team in sorted(scores['swimmer'],key=scores['swimmer']['total']):				print '-------------------------------'				print team				for name in sorted(scores['swimmer'][team], key=scores['swimmer'][team].__getitem__):					print name.join(scores['swimmer'][team][name].ljust(25))		if repressTeam:			zeroTeams=set()			for team in scores:				if scores[team]['total'] == 0:					zeroTeams.add(team)			for team in zeroTeams:				del(scores[team])		return scores	def printout(self, events=''):		events=self.getEvents(events)		for event in events:			if event not in self.eventSwims: continue			print "-------------------------------------------------------------------------------------"			print "Event: " + event			for swim in self.eventSwims[event]:				if swim.score:					print swim.printScore().lstrip()+"\t"+str(swim.score)				else:					print swim.printScore().lstrip()		print self.scores	def scoreString(self, showNum='all', showScores=True, showPlace=False):		self.score()		string = {}		events=self.getEvents('')		for event in events:			if event not in self.eventSwims: continue			string[event]=[]			place = 0			for swim in self.eventSwims[event]:				place += 1				if not showNum=='all' and place > showNum:					break				swimAry = re.split('\t', swim.printScore(gender=False).strip())				if showPlace:					swimAry.insert(0, place)				if swim.score and showScores:					swimAry.append(str(swim.score))					string[event].append(swimAry)				else:					string[event].append(swimAry)		string["scores"]=self.teamScores()		return string	def __str__(self):		if self.name:			return self.name		self.printout()		return ''	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name and self.date==s.date	def __hash__(self):		return hash(self.name)^hash(self.date)'''full database methods'''class SwimDatabase:	def __init__(self, database):		global swimDatabase		swimDatabase = self		db_proxy.initialize(database)		self.dist = {}		self.results = {}  # cache dual results		self.teams = {}		self.conferences = getConfs()		if not self.conferences:			self.conferences = {'D1': {}, 'D2': {}, 'D3': {}}			for swim in Swim.select(Swim.conference, Swim.division, Swim.team).distinct(Swim.team):				if swim.division=='':					continue				if not swim.conference in self.conferences[swim.division]:					self.conferences[swim.division][swim.conference] = set()				self.conferences[swim.division][swim.conference].add(swim.team)		self.teamMeets = getTeamMeets()		if not self.teamMeets:			self.teamMeets = {}			for team in Swim.select(Swim.team).distinct():				teamName = team.team				for swim in Swim.select(Swim.meet, Swim.team, Swim.season).where(Swim.team == teamName).distinct(						Swim.meet):					if not teamName in self.teamMeets:						self.teamMeets[teamName] = {}					if not swim.season in self.teamMeets[teamName]:						self.teamMeets[teamName][swim.season] = set()					self.teamMeets[teamName][swim.season].add(swim.meet)			storeTeamMeets(self.teamMeets)		self.teams = {}		for swim in Swim.select(Swim.team).distinct():			self.teams[swim.team] = Team(name=swim.team, database=self)	def topDual(self, season=thisSeason(), events=requiredEvents, debug=False, teams='all', gender='Men'):		if teams == 'all':			teams = self.teams		meets = {}		wins = {}		losses = {}		for team in teams:			if not team in self.teams:				self.teams[team] = Team(team, self)			if not self.teams[team].topDual(season, debug=debug, gender=gender):				continue			meets[team] = self.teams[team].topDual(season, debug=debug, gender=gender)  # its cached			wins[team] = 0			losses[team] = 0			#if debug: print team, '\t\t', meets[team]		if debug: print '-----------'		for team1 in meets:			for team2 in meets:				if team1 == team2:					continue				if not team1 in self.results:					self.results[team1] = {}				if not team2 in self.results:					self.results[team2] = {}				if team2 in self.results[team1] or team1 in self.results[team2]:  # reverse meet already swum					continue				newMeet = self.swimMeet([[team1, meets[team1]], [team2, meets[team2]]], includeEvents=events,									  selectEvents=False)  # should convert to dual form				self.results[team1][team2] = newMeet.winningTeam()				self.results[team2][team1] = newMeet.winningTeam()				if debug: print team1, team2, newMeet.winningTeam()				if self.results[team1][team2] == team1: # team1 wins					wins[team1] += 1					losses[team2] += 1				elif self.results[team1][team2] == team2:  # team2 wins, otherwise no points					wins[team2] += 1					losses[team1] += 1		if debug:			for (index, team) in enumerate(sorted(wins.items(), key=operator.itemgetter(1), reverse=True)):				print str(index)+'.',team[0]+':',team[1],'-',losses[team[0]]		return meets, wins, losses	'''	creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	'''	def swimMeet(self, teamMeets, gender=None, debug=False, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False):		meet = Meet()		teams = set()		if includeEvents == 'all':			includeEvents = allEvents		commonEvents = allEvents		for teamMeet in teamMeets:			newTeamName = None			newTeam = teamMeet[0]			newMeet = teamMeet[1]			if isinstance(newMeet, basestring):  # just a name				newMeet = Meet(name=newMeet, gender=gender, teams=set(newTeam))			commonEvents = commonEvents & set(newMeet.eventSwims.keys())			if debug:				print set(newMeet.eventSwims.keys())				newMeet.printout()			if len(teamMeet) == 3:  # maybe pass in new team name				newTeamName = teamMeet[2]			swims = newMeet.getSwims(newTeam)			duplicate = 1			for swim in swims:				if newTeamName:					swim.scoreTeam = newTeamName				elif newTeam in teams:  # duplicate team and no new name specified					duplicate += 1					swim.scoreTeam = swim.team + ' ' + str(duplicate)				meet.addSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		if len(meet.teams) == 2:			if selectEvents:				meet.topEvents(25, 3, 4)			meet.events = (commonEvents | includeEvents) - excludeEvents			meet.score(dual=True)		else:			if selectEvents:				meet.topEvents()			meet.score()		if debug: meet.printout()		return meet	'''	optimal lineup creator	'''	def lineup(self, teams, meet, season=None, debug=False, resetTimes=False, events=eventsDualS, gender='Men'):		if not season:			season = thisSeason()		meet.events = events		if debug:			print meet.getEvents(), events		meet.addSwims(self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=True).getSwims())		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		meet.place()		if debug:			meet.printout()		if len(teams) == 1:			meet.lineup(teams.pop(), self, debug=debug)		else:			meet.topEvents(17, indMax=3, totalMax=4)		return meet	'''	doesn't really do anything	'''	def swimMeetPredictor(self, teams):		pass	'''	returns meet of top times	'''	def topTimes(self, events=None, teams=MIAC, season=None, gender='Men', topTimes=True, meetForm=True,				 taper=False, divisions='all'):		if not events:			events = allEvents		if teams == 'all':			teams = self.teams		if divisions == 'all':			divisions = ['D1', 'D2', 'D3']		if not season:			season = thisSeason()  # use current season		if taper:			taperDate = date(season, 2, 10)		topMeet = Meet(events=events)		swimmers = {}		print list(divisions)		if taper:			select = Swim.select().where(Swim.team << list(teams), Swim.event << list(events), Swim.date > taperDate,										 Swim.gender==gender, Swim.season==season, Swim.division << list(divisions))		else:			select = Swim.select().where(Swim.team << list(teams), Swim.event << list(events), Swim.gender==gender,										 Swim.season==season, Swim.division << list(divisions))		if topTimes:			qwery = select.select(Swim.name, Swim.event, Swim.team, fn.Min(Swim.time), Swim.year).group_by(					Swim.name, Swim.event, Swim.team, Swim.year)		else:			qwery = select.select(Swim.name, Swim.event, Swim.team, fn.Avg(Swim.time), Swim.year).group_by(					Swim.name, Swim.event, Swim.team, Swim.year)		for swim in qwery:			if topTimes:				time = swim.min			else:				time = swim.avg			if meetForm:				topMeet.addSwim(Swim(name=swim.name, event=swim.event, time=time, gender=gender, team=swim.team,									  season=season, year=swim.year))			else:				if not swim.team in swimmers:					swimmers[swim.team] = {}				if not swim.name in swimmers[swim.team]:					swimmers[swim.team][swim.name] = {}				swimmers[swim.team][swim.name][swim.event] = Swim(name=swim.name, event=swim.event, time=time,									gender=gender, team=swim.team, season=season, year=swim.year)		if meetForm:			topMeet.place()			return topMeet		return swimmers	def conference(self, teams=MIAC, season=None, topTimes=True, gender='Men', divisions='all'):		events = eventsChamp3		if not season:			season = thisSeason()  # use current season		conference = self.topTimes(events=events, teams=teams, season=season, gender=gender, topTimes=topTimes,								   divisions=[divisions])		conference.topEvents(17)		conference.score()		return conference	'''	tests predictions	'''	def taperTest(self):		for swimmer in self.swimmers.values():			tapers = swimmer.getMedianTaperTimes()			nonTapers = swimmer.getMedianNonTaperTimes(average=False)			for season in tapers:				for event in tapers[season]:					if season in nonTapers and event in nonTapers[season]:						absDif = abs(tapers[season][event] - nonTapers[season][event])						perDif = abs(tapers[season][event] - nonTapers[season][event])/abs(tapers[season][event] +																						   nonTapers[season][event])						print swimmer.name+','+swimmer.gender+','+swimmer.team+','+event+','+str(absDif)+','+str(perDif)	def preFinalVariance(self, meetNames):		for meetName in meetNames:			meet = self.meets[meetName]			if not meet.eventSwimsPrelims: return			meet.place('all',True)			placeDif={}			timeDif={}			for event in meet.eventSwims:				placeDif[event]=[]				timeDif[event]=[]				for finalsSwim in meet.eventSwims[event]:					for prelimsSwim in meet.eventSwimsPrelims[event]:						if finalsSwim.name==prelimsSwim.name:							placeDif.append(meet.eventSwims[event].index(finalsSwim)-meet.eventSwimsPrelims[event].index(prelimsSwim))							timeDif.append(abs(prelimsSwim.time-finalsSwim.time)/((prelimsSwim.time+finalsSwim.time)/2))		''' fix with std		if not outliers: #throw away swims >2 std from mean			for event in placeDif:				av=average(placeDif[event])				stdDev=std(placeDif[event])				for dif in placeDif[event]:					if abs(dif-av)>2*stdDev:						placeDif.remove(dif)				av=average(timeDif[event])				stdDev=std(placeDif[event])				for dif in placeDif[event]:					if abs(dif-av)>2*stdDev:						placeDif.remove(dif)		'''	def taperPredictions(self, years='', teams='all', event='all', taperDate=None):		seasons=[]		if years=='': seasons.append(Season())		else:			for year in years:				seasons.append(Season(year))		if teams=='all':			teams=self.teams		taperSwims={}		for season in seasons:			for team in teams:				for swimmer in self.teams[team]:					nonTaper=swimmer.getMedianNonTaperTimes(season=season)					taper=swimmer.getMedianTaperTimes(season=season)					for event in taper:						pass	#not finished	def improvement(self, gender='Men', teams=MIAC, events=allEvents, season1=thisSeason()-1, season2=thisSeason()-2):		top1 = self.topTimes(gender=gender, events=events, teams=teams, season=season1, meetForm=False, taper=True)		top2 = self.topTimes(gender=gender, events=events, teams=teams, season=season2, meetForm=False, taper=True)		allImprovement = {}		teamImprovement = {}		for team in top1:			if not team in top2:				continue			if not team in allImprovement:				allImprovement[team] = {}				teamImprovement[team] = []			for swimmer in top1[team]:				if not swimmer in top2[team]:					continue				if not swimmer in allImprovement:					allImprovement[team][swimmer] = {}				for event in top1[team][swimmer]:					if not event in top2[team][swimmer]:						continue					time1 = top1[team][swimmer][event].time					time2 = top2[team][swimmer][event].time					drop = (time2-time1) / ((time1+time2) / 2) * 100					if abs(drop) > 10:  # toss outliers						continue					allImprovement[team][swimmer][event] = drop					teamImprovement[team].append(drop)		totalTeamImprovement = {}		for team in teamImprovement:			totalTeamImprovement[team] = {}			totalTeamImprovement[team]['avg'] = np.average(teamImprovement[team])			totalTeamImprovement[team]['std'] = np.std(teamImprovement[team])		return teamImprovement, allImprovement	def improvementTimes(self, printout, division, gender):		timeDrops={}		for swimmer in self.swimmers:			self.swimmers[swimmer].findImprovement()			swimmerDrops=self.swimmers[swimmer].improvementTimes			for season in swimmerDrops:				for event in swimmerDrops[season]:					if not event in timeDrops:						timeDrops[event]=[]					t1=swimmerDrops[season][event][0]					t2=swimmerDrops[season][event][1]					if abs(t1/t2-1)>.1: continue					timeDrops[event].append((t1,t2))					print gender+','+division+','+event+','+self.swimmers[swimmer].team+','+str(round((t1-t2)/((t1+t2)/2),5))+','+str((t1+t2)/2)		return timeDrops	def taperDrop(self):		difs={}		for swimmerName in self.swimmers:			swimmer=self.swimmers[swimmerName]			tapers=swimmer.getTapers()			taperTimes=swimmer.getMedianTaperTimes()			nonTaperTimes=swimmer.getMedianNonTaperTimes(True)			for season in tapers:				if season+1 in taperTimes and season+1 in nonTaperTimes:					for event in taperTimes[season+1]:						if event in nonTaperTimes[season+1] and event in tapers[season]:							if not event in difs:								difs[event]=[]							dif=(nonTaperTimes[season+1][event]*(1+tapers[season][event]))/taperTimes[season+1][event]							if abs(dif-1)>.07: continue #toss outliers							difs[event].append(dif)		for event in difs:			print event			print round(np.std(difs[event])*100,3)			np.average(difs[event])			#P.hist(difs[event])			#P.show()	def eventVariance(self, printout=False):		events={}		counts={}		for swimmerName in self.swimmers:			variance=self.swimmers[swimmerName].getTimeVariance(cutoff=2, tapers=False)			if variance!=[]:				for swim in variance:					event=swim[2]					var=swim[3]					num=swim[4]					if event not in events: events[event]=0					if event not in counts: counts[event]=0					events[event]=(events[event]*counts[event]+var*num)/(counts[event]+num)					counts[event]+=num					if printout: print swim		return events	def dualPlace(self):		print 'gender,event,time,score'		for meet in self.meets.values():			if not len(meet.teams)==2: continue			meet.score()			for swim in meet.getSwims():				print swim.gender+','+swim.event+','+str(swim.time)+','+str(swim.score)	def conferencePlace(self, division, gender, newSwims):		newEvents = set()		for swim in newSwims:			newEvents.add(swim[0])		confMeets = {}		with open('./data/' + division + gender + '.csv') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet					confMeets[confName].addSwims(Meet(name=meetName, events=newEvents, gender=gender,													  topSwim=True).getSwims())				else:					confMeets[confName] = Meet(name=meetName, events=newEvents, gender=gender, topSwim=True)		confScores = {}		for conference in confMeets:			confMeet = confMeets[conference]			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScores	def expectedPoints(self, time, gender, division, event, numSwimmers=6, losses=0):		if not gender in self.dist:			self.dist[gender] = {}		if not division in self.dist[gender]:			self.dist[gender][division] = {}		if not event in self.dist[gender][division]:			times = []			for swim in Swim.select(Swim.time).where(Swim.division==division, Swim.gender==gender, Swim.event==event):				if swim.time > 15:					times.append(swim.time)			if len(times) == 0:				print event, gender, division				return			times = rejectOutliers(times)			std = np.std(times)			mean = np.mean(times)			#return std, mean, scipy.stats.skew(times)			self.dist[gender][division][event] = scipy.stats.norm(mean, std)			#pylab.hist(times, bins=60)			#pylab.show()		scoresR = None		if numSwimmers == 24:			scores = [32, 28, 27, 26, 25, 24, 23, 22, 20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif numSwimmers == 16:			scores = [20, 17, 16, 15, 14, 13, 12, 11, 9, 7, 6, 5, 4, 3, 2, 1]		elif numSwimmers == 12:			scores = [15, 13, 12, 11, 10, 9, 7, 5, 4, 3, 2, 1]		else:			if not 'Relay' in event:				if losses > 2:					return 0			else:				if loses < 1:					return 0			scores = [9, 4, 3, 2, 1]			scoresR = [11, 4, 2]		if 'Relay' in event:			if scoresR:				scores = scoresR			else:				scores = [x*2 for x in scores]		scores = scores[losses:]  # people who you know you will lose to		dist = self.dist[gender][division][event]		lose = 1 - dist.cdf(time)		win = dist.cdf(time)		num = numSwimmers - 1 - losses # other swimmers		totalScore = 0		for place, score in enumerate(scores):			comb = scipy.misc.comb(num, place)  # number of ways to score that			totalScore += score * comb * (lose**(num-place) * win**(place))		return totalScoreif __name__ == "__main__":	database = SwimDatabase(PostgresqlDatabase('swimdb', user='hallmank'))	meet = None	i = 1	for meetName in database.teamMeets['Connecticut'][2013]:		print meetName		meet = Meet(meetName, gender='Men', teams=['Connecticut'])		start = Time.time()		#print meet.expectedScores()		#print Time.time() - start		i+=1		if i > 2:			break	#print database.improvement()[0]	#for swim in Swim.select().where(Swim.name=='Brown, Ross',Swim.season==2013, Swim.date > date(2013, 2, 10)):	#	print swim.name, swim.date, swim.season, swim.event, swim.team, swim.gender	#teams=set()	#for conf in database.conferences['D1']:	#	for team in database.conferences['D1'][conf]:	#		teams.add(team)