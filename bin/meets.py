import reimport osimport numpy as npimport operatorfrom datetime import datefrom types import *'''Data structure:SwimDatabase - overarching class that contains one full section of data. Pulls in from database flatfile.	meets - dictionary of Meet objects listed by name	swimmers - dictionary of Swimmer objects listed by name	swims - set of Swim objects	teams - set of Team objectsSwim - fundamental unit. Contains all information about a given swim including name, time, team, event, and score.	initialized from string from flatfileMeet - stores a single swim meet. 	score - scores and places the meet. Score is contained in	eventSwims - dictionary of a set of swims ex. eventSwims['100 Yard Free]'''pointsChampionship = [20,17,16,15,14,13,12,11,9,7,6,5,4,3,2,1]pointsDualI = [9,4,3,2,1]pointsDualR = [11,4,2]eventsDualS = ["200 Yard Medley Relay","1000 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsDualL = ["400 Yard Medley Relay","1650 Yard Freestyle","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","400 Yard Individual Medley","400 Yard Freestyle Relay"]eventsChamp = ["400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay"]eventsChamp3 = ['1 mtr Diving','200 Yard Freestyle Relay','','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','','400 Yard Medley Relay','','400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','','800 Yard Freestyle Relay','','1650 Yard Freestyle','','200 Yard Medley Relay','','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','','400 Yard Freestyle Relay','3 mtr Diving']eventsDay1 = ['1 mtr Diving','200 Yard Freestyle Relay','500 Yard Freestyle','200 Yard Individual Medley','50 Yard Freestyle','400 Yard Medley Relay']eventsDay2 = ['400 Yard Individual Medley','100 Yard Butterfly','200 Yard Freestyle','100 Yard Breastroke','100 Yard Backstroke','800 Yard Freestyle Relay']eventsDay3 = ['1650 Yard Freestyle','200 Yard Medley Relay','200 Yard Backstroke','100 Yard Freestyle','200 Yard Breastroke','200 Yard Butterfly','400 Yard Freestyle Relay','3 mtr Diving']allEvents={"400 Yard Medley Relay","400 Yard Freestyle Relay","800 Yard Freestyle Relay","400 Yard Individual Medley","1650 Yard Freestyle","200 Yard Medley Relay","200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly","200 Yard Individual Medley","200 Yard Freestyle Relay",'1000 Yard Freestyle','100 Yard Breastroke','200 Yard Breastroke'}eventsHS = ["200 Yard Medley Relay","200 Yard Individual Medley","200 Yard Freestyle","50 Yard Freestyle","1 mtr Diving","100 Yard Butterfly","100 Yard Freestyle","500 Yard Freestyle","200 Yard Freestyle Relay","100 Yard Backstroke","100 Yard Breastroke","400 Yard Freestyle Relay"]MIAC = ["Carleton","Augsburg","St. Olaf","Saint Mary's MN","Macalester","Gustavus","Saint Benedict","St. Kate's","Concordia","St. John's","St. Thomas","Hamline"]Big10=set()Pac12=set()requiredEvents={"200 Yard Freestyle","100 Yard Backstroke","100 Yard Breastroke","200 Yard Butterfly","50 Yard Freestyle","1 mtr Diving","3 mtr Diving","100 Yard Freestyle","200 Yard Backstroke","200 Yard Breastroke","500 Yard Freestyle","100 Yard Butterfly"}'''First we will declare the static methodsthis converts a double to swimming time'''def swimTime(time):	(seconds,point) = re.split("\.",str(time))	if int(seconds) < 60:		time=round(time,2)		time=str(time)		while len(time) < 5:			time += '0'		return time	minutes=str(int(seconds)/60)	seconds=str(int(seconds)%60)	while len(seconds) < 2:		seconds='0'+seconds	while len(point) < 2:		point=point+'0'	return  minutes + ":" + seconds + "." + point[:2]#convers to a time in secondsdef toTime(time):	if time[0]=="X" or time[0]=="x":		time=time[1:]	if re.match(".*:.*",time) == None:		return float(time)	return float(re.split(":",time)[0])*60 +float(re.split(":",time)[1])#sees if one list contains anotherdef contains(small, big):	for i in small:		if not i in big:			return False	return Truedef relayEvents(relay):	dist=str(int(re.findall('\d\d\d',relay)[0])/4)	if re.search('Free',relay):		return [dist+' Yard Freestyle']+[dist+' Yard Freestyle Split']*3	return  [dist+' Yard Backstroke Split',dist+' Yard Breastroke Split',dist+' Yard Butterfly Split',dist+' Yard Freestyle Split']#provides menuing and outputs responsedef menu(choices):	while True:		if len(choices)==1:			return choices[0]		num=0		for choice in choices:			num=num+1			print str(num)+') '+str(choice)		num=str(num)		try:			answer = raw_input('Enter a value (1 - ' + num + '): ')			if answer=='':				return			answer = int(answer)		except ValueError:			print 'Invalid input. Enter a value between 1 - '+num			continue		if not answer in range(1, len(choices)+1):			print 'Invalid input. Enter a value between 1 - '+num			continue		return choices[answer-1]'''summarized by arbitrary groupings'''def group(self,groups,swims):	#base case	if not groups:		for swim in swims:			print swim		return sorted(swims,key=lambda s: s.time)	#recursive case	newGroup=groups[-1]	summary={}	for swim in swims:		if not summary.has_key(swim.get(newGroup)):			summary[swim.get(newGroup)]=[]		summary[swim.get(newGroup)].append(swim)	for group in summary:		summary[group]=self.group(groups[:-1],summary[group])	return summary'''can prints grouped summary how you like'''def printSummary(self,summary,tabs=''):	for group in summary:		print tabs,group		if type(summary) is DictType:			self.printSummary(summary[group],tabs=tabs+'\t')def start(gender='Women', file='./swimData/DIII15f', confFile='./bin/conferences.txt'):	global database	database = SwimDatabase('', gender, 'College')	database.load(file)	with open(confFile,'r') as file:		for line in file:			parts = re.split('\t', line.strip())			division = parts[0]			name = parts[1]			team = parts[2]			if not team in database.teams: continue			if not name in database.conferences:				database.conferences[name]=Conference(name, division, {team})			else:				database.conferences[name].addTeam(team)	return databaseclass Swim(object):	def __init__(self, string='', name=None, team=None, event=None, time=None, gender=None, season=None, year=None):		if string=='':			self.finals=True			self.season=season			self.date=date.today()			self.meet=''			self.gender=gender			self.name=name			self.team=team			self.time=time			self.event=event			self.year=year			self.leadoff=False			self.split=False		else:			swimArray = re.split('\t',string)			self.meet=swimArray[0]			if '-' in swimArray[1]:				dateParts=re.split('-',swimArray[1])				self.date=date(int(dateParts[0]),int(dateParts[1]),int(dateParts[2]))			else:				dateParts=re.split('/',swimArray[1])				self.date=date(int(dateParts[2]),int(dateParts[0]),int(dateParts[1]))			self.season=Season(self.date)			self.meet=self.meet.strip()			self.name = swimArray[2]			self.year = swimArray[3]			self.team = swimArray[4]			self.gender = swimArray[5]			eventParts = re.split('-',swimArray[6])			self.event = eventParts[0].strip()			if len(eventParts)==2:				self.finals=False			else:				self.finals=True			time = swimArray[7].strip()			self.leadoff=False			self.split=False			if time[-1]=='L':				self.leadoff=True				time = time[:-1]			elif time[-1]=='R':				self.split=True				time = time[:-1]			if not ':' in time:				self.time = float(time)			else:				self.time=toTime(time)		self.place = None		self.swimmer = None		self.scoreTeam = None		self.scoreTime = None  #used if time is temporarily tapered ect.		self.score = None		self.diving = False		self.relay = False		if re.match(".*Diving", self.event):			self.diving=True		if re.match(".*Relay", self.event):			self.relay=True	def get(self, item):		item=item.lower()		if item=='name': return self.name		elif item=='event': return self.event		elif item=='team': return self.team		elif item=='scoreteam': return self.scoreTeam		elif item=='time': return self.time		elif item=='scoretime': return self.scoreTime		elif item=='score': return self.score		elif item=='date': return self.date		elif item=='season': return self.season		elif item=='year': return self.year	def rest(self, level=1):		if self.rest: return self.time*level/self.rest		return self.time	def improve(self):		self.scoreTime=self.time*.995	def taper(self):		self.swimmer.taper(self.event,self.season)		return self	def getScoreTeam(self):		if self.scoreTeam: return self.scoreTeam		return self.team	def getScoreTime(self):		if self.scoreTime: return self.scoreTime		return self.time	def getScore(self):		if self.score: return self.score		return 0	#time in seconds	def printScore(self, br='\t', gender=True):		if not self.diving:			time=swimTime(self.getScoreTime())		else:			time=str(self.time)		if gender:			genderStr = br + self.gender		else:			genderStr = ''		if self.relay:			name = 'Relay'		else:			name = self.name		return name+br+self.getScoreTeam()+genderStr+br+self.event+br+time+br+self.meet	def __str__(self):		return self.printScore()class Relay(Swim):	def __init__(self, string):		self.relay=True		self.swims=[]		if type(string[0]) == Swim:			self.create(string)			return		super(Relay, self).__init__(string)		self.name = self.team + ' Relay'	def addSwimmer(self, swim):		self.swims.append(swim)		swim.fromRelay=self.event	def changeSwimmer(self, oldSwim, newSwim):		self.swims[self.swims.index(oldSwim)]=newSwim		newSwim.fromRelay=self.event		time=0		for swim in self.swims:			time+=swim.time		self.time=time	def create(self, swims):		#we will assume last spot is reserved for the event		event=swims.pop()		time=0		for swim in swims:			time+=swim.time		#we're going to use the first swim to populate much of the info for the constructor		relay=swims[0].meet+' - '+swims[0].date.strftime("%x")+'\t\t\t'+swims[0].team+'\t'+swims[0].gender+'\t'+event+'\t'+str(time)		super(Relay,self).__init__(relay)		for swim in swims: #make sure constructor has been called to know what event to use			self.addSwimmer(swim)class Swimmer: #should add in filtering by season	def __init__(self,swim):		self.name=swim.name		self.team=swim.team		self.gender=swim.gender		self.year=swim.year		self.events={}		self.tapers=None		self.averageTaper=None		self.taperTimes={}		self.medianTaperTimes={}		self.topTaperTimes=None		self.nonTaperTimes={}		self.medianNonTaperTimes={}		self.topNonTaperTimes={}		self.improvement=None		self.improvementTimes=None		self.averageImprovement={}		self.totalAverageImprovement=None		self.topTimes={}		self.scoreTeam=None		self.taperDate=date(2000,2,1)	def getScoreTeam(self):		if self.scoreTeam: return self.scoreTeam		return self.team	def addSwim(self, swim):		swim.swimmer=self		if not swim.season in self.events:			self.events[swim.season]={}			self.taperTimes[swim.season]={}			self.nonTaperTimes[swim.season]={}			self.topNonTaperTimes[swim.season]={}		if not swim.event in self.events[swim.season]:			self.events[swim.season][swim.event]=[]		self.events[swim.season][swim.event].append(swim)		if swim.date > swim.season.end.replace(swim.season.end.year,self.taperDate.month,self.taperDate.day): #tapered swims			if not swim.event in self.taperTimes[swim.season]:				self.taperTimes[swim.season][swim.event]=[]			self.taperTimes[swim.season][swim.event].append(swim.time)		else: 											#non-tapered swims			if not swim.event in self.nonTaperTimes[swim.season]:				self.nonTaperTimes[swim.season][swim.event]=[]			self.nonTaperTimes[swim.season][swim.event].append(swim.time)			if not swim.event in self.topNonTaperTimes[swim.season]:				self.topNonTaperTimes[swim.season][swim.event]=swim.time			elif swim.time<self.topNonTaperTimes[swim.season][swim.event]:				self.topNonTaperTimes[swim.season][swim.event]=swim.time	def getTapers(self,swim=None,season='all',event='all',top=False):		if not self.tapers: self.findTapers(top=top)		if season=='all':			if event=='all':				return self.tapers		if season in self.tapers:			if event in self.tapers[season]:				return self.tapers[season][event]		return None	def findTapers(self,top=False):		self.tapers={}		self.getMedianTaperTimes()		if not top: #median tapers			nonTapers=self.getMedianNonTaperTimes()		else:			nonTapers=self.topNonTaperTimes		if not self.medianTaperTimes=={} and not nonTapers=={}:			for season in self.medianTaperTimes:				if season in nonTapers:					if not season in self.tapers:						self.tapers[season]={}					for event in self.medianTaperTimes[season]:						if event in nonTapers[season]:							if not event in self.tapers[season]:								self.tapers[season][event]=[]							self.tapers[season][event]=self.medianTaperTimes[season][event]/nonTapers[season][event]-1	def getMedianTaperTimes(self,season='all',event='all'):		if self.medianTaperTimes=={}: self.findMedianTaperTimes()		if season in self.medianTaperTimes:			if event=='all':				return self.medianTaperTimes[season]			if event in self.medianTaperTimes[season]:				return self.medianTaperTimes[season][event]		if not season=='all':			return		if not event=='all':			events=[]			for season in self.medianTaperTimes:				if event in self.medianTaperTimes[season]:					events.append(self.medianTaperTimes[season][event])			return events		return self.medianTaperTimes	def findMedianTaperTimes(self):		for season in self.taperTimes:			self.medianTaperTimes[season]={}			for event in self.taperTimes[season]:				self.medianTaperTimes[season][event]=np.median(self.taperTimes[season][event])	def getTopTaperTimes(self):		if not self.topTaperTimes: self.findTopTaperTimes()		return self.topTaperTimes	def findTopTaperTimes(self):		self.topTaperTimes={}		for season in self.taperTimes:			self.topTaperTimes[season]={}			for event in self.taperTimes[season]:				self.taperTimes[season][event].sort()				self.topTaperTimes[season][event]=self.taperTimes[season][event][0]		def getMedianNonTaperTimes(self,season='all',event='all',average=False):		if self.medianNonTaperTimes=={}:			self.findMedianNonTaperTimes(average=average) #use average or median		if season in self.medianNonTaperTimes:			if event=='all':				return self.medianNonTaperTimes[season]			if event in self.medianNonTaperTimes[season]:				return self.medianNonTaperTimes[season][event]		if not season=='all':			return None		if not event=='all' and season=='all':			events=[]			for season in self.medianNonTaperTimes:				if event in self.medianNonTaperTimes[season]:					events.append(self.medianNonTaperTimes[season][event])			return events		return self.medianNonTaperTimes	def findMedianNonTaperTimes(self,average=False):		for season in self.nonTaperTimes:			self.medianNonTaperTimes[season]={}			for event in self.nonTaperTimes[season]:				if average:					self.medianNonTaperTimes[season][event]=np.average(self.nonTaperTimes[season][event])				else:					self.medianNonTaperTimes[season][event]=np.median(self.nonTaperTimes[season][event])	def getImprovement(self):		if not self.improvement: self.findImprovement()		return self.improvement#negative means you got faster!	def findImprovement(self,seasons='all'):		self.improvement={}		self.improvementTimes={}		self.findMedianTaperTimes()		if seasons=='all': seasons=self.events.keys()		for season in self.medianTaperTimes:			nextSeason=season+1			if nextSeason in self.medianTaperTimes:				self.improvement[nextSeason]={}				self.improvementTimes[nextSeason]={}				for event in self.medianTaperTimes[season]:					if event in self.medianTaperTimes[nextSeason]:						self.improvement[nextSeason][event]=self.medianTaperTimes[nextSeason][event]/self.medianTaperTimes[season][event]-1						self.improvementTimes[nextSeason][event]=(self.medianTaperTimes[nextSeason][event],self.medianTaperTimes[season][event])	def printImprovement(self):		if not self.improvement: self.findImprovement()		for season in self.improvement:			print season			for event in self.improvement[season]:				print event,round(self.improvement[season][event],3)*100	def getAverageImprovement(self,oneSeason=None):		#print season		#print self		#print self.averageImprovement		if oneSeason==None and self.totalAverageImprovement: return self.totalAverageImprovement		if oneSeason in self.averageImprovement: return self.averageImprovement[oneSeason]		if not self.improvement: self.findImprovement()		if not self.improvement: return None #well we didn't find anything		countTotal=0		averageTotal=0		for season in self.improvement:			countSeason=0			averageSeason=0			for event in self.improvement[season]:				countTotal+=1				averageTotal=(averageTotal*(countTotal-1)+self.improvement[season][event])/countTotal				countSeason+=1				averageSeason=(averageSeason*(countSeason-1)+self.improvement[season][event])/countSeason			self.averageImprovement[season]=averageSeason		self.totalAverageImprovement=averageTotal		if oneSeason==None: return averageTotal		if oneSeason in self.averageImprovement: return self.averageImprovement[oneSeason]		return None	def assignRest(self): #assigns rest to all swims that I've done		self.getMedianTaperTimes()		for season in self.medianTaperTimes:			for event in self.medianTaperTimes[season]:				for swim in self.events[season][event]:					if swim.diving:	#we will allow for swimming divers						continue					swim.rest=self.medianTaperTimes[season][event]/swim.time	def findTopTimes(self,startDate='',endDate='',events='all'):		if not startDate: startDate=Season().start		if not endDate: endDate=Season().end		topSwims={}		if events=='all':			eventLoop=self.events[Season(startDate)]		else:			eventLoop=events		for event in eventLoop:			for swim in events[Season(startDate).name][event]:				if topSwims[event]==None or topSwims[event].time > swim.time:					topSwims[event]=swim		return topSwims	def taper(self,event,season=None,debug=False,justTime=False):		if not season:			season=Season()		lastNon=self.getMedianNonTaperTimes(season-1,event)		thisNon=self.getMedianNonTaperTimes(season,event)		lastTaper=self.getMedianTaperTimes(season-1,event)		if debug:			print lastNon			print thisNon			print lastTaper		if lastNon and thisNon and lastTaper:			change=.515*(thisNon/lastNon-1)*.995			time = lastTaper*(change+1)		elif lastTaper:			time = lastTaper*.995		elif not thisNon:			return None		else:			time = thisNon*.96		if justTime: return time		return Swim(name=self.name,team=self.team,event=event,time=time,gender=self.gender,year=self.year)	def getTimeVariance(self,cutoff=1,tapers=True):		times={}		if tapers==True: swims=self.events		else: swims=self.taperTimes		for season in swims:			for event in swims[season]:				times[event]=[]				for swim in swims[season][event]:					times[event].append(swim)		var=[]		for event in times:			if len(times[event])<cutoff: continue			mean=sum(times[event])/len(times[event])			var.append((self.name,mean,event,np.std(times[event]),len(times[event])))		return var	def __str__(self):		return self.name	def __eq__(self,s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name	def __hash__(self):		return hash(self.name)'''a probabilistic time'''class TimeProb:	def __init__(self, median, standardDeviation):		self.mu=median		self.sigma=standardDeviation	def intervals(self, number): #finds percentage intervals		return	def sample(self):		return self.mu + self.sigma*2.171^np.rand()	def __lt__(self, time): #gaussian transform		myTime=self.sample()		if type(time)==type(self):			otherTime=time.sample		return myTime<otherTime	def __gt__(self, time):		myTime=self.sample()		if type(time)==type(self):			otherTime=time.sample		return myTime>otherTime	def __str__(self):		print str(self.mu)+'+-'+str(self.sigma)'''stores a team's data'''class Team:	def __init__(self,name):		self.name=name		self.swimmers={}		self.meets={}		self.topDuals={} #cache top duals		self.averageImprovement={}		self.averageTaper=None		self.totalAverageImprovement=None	def addSwimmer(self,swimmer):		for season in swimmer.events:			if not self.swimmers.has_key(season):				self.swimmers[season]=set()			self.swimmers[season].add(swimmer)	def addMeet(self,meet):		if not meet.season in self.meets:			self.meets[meet.season]={}		self.meets[meet.season][meet.name]=meet	def topDual(self,season,debug=False,includeEvents=set()):		if debug: print self.name		if self.topDuals.has_key(season):			if debug: print 'cached'			return self.topDuals[season]		#now we will swim the season's meets against each other		topMeet=None		if not season in self.meets:			return None		for meet in self.meets[season].values():			if not meet.isDual(): continue			if debug: print 'testing '+meet.name			if topMeet==None:				topMeet=meet				continue			result=database.swimMeet([[self.name,topMeet,'old'],[self.name,meet,'new']],includeEvents=includeEvents,selectEvents=True) #token names			score=result.teamScores()			if debug:				print score				result.printout()			if score and score[0][0]=='new':				topMeet=meet			for event in meet.eventSwims: #return team names of swims				for swim in meet.eventSwims[event]:					swim.scoreTeam=None		self.topDuals[season]=Meet()		if topMeet==None:			return None		swims=topMeet.getSwims(self.name)		for swim in swims:			swim.scoreTeam=swim.team		self.topDuals[season].addSwims(swims)		if debug: print 'top '+self.topDuals[season].name		return self.topDuals[season]	def getAverageImprovement(self,season=None):		if season==None and self.totalAverageImprovement: return self.totalAverageImprovement		elif season in self.averageImprovement: return self.averageImprovement		countTotal=0		averageTotal=0		for season in self.swimmers:			#print 'a-----------------------------------------------'			#print season			countSeason=0			averageSeason=0			for swimmer in self.swimmers[season]:				#print '-------------------'				#print swimmer				improvement=swimmer.getAverageImprovement(season)				if improvement:					countTotal+=1					averageTotal=(averageTotal*(countTotal-1)+improvement)/countTotal					countSeason+=1					averageSeason=(averageSeason*(countSeason-1)+improvement)/countSeason			self.averageImprovement[season]=averageSeason		self.totalAverageImprovement=averageTotal		if season==None: return averageTotal		if season in self.averageImprovement: return self.averageImprovement[season]		return None	def getAverageTaper(self,season='all',top=False):		if self.averageTaper: return self.averageTaper		count=0		average=0		if season=='all':			for season in self.swimmers:				for swimmer in self.swimmers[season]:					tapers=swimmer.getTapers(top=top)					for season in tapers:						for event in tapers[season]:							average=(average*count+tapers[season][event])/(count+1)							count=count+1		return average	def __str__(self):		return self.name	def __eq__(self, s):		if self.name == s:			return True		if not type(s)==type(self): return False #not called on a season		return self.name==s.name	def __hash__(self):		return hash(self.name)class Conference:	def __init__(self,name,division=None,teams=set()):		self.division = division		self.teams = teams		self.name = name	def addTeam(self,team):		self.teams.add(team)'''a type representing the dates of a swim season'''class Season:	def __init__(self,d=date.today()):		if type(d)==type('') or type(d)==type(1):			year=int(d)			if year<100: #allow for '13 to be 2013				year=year+2000		elif d>date(d.year,4,1):			year=d.year		else:			year=d.year-1		self.year=year		self.start=date(year,9,1) #start sept 1, 13->2013-2014		self.end=date(year+1,4,1) #end april 1		self.name=str(self.start.year)+' - '+str(self.end.year)	def previous(self):		return Season(self.year-1)	def next(self):		return Season(self.year+1)	def __contains__(self,date):		if date>=self.start and date<=self.end:			return True		return False	def __hash__(self):		return hash(self.start)	def __sub__(self,n):		return Season(self.year-n)	def __add__(self,n):		return Season(self.year+n)	def __str__(self):		return self.name	def __eq__(self,s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name'''meet is a meet of swimmers, will predict results'''class MetaMeet:	def __init__(self,events=eventsDualS):		self.events=events		self.swimmers=set()		self.eventSwims={}		self.placePredictions={}		self.scorePredictions={}		self.teams=set()	def addSwimmer(self,swimmer,event=None):		if event:			if not event in self.eventSwims:				self.eventSwims[event]=set()			self.eventSwims[event].add(swimmer)		self.swimmers.add(swimmer)		self.teams.add(swimmer.team)	def place(self,events='all',date=date.today()):		if not self.eventSwims: #have to determine the swimmer's events			return		for event in self.eventSwims:			times={}			for swimmer in self.eventSwims[event]:				times[swimmer]=swimmer.swim(event,date)				self.placePredictions[event]=self.predictPlaces(times)		#now place relays	def score(self,dual=True,heatSize=8):		events=self.events		if dual:			max=3			pointsI=[9,4,3,2,1]			pointsR=[11,4,2]		elif heatSize==8:			max=16			pointsI = [20,17,16,15,14,13,12,11,9,7,6,5,4,3,2,1]			pointsR = [40,34,32,30,28,26,24,22,18,14,12,10,8,6,4,2]		elif heatSize==6:			pointsI = [15,13,12,11,10,9,7,5,4,3,2,1]			pointsR = [x*2 for x in pointsI]		self.predictPlaces(events)		for event in self.placePredictions:			for swimmer in self.placePredictions[event]:				avgScore=[pointsI[i]*self.placePredictions[event][swimmer][i] for i in range(len(pointsI))]	def teamScores(self):		pass	def predictPlaces(self,swims,num=4): #returns double array with 1st prob, swimmer 1, 2nd prob swimmer 1, ...		#subdivide into n/100% probability intervals, but median?		#relays?		'''		probs={}		for swim1 in swims:			probs[swim1]=[]			times=swims[swim1].intervals(num)			for time in times: #sampling size				for swim2 in swims-swim1:					#win=erf(swim2[time					length=len(probs)					winP=probs*win					winP.append(0)					loseP=probs*(1-win)					loseP.insert(0,0)					newProbs=[[winP[i]+loseP[i]] for i in range(len(winP))]				probs[swim1]=[probs[swim1][i]+newProbs[i]/len(times) for i in range(len(newProbs))]		return probs		''''''this class contains a swim meetscores itself'''class Meet:	def __init__(self, swim=None, events=allEvents):		self.teams=[]		self.teamRest={}		self.eventRest={}		self.rest=0		self.isTaper=False		self.scores=None		self.eventSwims={}		self.eventSwimsPrelims={}		self.eventSwimsFinals={}		self.events=events		if swim:			self.name=swim.meet			self.date=swim.date			self.season=swim.season		else:			self.name=None			self.date=None			self.season=None	def averageRest(self):		count={}		for team in self.teams:			self.teamRest[team]=0			count[team]=0			count['total']=0		for event in self.eventSwims:			self.eventRest[event]=0			count[event]=0			for swim in self.eventSwims[event]: #running average				if not swim.rest or swim.rest==0:					continue				self.teamRest[swim.team]=(self.teamRest[swim.team]*count[swim.team]+swim.rest)/(count[swim.team]+1)				self.eventRest[event]=(self.eventRest[event]*count[event]+swim.rest)/(count[event]+1)				self.rest=(self.rest*count['total']+swim.rest)/(count['total']+1)				count[swim.team]+=1				count[event]+=1				count['total']+=1	def averageTimes(self):		self.averageTime={}		for event in self.eventSwims:			self.averageTime[event]=0			count=0			for swim in self.eventSwims[event]:				self.averageTime[event]=(self.averageTime[event]*count+swim.time)/(count+1)				count=count+1	def printRest(self):		self.averageRest()		print self.name,self.season		for team in self.teamRest:			if self.teamRest[team]!=0:				print '\t'+team				print '\t'+str(self.teamRest[team])		print	def eventVariance(self):		timeVar={}		self.place()		for event in self.eventSwims:			average=0			count=0			for i in range(len(self.eventSwims[event])-1):				timeDif=abs(self.eventSwims[event][i].time-self.eventSwims[event][i+1].time) #time dif between this and next place				average=(average*count+timeDif)/(count+1) #running average				count+=1			timeVar[event]=average		return timeVar	#check if a particular swim is already in the meet	def hasSwim(self,newSwim):		if self.eventSwims.has_key(newSwim.event):			for swim in self.eventSwims[newSwim.event]:				if swim is Relay or swim.relay:					if swim.getScoreTeam()==newSwim.getScoreTeam():						return True				elif swim.name==newSwim.name and swim.getScoreTeam()==newSwim.getScoreTeam():					return True		return False	def isDual(self):		if 'Dual' in self.name: return True		if len(self.teams)>2: return False		if '1650 Yard Freestyle' in self.eventSwims: return False		return True	#checks to see if a swimmer is in a particular event	def hasRace(self,swimmer,event):		if not event in self.eventSwims: return False		for swim in self.eventSwims[event]:			if swim.name==swimmer:				return swim		return False	#sees if any swims are in the meet	def isEmpty(self):		for event in self.eventSwims:			if not self.eventSwims[event]==[]:				return False		return True	def removeSwimmer(self, name):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.name==name:					self.eventSwims[event].remove(swim)	#adds a possbily existing swimmer and event keeping the faster of the two	def addDupSwim(self, newSwim):		if self.hasSwim(newSwim):			if not newSwim.relay:				for swim in self.eventSwims[newSwim.event]:					if swim.name==newSwim.name and swim.getScoreTeam()==newSwim.getScoreTeam():						if swim.diving:							if swim.time < newSwim.time:								self.eventSwims[swim.event].remove(swim)								self.addSwim(newSwim)						else:							if swim.time > newSwim.time:								self.eventSwims[swim.event].remove(swim)								self.addSwim(newSwim)						return			else:				for swim in self.eventSwims[newSwim.event]:					if swim.getScoreTeam()==newSwim.getScoreTeam():						if swim.time > newSwim.time:							self.eventSwims[swim.event].remove(swim)							self.addSwim(newSwim)						return		else:			self.addSwim(newSwim)	def getSwims(self, team='all', relays=True, splits=False, ind=True):		swims=set()		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if ind and (swim.team == str(team) or team=='all') and (relays or not swim.relay):					swims.add(swim)				if splits and swim.relay and (team=='all' or swim.team == str(team)):					for split in swim.swims:						swims.add(split)		return swims	def addSwim(self, swim):		#if self.events and not swim.event in self.events:		#	return		#print swim		if not swim.getScoreTeam() in self.teams:			self.teams.append(swim.getScoreTeam())		if not self.name or not self.date or not self.season:			self.name=swim.meet			self.date=swim.date			self.season=swim.season		if not self.eventSwims.has_key(swim.event):			self.eventSwims[swim.event]=[]		self.eventSwims[swim.event].append(swim)	def addSwims(self, swims):		for swim in swims:			self.addSwim(swim)	def addDupSwims(self, swims):		for swim in swims:			self.addDupSwim(swim)	def getEvents(self, events='', prelims=False):		if prelims:			allEvents=set(self.eventSwimsPrelims.keys())		else:			allEvents=set(self.eventSwims.keys())		if events=='':			if self.events==None:				events=allEvents			else: events=self.events		events=set(events)&set(allEvents)		return events	'''	decides top events for each swimmer	top swimmers are decided by highest scoring event right now	unlimited divers	'''	def topEvents(self, teamMax=17, indMax=3, totalMax=8, events=''):		self.place()		conference=Meet()		indSwims={}		relaySwims={}		teamSwimmers={}		teamDivers={}		drops=[]		relayEvents=set()		events=self.getEvents(events)		for team in self.teams:			teamSwimmers[team]=0			teamDivers[team]=0		for event in events: #we will keep relays as is, but count them towards total swims			if re.search('Relay',event):				while not self.eventSwims[event]==[]:					relay=self.eventSwims[event].pop()					conference.addSwim(relay)					if type(relay)==Relay:						for swim in relay.swims:							if swim.name in relaySwims:								relaySwims[swim.name]+=1							else:								relaySwims[swim.name]=1				relayEvents.add(event)		for event in relayEvents:			events.remove(event)		#now make sure that each person swims their top events		preEvent=None		nextEvent=None		while not self.isEmpty():			for event in events:				drop=True #just allow us to enter the loop				while drop==True and not self.eventSwims[event]==[]:#we need to loop on an event until we find someone who is actually in it					drop=False					if self.events and type(self.events)==type([]):						if not self.events.index(event)==0:							preEvent=self.events[self.events.index(event)-1]						if not self.events.index(event)==len(self.events)-1:							nextEvent=self.events[self.events.index(event)+1]					newSwim=self.eventSwims[event].pop(0)					if newSwim.diving:						conference.addSwim(newSwim)						teamDivers[newSwim.getScoreTeam()]+=1						continue					if preEvent in conference.eventSwims:						for swim in conference.eventSwims[preEvent]:							if newSwim.name==swim.name:								drops.append(newSwim)								drop=True								break					if nextEvent in conference.eventSwims:						for swim in conference.eventSwims[nextEvent]:							if newSwim.name==swim.name:								drop=True								drops.append(newSwim)								break					if drop: #already swimming previous or next event						continue					if not newSwim.name in indSwims: #fixed to still add swim when all 18 swimmers there						if teamSwimmers[newSwim.getScoreTeam()] < teamMax:							indSwims[newSwim.name]=0							teamSwimmers[newSwim.getScoreTeam()]+=1						else:							drops.append(newSwim)							continue					if indSwims[newSwim.name]<indMax and ((not newSwim.name in relaySwims) or indSwims[newSwim.name]+relaySwims[newSwim.name] < totalMax):						conference.addSwim(newSwim)						indSwims[newSwim.name]+=1					else:						drops.append(newSwim)						drop=True #can't swim any more events		self.eventSwims=conference.eventSwims		return drops	'''	adds top relays using same method in database	'''	def addTopRelays(self,number,team,database):		relays = [event for event in self.events if re.search('Relay',event)]		return database.topRelays(relays,team,self)	'''	creates the best lineup for the given team against another set lineup	no two person swapping instabilities	->must implement relay creation and switching	'''	def lineup(self, team, database=None, debug=False, splits=False):		team=str(team)		#take top three relays in each event		if database:			dropSplits = self.addTopRelays(3, team, database)			dropSplits = [split for split in dropSplits if split.split]		drops=self.topEvents(30, 3, 4)		self.place()		'''		now we have a starting point		'''		extras = {}  # double dictionary,swim:event		for swim in drops + dropSplits:			if not swim.name in extras:				extras[swim.name] = {}			extras[swim.name][swim.event]=swim		toCheck = self.getSwims(team, False, splits=splits)		while len(toCheck) > 0:  # double loop on all swims, trying to see if more points are scored if swapped			swim1=toCheck.pop()			swims=self.getSwims(team, False, splits=splits)			while len(swims) > 0:				swim2=swims.pop()				if swim1==swim2 or swim1.event==swim2.event:					continue				#make sure swims exist				if extras.has_key(swim2.name) and extras.has_key(swim1.name) and extras[swim1.name].has_key(swim2.event) and extras[swim2.name].has_key(swim1.event):					self.score()					if debug:						print self.score()						print team					oldScore = self.teamScores(sorted=False)[team]  # [swim1.event,swim2.event]					(newSwim1, newSwim2) = self.swap(swim1, swim2, extras)					self.score()					newScore = self.teamScores(sorted=False)[team] # [swim1.event,swim2.event]					if oldScore < newScore: # swap in new swims						if debug:							print "swap"							print newSwim1.name, newSwim1.event							print newSwim2.name, newSwim2.event						swims.add(newSwim1)						swims.add(newSwim2)						if swim1 in swims:							swims.remove(swim1)						if swim2 in swims:							swims.remove(swim2)						if newSwim1.split: #re-add swims in those events							for relay in self.eventSwims[newSwim1.fromRelay]:								if relay.team==team:									for split in relay.swims:										if not split in toCheck:											toCheck.add(split)						else:							for swim in self.eventSwims[newSwim1.event]:								if not swim in toCheck and swim.team==team:									toCheck.add(swim)						if newSwim1.split: #re-add swims in those events							for relay in self.eventSwims[newSwim1.fromRelay]:								if relay.team==team:									for split in relay.swims:										if not split in toCheck:											toCheck.add(split)						else:							for swim in self.eventSwims[newSwim1.event]:								if not swim in toCheck and swim.team==team:									toCheck.add(swim)						if swim2 in toCheck: #make sure second swim is not checked again							toCheck.remove(swim2)						swim1=toCheck.pop() #start checking next swim					else: # revert to old lineup						self.swap(newSwim1,newSwim2,extras)		self.score()	'''	given two old swims	will swap two swims, returns two new swims	'''	def swap(self,swim1,swim2,extras):		newSwim1=extras[swim1.name][swim2.event]		newSwim2=extras[swim2.name][swim1.event]		if self.eventSwims.has_key(swim2.event) and swim2 in self.eventSwims[swim2.event]: # ind swim			self.eventSwims[swim2.event].remove(swim2)			self.addSwim(newSwim1)		else: #gotta be a relay			self.relaySwap(swim2,newSwim1)		if self.eventSwims.has_key(swim1.event) and swim1 in self.eventSwims[swim1.event]: # ind swim			self.eventSwims[swim1.event].remove(swim1)			self.addSwim(newSwim2)		else: #gotta be a relay			self.relaySwap(swim1,newSwim2)		if not extras.has_key(swim1.name):			extras[swim1.name]={}		extras[swim1.name][swim1.event]=swim1		if not extras.has_key(swim2.name):			extras[swim2.name]={}		extras[swim2.name][swim2.event]=swim2		return (newSwim1,newSwim2)	'''	swaps someone into a relay	given old (swim1) and new (swim2) split	'''	def relaySwap(self,swim1,swim2):		for relay in self.eventSwims[swim1.fromRelay]:			if swim1 in relay.swims:				relay.changeSwimmer(swim1,swim2)				return	def taper(self):		for event in self.eventSwims:			for swim in self.eventSwims[event]:				swim.taper()	'''	places the meet	'''	def place(self, events='', storePlace=False):		events=self.getEvents(events)		for event in events:			if not event in self.eventSwims: continue			if not self.eventSwims[event][0].diving:				self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=False)			else:  #diving				self.eventSwims[event] = sorted(self.eventSwims[event], key=lambda Swim:Swim.getScoreTime(), reverse=True)			if storePlace:				for idx, swim in enumerate(self.eventSwims[event]):					swim.place = idx+1	'''	scores the meet	'''	def score(self,prelims=False,dual='Unknown',events='',heatSize=8,heats=2,debug=False):		events=self.getEvents(events)		if debug: print events		if dual =='Unknown':			if len(self.teams)==2: dual=True			else: dual=False		self.place(events)		max=16		if heats==3:			pointsI=[32,28,27,26,25,24,23,22,20,17,16,15,14,13,12,11,9,7,6,5,4,3,2,1]		elif heats==2:			pointsI = [20,17,16,15,14,13,12,11,9,7,6,5,4,3,2,1]		if heatSize==6:			pointsI = [15,13,12,11,10,9,7,5,4,3,2,1]		pointsR = [x*2 for x in pointsI]		if dual:			max=3			pointsI=[9,4,3,2,1]			pointsR=[11,4,2]		if prelims and not dual:			self.runPrelims('all',heatSize,2)			for event in events:				if not event in self.eventSwimsFinals[event]:					continue				for heat in self.eventSwimsFinals[event]:					self.scoreHeat(heat,heatSize,pointsI,pointsR)			return self.teamScores(events)		for event in self.eventSwims: #Assign scores to the swims			if not event in events and self.eventSwims[event]: #set score of those not being swum to zero				for swim in self.eventSwims[event]:					swim.score=0			if debug: print 'scoring',event			if re.search('Swim-off',event): #if event is not being swum, no points				continue			place=1			teamSwims={}			for swim in self.eventSwims[event]:				swim.score=None #reset score				if not swim.relay:					team=swim.getScoreTeam()					if place>len(pointsI) or (teamSwims.has_key(team) and not swim.diving and teamSwims[team]>=max):						swim.score=0					else:						swim.score=pointsI[place-1]						if not teamSwims.has_key(team):							teamSwims[team]=0						teamSwims[team]+=1						place+=1				else:					team=swim.team					if place>len(pointsR) or (teamSwims.has_key(team) and teamSwims[team]>=max):						swim.score=0					else:						swim.score=pointsR[place-1]						if not teamSwims.has_key(team):							teamSwims[team]=0						teamSwims[team]+=1						place+=1		return self.teamScores(events)	def teamScores(self,events='',sorted=True):		events=self.getEvents(events)		teams={}		for event in events:			if not event in self.eventSwims: continue			for swim in self.eventSwims[event]:				team=swim.getScoreTeam()				if not teams.has_key(team):					teams[team]=0				teams[team]=swim.getScore()+teams[team]		if not sorted:			return teams		scores=[]		for team in teams:			scores.append([team,teams[team]])		scores.sort(key=lambda team: team[1],reverse=True)		self.scores=scores		return scores	def winningTeam(self):		if not self.scores: self.teamScores()		if len(self.scores)<1 or len(self.scores[0])<1: return None		return self.scores[0][0]	'''	lists swimmers by team and by points scored	'''	def scoreReport(self, printout=True, repressSwim=False, repressTeam=False):		scores={}		for team in self.teams:			scores[team]={'total': 0, 'year': {}, 'swimmer': {}, 'event': {}}		for event in self.eventSwims:			for swim in self.eventSwims[event]:				if swim.relay:					name = 'Relays'				else:					name = swim.name				if repressSwim and swim.score == 0:					continue   # repess zero scores				if not name in scores[swim.team]['swimmer']:					scores[swim.team]['swimmer'][name] = 0				if not event in scores[swim.team]['event']:					scores[swim.team]['event'][event]=0				scores[swim.team]['swimmer'][name] += swim.score				scores[swim.team]['total'] += swim.score				scores[swim.team]['event'][event] += swim.score				if swim.year:					if not swim.year in scores[swim.team]['year']:						scores[swim.team]['year'][swim.year] = 0					scores[swim.team]['year'][swim.year] += swim.score		if printout:			for team in sorted(scores['swimmer'],key=scores['swimmer']['total']):				print '-------------------------------'				print team				for name in sorted(scores['swimmer'][team], key=scores['swimmer'][team].__getitem__):					print name.join(scores['swimmer'][team][name].ljust(25))		if repressTeam:			zeroTeams=set()			for team in scores:				if scores[team]['total'] == 0:					zeroTeams.add(team)			for team in zeroTeams:				del(scores[team])		return scores	'''	a printout for D3	'''	def printout2(self):		for event in self.eventSwims:			print			print event			print "==============================================="			for swim in self.eventSwims[event]:				if not swim.diving:					time=swimTime(swim.time)				else:					time=str(swim.time)				if swim.score:					print swim.name+'---'+swim.team+'---'+time+'---'+str(swim.score)				else:					print swim.name+'---'+swim.team+'---'+time		if not self.eventSwims[event]==[] and not swim.score==None:			print self.teamScores()	def printout(self, events=''):		events=self.getEvents(events)		for event in events:			if event not in self.eventSwims: continue			print "-------------------------------------------------------------------------------------"			print "Event: " + event			for swim in self.eventSwims[event]:				if swim.score:					print swim.printScore().lstrip()+"\t"+str(swim.score)				else:					print swim.printScore().lstrip()		print self.scores	def scoreString(self, showNum='all', showScores=True, showPlace=False):		self.score()		string = {}		events=self.getEvents('')		for event in events:			if event not in self.eventSwims: continue			string[event]=[]			place = 0			for swim in self.eventSwims[event]:				place += 1				if not showNum=='all' and place > showNum:					break				swimAry = re.split('\t', swim.printScore(gender=False).strip())				if showPlace:					swimAry.insert(0, place)				if swim.score and showScores:					swimAry.append(str(swim.score))					string[event].append(swimAry)				else:					string[event].append(swimAry)		string["scores"]=self.teamScores()		return string	def __str__(self):		return self.name	def __eq__(self, s):		if not type(s)==type(self): return False #not called on a season		return self.name==s.name and self.date==s.date	def __hash__(self):		return hash(self.name)^hash(self.date)'''used to load the database into local memorynow used to make and swim fantasy meetsloaded in using a tab separated database file'''class SwimDatabase:	def __init__(self, fileName, gender, homeDir=None): #gender split perhaps done in the parsing later,	# for now 2 databases		self.conferences={}		self.homeDir=homeDir		self.gender=gender		self.swims=set()		self.meets={}		self.teams={}		self.swimmers={}		if not fileName=='':			self.load(fileName)	def loadDir(self, root='./USSwimmingData', years='all', conferences='all', events='all',debug=False):		for conf in os.listdir(root): #should be storing in seperate files per meet, per gender			if conf[0]=='.':continue #don't use ref files			if conf in conferences or conferences=='all':				for year in os.listdir(root+'/'+conf):					if year[0]=='.':continue					if year in years or years=='all':						for file in os.listdir(root+'/'+conf+'/'+year):							if debug: print file							if file[0]=='.':continue							#fileParts=re.split('_',file)							#gender=fileParts[1]							#distance=fileParts[2]							#stroke=fileParts[3]							self.load(root+'/'+conf+'/'+year+'/'+file,conf)		def load(self, fileName, conference=None):  # this is called once for each file!!!!!!		if conference and not self.conferences.has_key(conference):			self.conferences[conference]=set()		with open(fileName) as file:			for line in file:				newSwim = Swim(line)				if not newSwim.gender==self.gender:  # still works as a double check					continue				if not newSwim.meet in self.meets:					newMeet = Meet(newSwim)					self.meets[newSwim.meet] = newMeet				if conference and not newSwim.team in conference:					self.conferences[conference].add(newSwim.team)				if newSwim.relay:  # Relay Time					newRelay = Relay(line)					self.swims.add(newRelay)					self.meets[newSwim.meet].addSwim(newRelay)				else:					self.meets[newSwim.meet].addDupSwim(newSwim)					self.swims.add(newSwim)					if not newSwim.name in self.swimmers:						self.swimmers[newSwim.name]=Swimmer(newSwim)					self.swimmers[newSwim.name].addSwim(newSwim)		for swimmerName in self.swimmers:			swimmer=self.swimmers[swimmerName]			if not self.teams.has_key(swimmer.team):				self.teams[swimmer.team]=Team(swimmer.team)			self.teams[swimmer.team].addSwimmer(swimmer)		for meet in self.meets.values():			for team in meet.teams:				if not team in self.teams:					self.teams[team] = Team(team)				self.teams[team].addMeet(meet)	def assignRest(self):		for swimmer in self.swimmers.values():			swimmer.assignRest()		for meet in self.meets.values():			meet.averageRest()	def totalRest(self):		teams={}		events={}		count={}		eventsPM={} #plus/minus the average rest for a meet		countPM={}	#wieghted average for events w/ more swims		eventsPMlist={}		meetr={}		for meet in self.meets.values():			if meet.rest==0:				continue			for team in meet.teamRest:				if meet.teamRest[team]==0 or meet.teamRest[team]==1:					continue				if not teams.has_key(team):					teams[team]=0					count[team]=0				teams[team]=(teams[team]*count[team]+meet.teamRest[team])/(count[team]+1)			for event in meet.eventRest:				if meet.eventRest[event]==0 or meet.eventRest[event]==1:					continue				if not events.has_key(event):					events[event]=0					count[event]=0					eventsPM[event]=0					countPM[event]=0					eventsPMlist[event]=[]				eventsPM[event]=(eventsPM[event]*countPM[event]+(meet.eventRest[event]-meet.rest)*len(meet.eventSwims[event]))/(count[event]+len(meet.eventSwims[event]))				eventsPMlist[event].append(meet.eventRest[event]-meet.rest)				events[event]=(events[event]*count[event]+meet.eventRest[event])/(count[event]+1)		#run a T-test?		for team in teams:			print team			print teams[team]		print		for event in events:			print event			print eventsPM[event]			#print eventsPMlist[event]			print	def topDual(self, season=Season(), events=requiredEvents, printout=True, teams='all'):		if teams == 'all':			teams = self.teams		meets={} #replace with a set		results={} #right now we double up, easier to count at end		wins={}		losses={}		for team in teams:			if not self.teams[team].topDual(season) or team=='&nbsp;': continue			if team in self.teams and self.teams[team].topDual(season): #team exists and has swum a meet this season				meets[team]=self.teams[team].topDual(season)				wins[team]=0				losses[team]=0				if printout: print team,'\t\t',meets[team]		if printout: print '-----------'		for team1 in meets:			for team2 in meets:				if team1==team2: continue				if not team1 in results:					results[team1]={}				if not team2 in results:					results[team2]={}				if team2 in results[team1] or team1 in results[team2]: #reverse meet already swum					continue				newMeet=self.swimMeet([[team1,meets[team1]],[team2,meets[team2]]],includeEvents=events,									  selectEvents=False) #should convert to dual form				results[team1][team2]=newMeet				results[team2][team1]=newMeet				#if team1 == 'Hawaii (M)' and team2 == 'Bard' or team2=='Bard' and team1=='Hawaii (M)':				#    newMeet.printout()				if results[team1][team2].winningTeam() == team1: #team1 wins					wins[team1]+=1					losses[team2]+=1				elif results[team1][team2].winningTeam() == team2: #team2 wins, otherwise no points					wins[team2]+=1					losses[team1]+=1		i=1		if printout:			for team in sorted(wins.items(),key=operator.itemgetter(1),reverse=True): #sort based off of the number of wins				print str(i)+'.',team[0]+':',team[1],'-',losses[team[0]]				i+=1		return (results,meets,wins,losses)	'''	gives the top number of swims done in events done by a team	duplicates if a person can swim more than one top event	'''	def topSwims(self, event, team, number):		topTimes=Meet()		top=[]		for swim in self.swims:			if swim.team == team and swim.event==event and swim.date > date(2012,6,1):				topTimes.addDupSwim(swim)		if not event in topTimes.eventSwims:			 return []		topTimes.place(set(event))		for i in range(len(topTimes.eventSwims[event])):			if not number=='all' and i > number:				break			top.append(topTimes.eventSwims[event][i])		return top	#creates a swim meet with given teams and meets format is [(team1,meet1),(team2,meet2),...]	def swimMeet(self,teamMeets, usePrelim=False, diving=True, debug=False, includeEvents='all', excludeEvents=set(),				 selectEvents=True, resetTimes=False):		meet=Meet()		teams=set()		if includeEvents=='all':			includeEvents=allEvents		commonEvents=allEvents		for teamMeet in teamMeets:			newTeamName=None			newTeam=teamMeet[0]			newMeet=teamMeet[1]			commonEvents=commonEvents & set(newMeet.eventSwims.keys())			if debug: print set(newMeet.eventSwims.keys())			if len(teamMeet)==3:				newTeamName=teamMeet[2]			swims=newMeet.getSwims(newTeam)			for swim in swims:				if usePrelim:					swim.finals=True				if newTeamName:					swim.scoreTeam=newTeamName				elif newTeam in teams: #duplicate team and no new name specified					swim.scoreTeam=swim.team+' '+str(swim.date.year)				meet.addDupSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		if len(meet.teams)==2:			if selectEvents: meet.topEvents(25,3,4)			meet.events=(commonEvents | includeEvents) - excludeEvents			meet.score(dual=True,events=meet.events)		else:			if selectEvents: meet.topEvents()			meet.score()		if debug: meet.printout()		return meet	#lineup creator	def lineup(self, teams, meet, season=Season(date.today()), debug=False, resetTimes=False, events=eventsDualS):		meet.events = events		if debug:			print meet.getEvents(), events		for swim in self.swims:			if str(swim.team) in teams and swim.date in season and not swim.relay and swim.event in events:				meet.addDupSwim(swim)		if resetTimes:			for swim in meet.getSwims():				swim.scoreTime = swim.time		meet.place()		if debug:			meet.printout()		if len(teams) == 1:			meet.lineup(teams.pop(), self, debug=debug)		else:			meet.topEvents(17, indMax=3, totalMax=4)		return meet	#returns the last swim meet a team was in	def getLastMeet(self, teams):		lastMeet=None		for meet in self.meets:			if contains(teams,self.meets[meet].teams) and (lastMeet==None or lastMeet.date < self.meets[meet].date):				lastMeet=self.meets[meet]		return lastMeet	#finds a meet with given criteria	def getMeet(self, teams, season, date=None):		for meet in self.meets[season.name]:			if date and (meet.date>date(date.year,date.month,date.day+10) or meet.date<date(date.year,date.month,date.day+10)):				continue			for team in teams:				if not team in meet.teams:					continue			return meet		return None	'''	creates top relays from all splits	returns either dropped swims if meet input or relays	'''	def topRelays(self,events,team,meet=None):		relays=[]		drops=[]		for event in events:			topSplits=Meet()			if re.search('Relay',event):				for leg in list(set(relayEvents(event))):					splits=self.topSwims(leg,team,'all')					if splits == None:						break					topSplits.addSwims(splits)				if splits == None:					break				if topSplits.eventSwims.values() == []:					continue				if re.search('Medley Relay',event):					numRelays = min(3,min(map(len,topSplits.eventSwims.values()))) #min of 3 and number of swimmers					for i in range(numRelays):						legs=[]						for leg in relayEvents(event):							legs.append(topSplits.eventSwims[leg].pop(0))						legs.append(event)						relays.append(Relay(legs))				elif re.search('Freestyle Relay',event):					events = relayEvents(event)					if not events[0] in topSplits.eventSwims or not events[1] in topSplits.eventSwims:						continue					numRelays = min(3,len(topSplits.eventSwims[events[0]]),len(topSplits.eventSwims[events[1]])/3)					for i in range(numRelays):						legs=[]						legs.append(topSplits.eventSwims[events[0]].pop(0))						for i in range(numRelays):							legs.append(topSplits.eventSwims[events[1]].pop(0))						legs.append(event)						relays.append(Relay(legs))		if meet:			meet.addSwims(relays)			return [split for split in drops if split.split] #don't return 50 frees		return relays	#predicts the outcome of a swim meet	#use last two dual meets swum, not necessarily in the same format	def swimMeetPredictor(self,teams):		lastMeets={}		for team in teams:			lastMeets[team]=self.getLastMeet(team)		for team in teams:			if not lastMeets.has_key(team):				print "Not enough data!"				return		newMeet=Meet()		for team in lastMeets:			swims=lastMeets[team].getSwims(team)			for swim in swims:				newMeet.addSwim(swim)		newMeet.score(dual=True)		return newMeet	'''	year=0 is current year, looks back from there	will not double swimmers now	'''	def topTimesReport(self, events='all', teams=MIAC, season=None):		topTimes = Meet()		if not season: season=Season()  # use current season		for swim in self.swims:			if swim.season == season and (swim.team in teams or teams=='all') and ((swim.event in events) or (events ==																										   'all')):				topTimes.addDupSwim(swim)		topTimes.place()		return topTimes	def averageTimesReport(self, season=Season(), teams=MIAC, average=True):		averageSwims=Meet()		for teamName in teams:			if not teamName in self.teams: continue			for swimmer in self.teams[teamName].swimmers[season]:				averageTimes=swimmer.getMedianNonTaperTimes(season,average=average)				for event in averageTimes:					newSwim=Swim(name=swimmer.name,team=teamName,event=event,time=averageTimes[event],								 gender=swimmer.gender,season=season)					averageSwims.addSwim(newSwim)		averageSwims.place()		return averageSwims	def conference(self, teams=MIAC, taper=True, season=Season(), topTimes=False):		events=eventsChamp3		conference=Meet()		if topTimes:			for swim in self.swims:				if swim.team in teams and swim.season==season and swim.event in events:					conference.addDupSwim(swim)		else:			for teamName in teams:				if not teamName in self.teams: continue				team=self.teams[teamName]				if not season in team.swimmers: continue				for swimmer in team.swimmers[season]:					for event in eventsChamp3:						if taper:							swim = swimmer.taper(event=event, season=season)						else:							time = swimmer.getMedianNonTaperTimes(event=event, season=season)							swim = Swim(name=swimmer.name, team=swimmer.team, event=event, time=time,										gender=swimmer.gender)						if swim: conference.addSwim(swim)		conference.events=events		conference.topEvents(17)		conference.score()		return conference	#lists meets stored, years optional	def listMeets(self, years=None):		meets=[]		for meet in self.meets:			if years:				if str(meet.date.year) in years:					meets.append(meet+" - "+str(self.meets[meet].date.year))			else:				meets.append(meet+" - "+str(self.meets[meet].date.year))	'''	finds same meet from x years back	checks to see if same teams are there and meet is within 1? week from last year	'''	def getPastMeet(self, newMeet, years=1):		for meet in self.teams:			dateDif = date.today() - meet.date			if abs(dateDif.days) < 8 and dateDif.years ==  years and contains(meet.teams,newMeet.teams) and contains(newMeet.teams,meet.teams):				return meet	'''	allows filtering down by various parameters	'''	def filter(self, teams='all', swimmers='all', events='all', startDate='all', endDate='all', bestTime=False):		filterMeet=Meet()		for swim in self.swims:			if (swim.name in swimmers or swimmers=='all') and (swim.team in teams or teams=='all') and (swim.event in events or events=='all') and (startDate=='all' or swim.date > startDate) and (endDate=='all' or swim.date < endDate):				if bestTime:					filterMeet.addDupSwim(swim)				else:					filterMeet.addSwim(swim)		return filterMeet.getSwims()	'''	tests predictions	'''	def taperTest(self):		for swimmer in self.swimmers.values():			tapers = swimmer.getMedianTaperTimes()			nonTapers = swimmer.getMedianNonTaperTimes(average=False)			for season in tapers:				for event in tapers[season]:					if season in nonTapers and event in nonTapers[season]:						absDif = abs(tapers[season][event] - nonTapers[season][event])						perDif = abs(tapers[season][event] - nonTapers[season][event])/abs(tapers[season][event] +																						   nonTapers[season][event])						print swimmer.name+','+swimmer.gender+','+swimmer.team+','+event+','+str(absDif)+','+str(perDif)	def preFinalVariance(self, meetNames):		for meetName in meetNames:			meet = self.meets[meetName]			if not meet.eventSwimsPrelims: return			meet.place('all',True)			placeDif={}			timeDif={}			for event in meet.eventSwims:				placeDif[event]=[]				timeDif[event]=[]				for finalsSwim in meet.eventSwims[event]:					for prelimsSwim in meet.eventSwimsPrelims[event]:						if finalsSwim.name==prelimsSwim.name:							placeDif.append(meet.eventSwims[event].index(finalsSwim)-meet.eventSwimsPrelims[event].index(prelimsSwim))							timeDif.append(abs(prelimsSwim.time-finalsSwim.time)/((prelimsSwim.time+finalsSwim.time)/2))		''' fix with std		if not outliers: #throw away swims >2 std from mean			for event in placeDif:				av=average(placeDif[event])				stdDev=std(placeDif[event])				for dif in placeDif[event]:					if abs(dif-av)>2*stdDev:						placeDif.remove(dif)				av=average(timeDif[event])				stdDev=std(placeDif[event])				for dif in placeDif[event]:					if abs(dif-av)>2*stdDev:						placeDif.remove(dif)		'''	def taperPredictions(self, years='', teams='all', event='all', taperDate=None):		seasons=[]		if years=='': seasons.append(Season())		else:			for year in years:				seasons.append(Season(year))		if teams=='all':			teams=self.teams		taperSwims={}		for season in seasons:			for team in teams:				for swimmer in self.teams[team]:					nonTaper=swimmer.getMedianNonTaperTimes(season=season)					taper=swimmer.getMedianTaperTimes(season=season)					for event in taper:						pass	def improvement(self,conference=None): #looks at average taper to next year		allImprovement={}		for swimmer in self.swimmers:			#if (not self.swimmers[swimmer].team in self.conferences[conference]) and (conference!=None): continue			improvement=self.swimmers[swimmer].getImprovement()			if not improvement: continue			for season in improvement:				for event in improvement[season]:					if not event in allImprovement: allImprovement[event]=[]					if np.abs(improvement[season][event])<.07: allImprovement[event].append(improvement[season][event])#toss outliers		drops={}		for event in allImprovement:			avgDrop=round(np.average(allImprovement[event])*100,3)			stdAvgDrop=round(np.std(allImprovement[event])*100,3)			drops[event]=(avgDrop,stdAvgDrop)			#print event,': ',avgDrop,'+-',stdAvgDrop			#P.hist(allImprovement[event])			#P.show()		return drops	def getTopTimes(self):		topTimes={}		for swimName in self.swims:			swim = self.swims[swimName]			if not swim.event in topTimes:				topTimes[event]=swim.time			else:				if swim.time < topTimes[event]:					topTimes[event]=swim.time		return events	def improvementTimes(self, printout, division, gender):		timeDrops={}		for swimmer in self.swimmers:			self.swimmers[swimmer].findImprovement()			swimmerDrops=self.swimmers[swimmer].improvementTimes			for season in swimmerDrops:				for event in swimmerDrops[season]:					if not event in timeDrops:						timeDrops[event]=[]					t1=swimmerDrops[season][event][0]					t2=swimmerDrops[season][event][1]					if abs(t1/t2-1)>.1: continue					timeDrops[event].append((t1,t2))					print gender+','+division+','+event+','+self.swimmers[swimmer].team+','+str(round((t1-t2)/((t1+t2)/2),5))+','+str((t1+t2)/2)		return timeDrops	def taperDrop(self):		difs={}		for swimmerName in self.swimmers:			swimmer=self.swimmers[swimmerName]			tapers=swimmer.getTapers()			taperTimes=swimmer.getMedianTaperTimes()			nonTaperTimes=swimmer.getMedianNonTaperTimes(True)			for season in tapers:				if season+1 in taperTimes and season+1 in nonTaperTimes:					for event in taperTimes[season+1]:						if event in nonTaperTimes[season+1] and event in tapers[season]:							if not event in difs:								difs[event]=[]							dif=(nonTaperTimes[season+1][event]*(1+tapers[season][event]))/taperTimes[season+1][event]							if abs(dif-1)>.07: continue #toss outliers							difs[event].append(dif)		for event in difs:			print event			print round(np.std(difs[event])*100,3)			np.average(difs[event])			#P.hist(difs[event])			#P.show()	def eventVariance(self, printout=False):		events={}		counts={}		for swimmerName in self.swimmers:			variance=self.swimmers[swimmerName].getTimeVariance(cutoff=2,tapers=False)			if variance!=[]:				for swim in variance:					event=swim[2]					var=swim[3]					num=swim[4]					if event not in events: events[event]=0					if event not in counts: counts[event]=0					events[event]=(events[event]*counts[event]+var*num)/(counts[event]+num)					counts[event]+=num					if printout: print swim		return events	def dualPlace(self):		print 'gender,event,time,score'		for meet in self.meets.values():			if not len(meet.teams)==2: continue			meet.score()			for swim in meet.getSwims():				print swim.gender+','+swim.event+','+str(swim.time)+','+str(swim.score)	def conferencePlace(self, division, gender, newSwims, meetList = True):		confMeets = {}		with open('./bin/D3ConfMeets.txt') as meetFile:			for line in meetFile:				(meetName, confName) = re.split('\t', line.strip())				if meetName in self.meets:					if confName=='UAA' and confName in confMeets:  # combine that stupid UAA meet						confMeets[confName].addSwims(self.meets[meetName].getSwims())					else:						confMeets[confName] = self.meets[meetName]		confScores = {}		for conference in confMeets:			#if conference.division != division:			#	continue			confMeet = confMeets[conference]  # self.conference(teams=conference.teams, topTimes=True)			for swim in newSwims:				newSwim = Swim(event=swim[0], name='you', team='self', time=swim[1], gender=gender)				confMeet.addSwim(newSwim)			confMeet.place(storePlace=True)			confMeet.score()			confScores[conference] = {}			for swim in confMeet.getSwims():				if swim.name=='you':					confScores[conference][swim.event] = swim.place			confMeet.removeSwimmer('you')		return confScoresif __name__ == "__main__":	start()	for meet in database.meets.values():		print meet.eventSwims.keys()		print meet.events		print meet.getEvents()		meet.printout()		break	#print teamMeets	#database.dualPlace()	#database.taperTest()	#print database.topDual(printout=False)	#database = SwimDatabase('','Men','College',unpickle=False)	#database.load('./bin/D3_15')	#team1 = database.teams["Carleton"]	#team2 = database.teams["Gustavus"]	#meet2 = database.meets["GUSTAVUS vs. UWEC"]	#MIAC = database.conferences['MIAC']	#database.lineup(team1=team2,team2=team1,meet1=meet2,debug=True)	#database.conference2(teams=MIAC.teams).printout()	#print database.teams.keys()	#database.lineup(team2,team1,meet2,debug=True)