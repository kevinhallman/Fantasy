'''
This program will scrape college times from USASwimming and load them into a text files
conference data can be scraped as well using all 100 freestyle times and will also be loaded into a text file
accepts most parms USASwimming does: https://legacy.usaswimming.org/DesktopDefault.aspx?TabId=2974'
'''


import requests
import re
import os
from swimdb import Swimstaging
from loadtimes import getNewConfs
import time as Time

# converts to a time in seconds
def toTime(time):
	if '*' in time:
		time = re.split('\*', time)[0].strip()
	if time[0]=="X" or time[0]=="x":
		time = time[1:]
	if re.match(".*:.*", time) == None:
		return float(time)
	return float(re.split(":", time)[0]) * 60 + float(re.split(":", time)[1])

conferenceMap = {59:'Allegheny Mountain',81:'American Southwest',346:'Appalachian (ASC)',125:'Bluegrass Mountain',82:'Capital Athletic',83:'Centennial',84:'City Univ. of New York',85:'College of Illinois/Wisc',86:'Colonial States Athletic',87:'Commonwealth Coast',88:'Empire 8',90:'Great Northeast Athletic',89:'Great South Athletic',91:'Heartland Collegiate',338:'Independent',92:'Iowa Intercollegiate',93:'Landmark',124:'Liberal Arts',94:'Liberty League',95:'Little East',96:'Massachusetts State',130:'Metropolitan Swim',97:'Michigan Intercollegiate',98:'Middle Atlantic',99:'Midwest',100:'MIAC',101:'New England Intercoll.',102:'NESCAC',103:'New England',104:'New Jersey Athletic',105:'North Atlantic',106:'North Coast Athletic',107:'North Eastern Athletic',108:'Northern Athletics',109:'Northwest Conference',110:'Ohio Athletic',111:'Old Dominion Athletic',129:'Pacific Collegiate',112:'Presidents',114:'Skyline',343:'Southern Athletic Associa',115:'Southern California',116:'Southern Collegiate',113:'St. Louis Intercollegiate',117:'State Univ of New York',119:'University Athletic',120:'Upper Midwest Athletic',118:'USA South Athletic',121:'Wisconsin Intercollegiate',25:'ACC (Atlantic Coast)',29:'America East',345:'American Athletic Conf',30:'Atlantic 10',27:'Big 12',31:'Big East',1:'Big Ten',49:'Coastal College (CCSA)',33:'Colonial Athletic Assoc',34:'Conference USA',35:'Horizon League',36:'Independent',37:'Ivy League',38:'Metro Atlantic Athl. Conf',340:'Metropolitan Swimming Con',39:'Mid',41:'Missouri Valley',336:'Mountain Pacific Sports',42:'Mountain West',43:'Northeast Conf',28:'Pac 12',26:'SEC',45:'Sun Belt',46:'The Patriot League',47:'The Summit League',48:'Western Athletic Conf',339:'Appalachian (ASC)',123:'Bluegrass Mountain',341:'California Collegiate',61:'Central Atlantic',64:'East Coast',66:'Great Lakes Intercoll',344:'Great Lakes Valley',337:'Independent',128:'Metropolitan Swimming',71:'Mid',127:'New South Intercollegiate',73:'Northeast Ten',72:'Northern Sun Intercoll',131:'Pacific Collegiate',122:'Pennsylvania State (PSAC)',76:'Rocky Mountain Athletic',79:'Sunshine State'}

def getTopTimes(conference="", team='radAllTeam', date='30', distance='50', stroke='1', gender='rbGenderMale',
				bestAll='radBestTimeOnly', number=100, startDate='', endDate='', season=None):
	if 'DIII' in date:
		URL = 'https://legacy.usaswimming.org/DesktopDefault.aspx?TabId=3055'
		cut = '9'
		division = 3
	elif 'DII' in date:
		URL = 'https://legacy.usaswimming.org/DesktopDefault.aspx?TabId=3049'
		cut = '6'
		division = 2
	else:
		URL = 'https://legacy.usaswimming.org/DesktopDefault.aspx?TabId=2974'
		cut = '1'  # speed cutoff
		division = 1

	relInd = 'rbIndividual'
	eventType = 'radEventIndividual'
	if '-R' in stroke:
		relInd = 'rbRelay'
		eventType = 'radEventRelay'

	r = requests.post(URL)
	if startDate=='' and endDate=='':
		place = r.text.find('<input type="hidden" name="__VIEWSTATE" id="__VIEWSTATE" value="')+64
		viewState = r.text[place:r.text.find('"', place)]
		place = r.text.find('<input type="hidden" name="__EVENTVALIDATION" id="__EVENTVALIDATION" value="')+76
		eventValidation = r.text[place:r.text.find('"', place)]
	elif not (startDate=='' and endDate==''):
		if division==1:
			viewState='/wEPDwUENTM4MQ8WBB4LVXJsUmVmZXJyZXIFVmh0dHBzOi8vbGVnYWN5LnVzYXN3aW1taW5nLm9yZy9EZXNrdG9wRGVmYXVsdC5hc3B4P1RhYklkPTI5NzQmQWxpYXM9UmFpbmJvdyZMYW5nPWVuLVVTHhNWYWxpZGF0ZVJlcXVlc3RNb2RlAgEWAmYPZBYCAgMPZBYCAgEPZBYCAgkPZBYCZg9kFgQCBA9kFgJmD2QWCAIBD2QWAmYPZBYCZg9kFgICAQ8PFgIeBFRleHRlZGQCAw9kFgICAQ9kFhBmD2QWAmYPZBYCAgEPDxYCHwIFCk5DQUEgRGl2IElkZAIED2QWBGYPZBYCAgEPDxYCHwIFC0NvbmZlcmVuY2U6ZGQCAQ9kFgICAQ8QDxYGHg1EYXRhVGV4dEZpZWxkBRFsZXZlbF9kZXNjcmlwdGlvbh4ORGF0YVZhbHVlRmllbGQFH3NlY29uZGFyeV9vcmdhbml6YXRpb25fbGV2ZWxfaWQeC18hRGF0YUJvdW5kZ2QQFRwJLS0gQWxsIC0tFEFDQyAoQXRsYW50aWMgQ29hc3QpDEFtZXJpY2EgRWFzdBZBbWVyaWNhbiBBdGhsZXRpYyBDb25mC0F0bGFudGljIDEwBkJpZyAxMghCaWcgRWFzdAdCaWcgVGVuFkNvYXN0YWwgQ29sbGVnZSAoQ0NTQSkXQ29sb25pYWwgQXRobGV0aWMgQXNzb2MOQ29uZmVyZW5jZSBVU0EOSG9yaXpvbiBMZWFndWULSW5kZXBlbmRlbnQKSXZ5IExlYWd1ZRlNZXRybyBBdGxhbnRpYyBBdGhsLiBDb25mGU1ldHJvcG9saXRhbiBTd2ltbWluZyBDb24RTWlkLUFtZXJpY2FuIENvbmYPTWlzc291cmkgVmFsbGV5F01vdW50YWluIFBhY2lmaWMgU3BvcnRzDU1vdW50YWluIFdlc3QOTm9ydGhlYXN0IENvbmYKUGFjaWZpYyAxMhJQYWNpZmljIENvbGxlZ2lhdGUSU0VDIChTb3V0aGVhc3Rlcm4pCFN1biBCZWx0ElRoZSBQYXRyaW90IExlYWd1ZRFUaGUgU3VtbWl0IExlYWd1ZRVXZXN0ZXJuIEF0aGxldGljIENvbmYVHAACMjUCMjkDMzQ1AjMwAjI3AjMxATECNDkCMzMCMzQCMzUCMzYCMzcCMzgDMzQwAjM5AjQxAzMzNgI0MgI0MwIyOAMzNTcCMjYCNDUCNDYCNDcCNDgUKwMcZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2RkAgYPZBYCAgEPZBYCAgUPD2QWBB4IcmVhZG9ubHkFCHJlYWRvbmx5HgVzdHlsZQUNZGlzcGxheTpub25lO2QCCA9kFgICAQ9kFgYCAw8QDxYGHwMFFW5hbWVkX2RhdGVfcmFuZ2VfZGVzYx8EBSFzZWNvbmRhcnlfb3JnX25hbWVkX2RhdGVfcmFuZ2VfaWQfBWdkEBULFigxKSAyMDE3LTE4IE5DQUEgRGl2IEkWKDIpIDIwMTYtMTcgTkNBQSBEaXYgSRYoMykgMjAxNS0xNiBOQ0FBIERpdiBJFig0KSAyMDE0LTE1IE5DQUEgRGl2IEkWKDUpIDIwMTMtMTQgTkNBQSBEaXYgSRYoNikgMjAxMi0xMyBOQ0FBIERpdiBJFig3KSAyMDExLTEyIE5DQUEgRGl2IEkWKDgpIDIwMTAtMTEgTkNBQSBEaXYgSRYoOSkgMjAwOS0xMCBOQ0FBIERpdiBJFygxMCkgMjAwOC0wOSBOQ0FBIERpdiBJFygxMSkgMjAwNy0wOCBOQ0FBIERpdiBJFQsCNDYCNDICMzcCMzMCMzACMjUCMjABNwE0ATUBNhQrAwtnZ2dnZ2dnZ2dnZ2RkAgcPZBYEZg8PFgYeEFNob3dQb3B1cE9uRm9jdXNoHgdNYXhEYXRlBgBwhDAgLDaNHgxTZWxlY3RlZERhdGVkZBYEZg8UKwAIDxYKHhFFbmFibGVBcmlhU3VwcG9ydGgfCQYAcIQwICw2jR8CZB4EU2tpbgUHRGVmYXVsdB4NTGFiZWxDc3NDbGFzcwUHcmlMYWJlbGQWBh4FV2lkdGgbAAAAAAAAWUAHAAAAHghDc3NDbGFzcwURcmlUZXh0Qm94IHJpSG92ZXIeBF8hU0ICggIWBh8OGwAAAAAAAFlABwAAAB8PBRFyaVRleHRCb3ggcmlFcnJvch8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUTcmlUZXh0Qm94IHJpRm9jdXNlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUTcmlUZXh0Qm94IHJpRW5hYmxlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUUcmlUZXh0Qm94IHJpRGlzYWJsZWQfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEXJpVGV4dEJveCByaUVtcHR5HxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRByaVRleHRCb3ggcmlSZWFkHxACggJkAgIPFCsADQ8WEAUDRVJTaAUNU2VsZWN0ZWREYXRlcw8FjwFUZWxlcmlrLldlYi5VSS5DYWxlbmRhci5Db2xsZWN0aW9ucy5EYXRlVGltZUNvbGxlY3Rpb24sIFRlbGVyaWsuV2ViLlVJLCBWZXJzaW9uPTIwMTMuMS4yMjAuNDUsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MTIxZmFlNzgxNjViYTNkNBQrAAAFEUVuYWJsZU11bHRpU2VsZWN0aAUPUmVuZGVySW52aXNpYmxlZwULU3BlY2lhbERheXMPBZIBVGVsZXJpay5XZWIuVUkuQ2FsZW5kYXIuQ29sbGVjdGlvbnMuQ2FsZW5kYXJEYXlDb2xsZWN0aW9uLCBUZWxlcmlrLldlYi5VSSwgVmVyc2lvbj0yMDEzLjEuMjIwLjQ1LCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTEyMWZhZTc4MTY1YmEzZDQUKwAABQRNaW5EBgBAVyBTBVEIBQRNYXhEBgBwhDAgLDaNBRBWaWV3U2VsZWN0b3JUZXh0BQF4DxYEHwtoHwwFB0RlZmF1bHRkZBYEHw8FC3JjTWFpblRhYmxlHxACAhYEHw8FDHJjT3RoZXJNb250aB8QAgJkFgQfDwUKcmNTZWxlY3RlZB8QAgJkFgQfDwUKcmNEaXNhYmxlZB8QAgIWBB8PBQxyY091dE9mUmFuZ2UfEAICFgQfDwUJcmNXZWVrZW5kHxACAhYEHw8FB3JjSG92ZXIfEAICFgQfDwUxUmFkQ2FsZW5kYXJNb250aFZpZXcgUmFkQ2FsZW5kYXJNb250aFZpZXdfRGVmYXVsdB8QAgIWBB8PBQlyY1ZpZXdTZWwfEAICZAICDw8WBB4SRW5hYmxlQ2xpZW50U2NyaXB0aB4HRW5hYmxlZGhkZAIJD2QWBGYPDxYGHwhoHwkGAHCEMCAsNo0fCmRkFgRmDxQrAAgPFgofC2gfCQYAcIQwICw2jR8CZB8MBQdEZWZhdWx0Hw0FB3JpTGFiZWxkFgYfDhsAAAAAAABZQAcAAAAfDwURcmlUZXh0Qm94IHJpSG92ZXIfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEXJpVGV4dEJveCByaUVycm9yHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRNyaVRleHRCb3ggcmlGb2N1c2VkHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRNyaVRleHRCb3ggcmlFbmFibGVkHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRRyaVRleHRCb3ggcmlEaXNhYmxlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwURcmlUZXh0Qm94IHJpRW1wdHkfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEHJpVGV4dEJveCByaVJlYWQfEAKCAmQCAg8UKwANDxYQBQNFUlNoBQ1TZWxlY3RlZERhdGVzDwWPAVRlbGVyaWsuV2ViLlVJLkNhbGVuZGFyLkNvbGxlY3Rpb25zLkRhdGVUaW1lQ29sbGVjdGlvbiwgVGVsZXJpay5XZWIuVUksIFZlcnNpb249MjAxMy4xLjIyMC40NSwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0xMjFmYWU3ODE2NWJhM2Q0FCsAAAURRW5hYmxlTXVsdGlTZWxlY3RoBQ9SZW5kZXJJbnZpc2libGVnBQtTcGVjaWFsRGF5cw8FkgFUZWxlcmlrLldlYi5VSS5DYWxlbmRhci5Db2xsZWN0aW9ucy5DYWxlbmRhckRheUNvbGxlY3Rpb24sIFRlbGVyaWsuV2ViLlVJLCBWZXJzaW9uPTIwMTMuMS4yMjAuNDUsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MTIxZmFlNzgxNjViYTNkNBQrAAAFBE1pbkQGAEBXIFMFUQgFBE1heEQGAHCEMCAsNo0FEFZpZXdTZWxlY3RvclRleHQFAXgPFgQfC2gfDAUHRGVmYXVsdGRkFgQfDwULcmNNYWluVGFibGUfEAICFgQfDwUMcmNPdGhlck1vbnRoHxACAmQWBB8PBQpyY1NlbGVjdGVkHxACAmQWBB8PBQpyY0Rpc2FibGVkHxACAhYEHw8FDHJjT3V0T2ZSYW5nZR8QAgIWBB8PBQlyY1dlZWtlbmQfEAICFgQfDwUHcmNIb3Zlch8QAgIWBB8PBTFSYWRDYWxlbmRhck1vbnRoVmlldyBSYWRDYWxlbmRhck1vbnRoVmlld19EZWZhdWx0HxACAhYEHw8FCXJjVmlld1NlbB8QAgJkAgIPDxYEHxFoHxJoZGQCCg9kFgICAQ9kFgICAw9kFgYCAQ8QDxYGHwQFCGRpc3RhbmNlHwMFCGRpc3RhbmNlHwVnZBAVDQI1MAMxMDADMjAwAzQwMAM1MDADODAwBDEwMDAEMTUwMAQxNjUwBDIwMDAEMzAwMAQ0MDAwBDUwMDAVDQI1MAMxMDADMjAwAzQwMAM1MDADODAwBDEwMDAEMTUwMAQxNjUwBDIwMDAEMzAwMAQ0MDAwBDUwMDAUKwMNZ2dnZ2dnZ2dnZ2dnZ2RkAgQPEA8WBh8EBQlzdHJva2VfaWQfAwULc3Ryb2tlX2NvZGUfBWdkEBUFAkZSAkJLAkJSAkZMAklNFQUBMQEyATMBNAE1FCsDBWdnZ2dnZGQCBw8QDxYGHwQFCWNvdXJzZV9pZB8DBQtjb3Vyc2VfY29kZR8FZ2QQFQMDU0NZA1NDTQNMQ00VAwExATIBMxQrAwNnZ2dkZAILD2QWAgIBD2QWAgIDD2QWBgIBDxAPFgYfBAUIZGlzdGFuY2UfAwUIZGlzdGFuY2UfBWdkEBUDAzIwMAM0MDADODAwFQMDMjAwAzQwMAM4MDAUKwMDZ2dnZGQCBA8QDxYGHwQFCXN0cm9rZV9pZB8DBQtzdHJva2VfY29kZR8FZ2QQFQIERlItUgVNRUQtUhUCATYBNxQrAwJnZ2RkAgcPEA8WBh8EBQljb3Vyc2VfaWQfAwULY291cnNlX2NvZGUfBWdkEBUDA1NDWQNTQ00DTENNFQMBMQEyATMUKwMDZ2dnZGQCDw9kFgICAQ9kFgICAQ8QDxYGHwMFDXN0YW5kYXJkX25hbWUfBAUZc2Vjb25kYXJ5X29yZ19zdGFuZGFyZF9pZB8FZ2QQFQUBQQFCAlFTAlBTAk5TFQUBMgEzAjE0AjE1ATEUKwMFZ2dnZ2dkZAIVD2QWAmYPZBYCAgEPDxYCHwIFMFNob3cgVGVhbXMgdGhhdCBhcmUgSW5lbGlnaWJsZSBmb3IgTkNBQSBDaGFtcHM/OmRkAgUPZBYCAgEPZBYIAgEPDxYCHwIFC0NvbmZlcmVuY2U6ZGQCAw8QDxYGHwMFEWxldmVsX2Rlc2NyaXB0aW9uHwQFH3NlY29uZGFyeV9vcmdhbml6YXRpb25fbGV2ZWxfaWQfBWdkEBUcCS0tIEFsbCAtLRRBQ0MgKEF0bGFudGljIENvYXN0KQxBbWVyaWNhIEVhc3QWQW1lcmljYW4gQXRobGV0aWMgQ29uZgtBdGxhbnRpYyAxMAZCaWcgMTIIQmlnIEVhc3QHQmlnIFRlbhZDb2FzdGFsIENvbGxlZ2UgKENDU0EpF0NvbG9uaWFsIEF0aGxldGljIEFzc29jDkNvbmZlcmVuY2UgVVNBDkhvcml6b24gTGVhZ3VlC0luZGVwZW5kZW50Ckl2eSBMZWFndWUZTWV0cm8gQXRsYW50aWMgQXRobC4gQ29uZhlNZXRyb3BvbGl0YW4gU3dpbW1pbmcgQ29uEU1pZC1BbWVyaWNhbiBDb25mD01pc3NvdXJpIFZhbGxleRdNb3VudGFpbiBQYWNpZmljIFNwb3J0cw1Nb3VudGFpbiBXZXN0Dk5vcnRoZWFzdCBDb25mClBhY2lmaWMgMTISUGFjaWZpYyBDb2xsZWdpYXRlElNFQyAoU291dGhlYXN0ZXJuKQhTdW4gQmVsdBJUaGUgUGF0cmlvdCBMZWFndWURVGhlIFN1bW1pdCBMZWFndWUVV2VzdGVybiBBdGhsZXRpYyBDb25mFRwAAjI1AjI5AzM0NQIzMAIyNwIzMQExAjQ5AjMzAjM0AjM1AjM2AjM3AjM4AzM0MAIzOQI0MQMzMzYCNDICNDMCMjgDMzU3AjI2AjQ1AjQ2AjQ3AjQ4FCsDHGdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cWAWZkAgcPEA8WBh8DBQhsc2NfbmFtZR8EBQZsc2NfaWQfBWdkEBU9CS0tIEFsbCAtLRNBRElST05EQUNLIFNXSU1NSU5HD0FMQVNLQSBTV0lNTUlORxtBTExFR0hFTlkgTU9VTlRBSU4gU1dJTU1JTkcQQVJJWk9OQSBTV0lNTUlORxFBUktBTlNBUyBTV0lNTUlORw9CT1JERVIgU1dJTU1JTkcbQ0VOVFJBTCBDQUxJRk9STklBIFNXSU1NSU5HEUNPTE9SQURPIFNXSU1NSU5HFENPTk5FQ1RJQ1VUIFNXSU1NSU5HG0ZMT1JJREEgR09MRCBDT0FTVCBTV0lNTUlORxBGTE9SSURBIFNXSU1NSU5HEEdFT1JHSUEgU1dJTU1JTkcNR1VMRiBTV0lNTUlORxFIQVdBSUlBTiBTV0lNTUlORxFJTExJTk9JUyBTV0lNTUlORxBJTkRJQU5BIFNXSU1NSU5HFklOTEFORCBFTVBJUkUgU1dJTU1JTkcNSU9XQSBTV0lNTUlORxFLRU5UVUNLWSBTV0lNTUlORxJMQUtFIEVSSUUgU1dJTU1JTkcSTE9VSVNJQU5BIFNXSU1NSU5HDk1BSU5FIFNXSU1NSU5HEU1BUllMQU5EIFNXSU1NSU5HFU1FVFJPUE9MSVRBTiBTV0lNTUlORxFNSUNISUdBTiBTV0lNTUlORxhNSURETEUgQVRMQU5USUMgU1dJTU1JTkcTTUlEV0VTVEVSTiBTV0lNTUlORxJNSU5ORVNPVEEgU1dJTU1JTkcUTUlTU0lTU0lQUEkgU1dJTU1JTkcYTUlTU09VUkkgVkFMTEVZIFNXSU1NSU5HEE1PTlRBTkEgU1dJTU1JTkcUTkVXIEVOR0xBTkQgU1dJTU1JTkcTTkVXIEpFUlNFWSBTV0lNTUlORxNORVcgTUVYSUNPIFNXSU1NSU5HEE5JQUdBUkEgU1dJTU1JTkcXTk9SVEggQ0FST0xJTkEgU1dJTU1JTkcVTk9SVEggREFLT1RBIFNXSU1NSU5HFE5PUlRIIFRFWEFTIFNXSU1NSU5HDU9ISU8gU1dJTU1JTkcRT0tMQUhPTUEgU1dJTU1JTkcPT1JFR09OIFNXSU1NSU5HDk9aQVJLIFNXSU1NSU5HGlBBQ0lGSUMgTk9SVEhXRVNUIFNXSU1NSU5HEFBBQ0lGSUMgU1dJTU1JTkcXUE9UT01BQyBWQUxMRVkgU1dJTU1JTkcbU0FOIERJRUdPLUlNUEVSSUFMIFNXSU1NSU5HFlNJRVJSQSBORVZBREEgU1dJTU1JTkcUU05BS0UgUklWRVIgU1dJTU1JTkcXU09VVEggQ0FST0xJTkEgU1dJTU1JTkcVU09VVEggREFLT1RBIFNXSU1NSU5HFFNPVVRIIFRFWEFTIFNXSU1NSU5HFVNPVVRIRUFTVEVSTiBTV0lNTUlORxxTT1VUSEVSTiBDQUxJRk9STklBIFNXSU1NSU5HDFVTQSBTV0lNTUlORw1VVEFIIFNXSU1NSU5HEVZJUkdJTklBIFNXSU1NSU5HE1dFU1QgVEVYQVMgU1dJTU1JTkcWV0VTVCBWSVJHSU5JQSBTV0lNTUlORxJXSVNDT05TSU4gU1dJTU1JTkcQV1lPTUlORyBTV0lNTUlORxU9AAJBRAJBSwJBTQJBWgJBUgJCRAJDQwJDTwJDVAJGRwJGTAJHQQJHVQJISQJJTAJJTgJJRQJJQQJLWQJMRQJMQQJNRQJNRAJNUgJNSQJNQQJNVwJNTgJNUwJNVgJNVAJORQJOSgJOTQJOSQJOQwJORAJOVAJPSAJPSwJPUgJPWgJQTgJQQwJQVgJTSQJTTgJTUgJTQwJTRAJTVAJTRQJDQQJVUwJVVAJWQQJXVAJXVgJXSQJXWRQrAz1nZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnFgFmZAIPD2QWAgIBD2QWAmYPZBYCZg9kFgICAQ88KwALAGQCBw8PFgIeB1Zpc2libGVoZBYCAgEPZBYGZg8WAh8TaGQCAQ9kFgJmDxYCHxNoZAIDD2QWAmYPZBYEAgEPPCsACwBkAgMPPCsACwBkAgYPDxYCHxNoZBYCAgUPZBYEAgIPEGQQFQQJQWRvYmUgUERGDkZvcm1hdHRlZCBIVE1MCFJhdyBIVE1MD0V4cG9ydCB0byBFeGNlbBUECUFkb2JlIFBERg5Gb3JtYXR0ZWQgSFRNTAhSYXcgSFRNTA9FeHBvcnQgdG8gRXhjZWwUKwMEZ2dnZxYBZmQCBg8WAh8TaGQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFhkFGGN0bDAwJGN0bDAyJHJiSW5kaXZpZHVhbAUTY3RsMDAkY3RsMDIkcmJSZWxheQUTY3RsMDAkY3RsMDIkcmJSZWxheQUWY3RsMDAkY3RsMDIkcmFkQWxsVGVhbQUbY3RsMDAkY3RsMDIkcmFkU3BlY2lmaWNUZWFtBRtjdGwwMCRjdGwwMiRyYWRTcGVjaWZpY1RlYW0FHGN0bDAwJGN0bDAyJHJiTmFtZWREYXRlUmFuZ2UFF2N0bDAwJGN0bDAyJHJiRGF0ZVJhbmdlBRdjdGwwMCRjdGwwMiRyYkRhdGVSYW5nZQUiY3RsMDAkY3RsMDIkdWNTdGFydERhdGUkcmFkVGhlRGF0ZQUrY3RsMDAkY3RsMDIkdWNTdGFydERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUrY3RsMDAkY3RsMDIkdWNTdGFydERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUgY3RsMDAkY3RsMDIkdWNFbmREYXRlJHJhZFRoZURhdGUFKWN0bDAwJGN0bDAyJHVjRW5kRGF0ZSRyYWRUaGVEYXRlJGNhbGVuZGFyBSljdGwwMCRjdGwwMiR1Y0VuZERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUeY3RsMDAkY3RsMDIkcmFkRXZlbnRJbmRpdmlkdWFsBRljdGwwMCRjdGwwMiRyYWRFdmVudFJlbGF5BRljdGwwMCRjdGwwMiRyYWRFdmVudFJlbGF5BRhjdGwwMCRjdGwwMiRyYkdlbmRlck1hbGUFGmN0bDAwJGN0bDAyJHJiR2VuZGVyRmVtYWxlBRpjdGwwMCRjdGwwMiRyYkdlbmRlckZlbWFsZQUbY3RsMDAkY3RsMDIkcmFkQmVzdFRpbWVPbmx5BSFjdGwwMCRjdGwwMiRyYWRBbGxUaW1lc0ZvclN3aW1tZXIFIWN0bDAwJGN0bDAyJHJhZEFsbFRpbWVzRm9yU3dpbW1lcgUlY3RsMDAkY3RsMDIkY2JTaG93SW5lbGlnaWJsZVRlYW1UaW1lc//1AmLHMLXewUzZG6DEhxFf7N3F'
			eventValidation='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'
		elif division==2:
			viewState	='/wEPDwUENTM4MQ8WBB4LVXJsUmVmZXJyZXIFU2h0dHBzOi8vbGVnYWN5LnVzYXN3aW1taW5nLm9yZy9EZXNrdG9wRGVmYXVsdC5hc3B4P1RhYklkPTMwNDkmQWxpYXM9UmFpbmJvdyZMYW5nPWVuHhNWYWxpZGF0ZVJlcXVlc3RNb2RlAgEWAmYPZBYCAgMPZBYCAgEPZBYCAgkPZBYCZg9kFgQCBA9kFgJmD2QWCAIBD2QWAmYPZBYCZg9kFgICAQ8PFgIeBFRleHRlZGQCAw9kFgICAQ9kFhBmD2QWAmYPZBYCAgEPDxYCHwIFC05DQUEgRGl2IElJZGQCBA9kFgRmD2QWAgIBDw8WAh8CBQxDb25mZXJlbmNlczpkZAIBD2QWAgIBDxAPFgYeDURhdGFUZXh0RmllbGQFEWxldmVsX2Rlc2NyaXB0aW9uHg5EYXRhVmFsdWVGaWVsZAUfc2Vjb25kYXJ5X29yZ2FuaXphdGlvbl9sZXZlbF9pZB4LXyFEYXRhQm91bmRnZBAVFAktLSBBbGwgLS0RQXBwYWxhY2hpYW4gKEFTQykSQmx1ZWdyYXNzIE1vdW50YWluFUNhbGlmb3JuaWEgQ29sbGVnaWF0ZRBDZW50cmFsIEF0bGFudGljFENvbmZlcmVuY2UgQ2Fyb2xpbmFzCkVhc3QgQ29hc3QVR3JlYXQgTGFrZXMgSW50ZXJjb2xsEkdyZWF0IExha2VzIFZhbGxleRlHcmVhdCBNaWR3ZXN0IEF0aGxldGljIENvC0luZGVwZW5kZW50FU1ldHJvcG9saXRhbiBTd2ltbWluZxVNaWQtQW1lcmljYSBJbnRlcmNvbGwZTmV3IFNvdXRoIEludGVyY29sbGVnaWF0ZQ1Ob3J0aGVhc3QgVGVuFk5vcnRoZXJuIFN1biBJbnRlcmNvbGwSUGFjaWZpYyBDb2xsZWdpYXRlGVBlbm5zeWx2YW5pYSBTdGF0ZSAoUFNBQykXUm9ja3kgTW91bnRhaW4gQXRobGV0aWMOU3Vuc2hpbmUgU3RhdGUVFAADMzM5AzEyMwMzNDECNjEDNDAwAjY0AjY2AzM0NAMzOTkDMzM3AzEyOAI3MQMxMjcCNzMCNzIDMTMxAzEyMgI3NgI3ORQrAxRnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2RkAgYPZBYCAgEPZBYCAgUPD2QWBB4IcmVhZG9ubHkFCHJlYWRvbmx5HgVzdHlsZQUNZGlzcGxheTpub25lO2QCCA9kFgICAQ9kFgYCAw8QDxYGHwMFFW5hbWVkX2RhdGVfcmFuZ2VfZGVzYx8EBSFzZWNvbmRhcnlfb3JnX25hbWVkX2RhdGVfcmFuZ2VfaWQfBWdkEBUIFygxKSAyMDE3LTE4IE5DQUEgRGl2IElJFygyKSAyMDE2LTE3IE5DQUEgRGl2IElJFygzKSAyMDE1LTE2IE5DQUEgRGl2IElJFyg0KSAyMDE0LTE1IE5DQUEgRGl2IElJFyg1KSAyMDEzLTE0IE5DQUEgRGl2IElJFyg2KSAyMDEyLTEzIE5DQUEgRGl2IElJFyg3KSAyMDExLTEyIE5DQUEgRGl2IElJFyg4KSAyMDEwLTExIE5DQUEgRGl2IElJFQgCNDcCNDMCMzgCMzQCMjkCMjYCMjEBORQrAwhnZ2dnZ2dnZ2RkAgcPZBYEZg8PFgYeEFNob3dQb3B1cE9uRm9jdXNoHgdNYXhEYXRlBgBwhDAgLDaNHgxTZWxlY3RlZERhdGVkZBYEZg8UKwAIDxYKHhFFbmFibGVBcmlhU3VwcG9ydGgfCQYAcIQwICw2jR8CZB4EU2tpbgUHRGVmYXVsdB4NTGFiZWxDc3NDbGFzcwUHcmlMYWJlbGQWBh4FV2lkdGgbAAAAAAAAWUAHAAAAHghDc3NDbGFzcwURcmlUZXh0Qm94IHJpSG92ZXIeBF8hU0ICggIWBh8OGwAAAAAAAFlABwAAAB8PBRFyaVRleHRCb3ggcmlFcnJvch8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUTcmlUZXh0Qm94IHJpRm9jdXNlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUTcmlUZXh0Qm94IHJpRW5hYmxlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUUcmlUZXh0Qm94IHJpRGlzYWJsZWQfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEXJpVGV4dEJveCByaUVtcHR5HxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRByaVRleHRCb3ggcmlSZWFkHxACggJkAgIPFCsADQ8WEAUDRVJTaAUNU2VsZWN0ZWREYXRlcw8FjwFUZWxlcmlrLldlYi5VSS5DYWxlbmRhci5Db2xsZWN0aW9ucy5EYXRlVGltZUNvbGxlY3Rpb24sIFRlbGVyaWsuV2ViLlVJLCBWZXJzaW9uPTIwMTMuMS4yMjAuNDUsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MTIxZmFlNzgxNjViYTNkNBQrAAAFEUVuYWJsZU11bHRpU2VsZWN0aAUPUmVuZGVySW52aXNpYmxlZwULU3BlY2lhbERheXMPBZIBVGVsZXJpay5XZWIuVUkuQ2FsZW5kYXIuQ29sbGVjdGlvbnMuQ2FsZW5kYXJEYXlDb2xsZWN0aW9uLCBUZWxlcmlrLldlYi5VSSwgVmVyc2lvbj0yMDEzLjEuMjIwLjQ1LCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTEyMWZhZTc4MTY1YmEzZDQUKwAABQRNaW5EBgBAVyBTBVEIBQRNYXhEBgBwhDAgLDaNBRBWaWV3U2VsZWN0b3JUZXh0BQF4DxYEHwtoHwwFB0RlZmF1bHRkZBYEHw8FC3JjTWFpblRhYmxlHxACAhYEHw8FDHJjT3RoZXJNb250aB8QAgJkFgQfDwUKcmNTZWxlY3RlZB8QAgJkFgQfDwUKcmNEaXNhYmxlZB8QAgIWBB8PBQxyY091dE9mUmFuZ2UfEAICFgQfDwUJcmNXZWVrZW5kHxACAhYEHw8FB3JjSG92ZXIfEAICFgQfDwUxUmFkQ2FsZW5kYXJNb250aFZpZXcgUmFkQ2FsZW5kYXJNb250aFZpZXdfRGVmYXVsdB8QAgIWBB8PBQlyY1ZpZXdTZWwfEAICZAICDw8WBB4SRW5hYmxlQ2xpZW50U2NyaXB0aB4HRW5hYmxlZGhkZAIJD2QWBGYPDxYGHwhoHwkGAHCEMCAsNo0fCmRkFgRmDxQrAAgPFgofC2gfCQYAcIQwICw2jR8CZB8MBQdEZWZhdWx0Hw0FB3JpTGFiZWxkFgYfDhsAAAAAAABZQAcAAAAfDwURcmlUZXh0Qm94IHJpSG92ZXIfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEXJpVGV4dEJveCByaUVycm9yHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRNyaVRleHRCb3ggcmlGb2N1c2VkHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRNyaVRleHRCb3ggcmlFbmFibGVkHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRRyaVRleHRCb3ggcmlEaXNhYmxlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwURcmlUZXh0Qm94IHJpRW1wdHkfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEHJpVGV4dEJveCByaVJlYWQfEAKCAmQCAg8UKwANDxYQBQNFUlNoBQ1TZWxlY3RlZERhdGVzDwWPAVRlbGVyaWsuV2ViLlVJLkNhbGVuZGFyLkNvbGxlY3Rpb25zLkRhdGVUaW1lQ29sbGVjdGlvbiwgVGVsZXJpay5XZWIuVUksIFZlcnNpb249MjAxMy4xLjIyMC40NSwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0xMjFmYWU3ODE2NWJhM2Q0FCsAAAURRW5hYmxlTXVsdGlTZWxlY3RoBQ9SZW5kZXJJbnZpc2libGVnBQtTcGVjaWFsRGF5cw8FkgFUZWxlcmlrLldlYi5VSS5DYWxlbmRhci5Db2xsZWN0aW9ucy5DYWxlbmRhckRheUNvbGxlY3Rpb24sIFRlbGVyaWsuV2ViLlVJLCBWZXJzaW9uPTIwMTMuMS4yMjAuNDUsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MTIxZmFlNzgxNjViYTNkNBQrAAAFBE1pbkQGAEBXIFMFUQgFBE1heEQGAHCEMCAsNo0FEFZpZXdTZWxlY3RvclRleHQFAXgPFgQfC2gfDAUHRGVmYXVsdGRkFgQfDwULcmNNYWluVGFibGUfEAICFgQfDwUMcmNPdGhlck1vbnRoHxACAmQWBB8PBQpyY1NlbGVjdGVkHxACAmQWBB8PBQpyY0Rpc2FibGVkHxACAhYEHw8FDHJjT3V0T2ZSYW5nZR8QAgIWBB8PBQlyY1dlZWtlbmQfEAICFgQfDwUHcmNIb3Zlch8QAgIWBB8PBTFSYWRDYWxlbmRhck1vbnRoVmlldyBSYWRDYWxlbmRhck1vbnRoVmlld19EZWZhdWx0HxACAhYEHw8FCXJjVmlld1NlbB8QAgJkAgIPDxYEHxFoHxJoZGQCCg9kFgICAQ9kFgICAw9kFgYCAQ8QDxYGHwQFCGRpc3RhbmNlHwMFCGRpc3RhbmNlHwVnZBAVDQI1MAMxMDADMjAwAzQwMAM1MDADODAwBDEwMDAEMTUwMAQxNjUwBDIwMDAEMzAwMAQ0MDAwBDUwMDAVDQI1MAMxMDADMjAwAzQwMAM1MDADODAwBDEwMDAEMTUwMAQxNjUwBDIwMDAEMzAwMAQ0MDAwBDUwMDAUKwMNZ2dnZ2dnZ2dnZ2dnZ2RkAgQPEA8WBh8EBQlzdHJva2VfaWQfAwULc3Ryb2tlX2NvZGUfBWdkEBUFAkZSAkJLAkJSAkZMAklNFQUBMQEyATMBNAE1FCsDBWdnZ2dnZGQCBw8QDxYGHwQFCWNvdXJzZV9pZB8DBQtjb3Vyc2VfY29kZR8FZ2QQFQMDU0NZA1NDTQNMQ00VAwExATIBMxQrAwNnZ2dkZAILD2QWAgIBD2QWAgIDD2QWBgIBDxAPFgYfBAUIZGlzdGFuY2UfAwUIZGlzdGFuY2UfBWdkEBUDAzIwMAM0MDADODAwFQMDMjAwAzQwMAM4MDAUKwMDZ2dnZGQCBA8QDxYGHwQFCXN0cm9rZV9pZB8DBQtzdHJva2VfY29kZR8FZ2QQFQIERlItUgVNRUQtUhUCATYBNxQrAwJnZ2RkAgcPEA8WBh8EBQljb3Vyc2VfaWQfAwULY291cnNlX2NvZGUfBWdkEBUDA1NDWQNTQ00DTENNFQMBMQEyATMUKwMDZ2dnZGQCDw9kFgICAQ9kFgICAQ8QDxYGHwMFDXN0YW5kYXJkX25hbWUfBAUZc2Vjb25kYXJ5X29yZ19zdGFuZGFyZF9pZB8FZ2QQFQQBQQFCAlBTAk5TFQQBNAE1AjE5ATYUKwMEZ2dnZ2RkAhUPZBYCZg9kFgICAQ8PFgIfAgUwU2hvdyBUZWFtcyB0aGF0IGFyZSBJbmVsaWdpYmxlIGZvciBOQ0FBIENoYW1wcz86ZGQCBQ9kFgICAQ9kFggCAQ8PFgIfAgUMQ29uZmVyZW5jZXM6ZGQCAw8QDxYGHwMFEWxldmVsX2Rlc2NyaXB0aW9uHwQFH3NlY29uZGFyeV9vcmdhbml6YXRpb25fbGV2ZWxfaWQfBWdkEBUUCS0tIEFsbCAtLRFBcHBhbGFjaGlhbiAoQVNDKRJCbHVlZ3Jhc3MgTW91bnRhaW4VQ2FsaWZvcm5pYSBDb2xsZWdpYXRlEENlbnRyYWwgQXRsYW50aWMUQ29uZmVyZW5jZSBDYXJvbGluYXMKRWFzdCBDb2FzdBVHcmVhdCBMYWtlcyBJbnRlcmNvbGwSR3JlYXQgTGFrZXMgVmFsbGV5GUdyZWF0IE1pZHdlc3QgQXRobGV0aWMgQ28LSW5kZXBlbmRlbnQVTWV0cm9wb2xpdGFuIFN3aW1taW5nFU1pZC1BbWVyaWNhIEludGVyY29sbBlOZXcgU291dGggSW50ZXJjb2xsZWdpYXRlDU5vcnRoZWFzdCBUZW4WTm9ydGhlcm4gU3VuIEludGVyY29sbBJQYWNpZmljIENvbGxlZ2lhdGUZUGVubnN5bHZhbmlhIFN0YXRlIChQU0FDKRdSb2NreSBNb3VudGFpbiBBdGhsZXRpYw5TdW5zaGluZSBTdGF0ZRUUAAMzMzkDMTIzAzM0MQI2MQM0MDACNjQCNjYDMzQ0AzM5OQMzMzcDMTI4AjcxAzEyNwI3MwI3MgMxMzEDMTIyAjc2Ajc5FCsDFGdnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnFgFmZAIHDxAPFgYfAwUIbHNjX25hbWUfBAUGbHNjX2lkHwVnZBAVPQktLSBBbGwgLS0TQURJUk9OREFDSyBTV0lNTUlORw9BTEFTS0EgU1dJTU1JTkcbQUxMRUdIRU5ZIE1PVU5UQUlOIFNXSU1NSU5HEEFSSVpPTkEgU1dJTU1JTkcRQVJLQU5TQVMgU1dJTU1JTkcPQk9SREVSIFNXSU1NSU5HG0NFTlRSQUwgQ0FMSUZPUk5JQSBTV0lNTUlORxFDT0xPUkFETyBTV0lNTUlORxRDT05ORUNUSUNVVCBTV0lNTUlORxtGTE9SSURBIEdPTEQgQ09BU1QgU1dJTU1JTkcQRkxPUklEQSBTV0lNTUlORxBHRU9SR0lBIFNXSU1NSU5HDUdVTEYgU1dJTU1JTkcRSEFXQUlJQU4gU1dJTU1JTkcRSUxMSU5PSVMgU1dJTU1JTkcQSU5ESUFOQSBTV0lNTUlORxZJTkxBTkQgRU1QSVJFIFNXSU1NSU5HDUlPV0EgU1dJTU1JTkcRS0VOVFVDS1kgU1dJTU1JTkcSTEFLRSBFUklFIFNXSU1NSU5HEkxPVUlTSUFOQSBTV0lNTUlORw5NQUlORSBTV0lNTUlORxFNQVJZTEFORCBTV0lNTUlORxVNRVRST1BPTElUQU4gU1dJTU1JTkcRTUlDSElHQU4gU1dJTU1JTkcYTUlERExFIEFUTEFOVElDIFNXSU1NSU5HE01JRFdFU1RFUk4gU1dJTU1JTkcSTUlOTkVTT1RBIFNXSU1NSU5HFE1JU1NJU1NJUFBJIFNXSU1NSU5HGE1JU1NPVVJJIFZBTExFWSBTV0lNTUlORxBNT05UQU5BIFNXSU1NSU5HFE5FVyBFTkdMQU5EIFNXSU1NSU5HE05FVyBKRVJTRVkgU1dJTU1JTkcTTkVXIE1FWElDTyBTV0lNTUlORxBOSUFHQVJBIFNXSU1NSU5HF05PUlRIIENBUk9MSU5BIFNXSU1NSU5HFU5PUlRIIERBS09UQSBTV0lNTUlORxROT1JUSCBURVhBUyBTV0lNTUlORw1PSElPIFNXSU1NSU5HEU9LTEFIT01BIFNXSU1NSU5HD09SRUdPTiBTV0lNTUlORw5PWkFSSyBTV0lNTUlORxpQQUNJRklDIE5PUlRIV0VTVCBTV0lNTUlORxBQQUNJRklDIFNXSU1NSU5HF1BPVE9NQUMgVkFMTEVZIFNXSU1NSU5HG1NBTiBESUVHTy1JTVBFUklBTCBTV0lNTUlORxZTSUVSUkEgTkVWQURBIFNXSU1NSU5HFFNOQUtFIFJJVkVSIFNXSU1NSU5HF1NPVVRIIENBUk9MSU5BIFNXSU1NSU5HFVNPVVRIIERBS09UQSBTV0lNTUlORxRTT1VUSCBURVhBUyBTV0lNTUlORxVTT1VUSEVBU1RFUk4gU1dJTU1JTkccU09VVEhFUk4gQ0FMSUZPUk5JQSBTV0lNTUlORwxVU0EgU1dJTU1JTkcNVVRBSCBTV0lNTUlORxFWSVJHSU5JQSBTV0lNTUlORxNXRVNUIFRFWEFTIFNXSU1NSU5HFldFU1QgVklSR0lOSUEgU1dJTU1JTkcSV0lTQ09OU0lOIFNXSU1NSU5HEFdZT01JTkcgU1dJTU1JTkcVPQACQUQCQUsCQU0CQVoCQVICQkQCQ0MCQ08CQ1QCRkcCRkwCR0ECR1UCSEkCSUwCSU4CSUUCSUECS1kCTEUCTEECTUUCTUQCTVICTUkCTUECTVcCTU4CTVMCTVYCTVQCTkUCTkoCTk0CTkkCTkMCTkQCTlQCT0gCT0sCT1ICT1oCUE4CUEMCUFYCU0kCU04CU1ICU0MCU0QCU1QCU0UCQ0ECVVMCVVQCVkECV1QCV1YCV0kCV1kUKwM9Z2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZxYBZmQCDw9kFgICAQ9kFgJmD2QWAmYPZBYCAgEPPCsACwBkAgcPDxYCHgdWaXNpYmxlaGQWAgIBD2QWBmYPFgIfE2hkAgEPZBYCZg8WAh8TaGQCAw9kFgJmD2QWBAIBDzwrAAsAZAIDDzwrAAsAZAIGDw8WAh8TaGQWAgIFD2QWBAICDxBkEBUECUFkb2JlIFBERg5Gb3JtYXR0ZWQgSFRNTAhSYXcgSFRNTA9FeHBvcnQgdG8gRXhjZWwVBAlBZG9iZSBQREYORm9ybWF0dGVkIEhUTUwIUmF3IEhUTUwPRXhwb3J0IHRvIEV4Y2VsFCsDBGdnZ2cWAWZkAgYPFgIfE2hkGAEFHl9fQ29udHJvbHNSZXF1aXJlUG9zdEJhY2tLZXlfXxYZBRhjdGwwMCRjdGwwMiRyYkluZGl2aWR1YWwFE2N0bDAwJGN0bDAyJHJiUmVsYXkFE2N0bDAwJGN0bDAyJHJiUmVsYXkFFmN0bDAwJGN0bDAyJHJhZEFsbFRlYW0FG2N0bDAwJGN0bDAyJHJhZFNwZWNpZmljVGVhbQUbY3RsMDAkY3RsMDIkcmFkU3BlY2lmaWNUZWFtBRxjdGwwMCRjdGwwMiRyYk5hbWVkRGF0ZVJhbmdlBRdjdGwwMCRjdGwwMiRyYkRhdGVSYW5nZQUXY3RsMDAkY3RsMDIkcmJEYXRlUmFuZ2UFImN0bDAwJGN0bDAyJHVjU3RhcnREYXRlJHJhZFRoZURhdGUFK2N0bDAwJGN0bDAyJHVjU3RhcnREYXRlJHJhZFRoZURhdGUkY2FsZW5kYXIFK2N0bDAwJGN0bDAyJHVjU3RhcnREYXRlJHJhZFRoZURhdGUkY2FsZW5kYXIFIGN0bDAwJGN0bDAyJHVjRW5kRGF0ZSRyYWRUaGVEYXRlBSljdGwwMCRjdGwwMiR1Y0VuZERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUpY3RsMDAkY3RsMDIkdWNFbmREYXRlJHJhZFRoZURhdGUkY2FsZW5kYXIFHmN0bDAwJGN0bDAyJHJhZEV2ZW50SW5kaXZpZHVhbAUZY3RsMDAkY3RsMDIkcmFkRXZlbnRSZWxheQUZY3RsMDAkY3RsMDIkcmFkRXZlbnRSZWxheQUYY3RsMDAkY3RsMDIkcmJHZW5kZXJNYWxlBRpjdGwwMCRjdGwwMiRyYkdlbmRlckZlbWFsZQUaY3RsMDAkY3RsMDIkcmJHZW5kZXJGZW1hbGUFG2N0bDAwJGN0bDAyJHJhZEJlc3RUaW1lT25seQUhY3RsMDAkY3RsMDIkcmFkQWxsVGltZXNGb3JTd2ltbWVyBSFjdGwwMCRjdGwwMiRyYWRBbGxUaW1lc0ZvclN3aW1tZXIFJWN0bDAwJGN0bDAyJGNiU2hvd0luZWxpZ2libGVUZWFtVGltZXO7vPv3pOVNYb6b7db6JmURc48CMQ=='
			eventValidation='/wEdAFLziLkFQ7pTvkj9yQNXdHcGmMwLJUVUxz/ruqloW0EARRA36MGSNcW9LVxCPwRsea5WIvmKpNl3JDvdhn+kjTw1hWs6QtgEyFm9JSu+jItKcqcxrHEIrrqwLJZwM1AODktufCJHdtQ3LZ1d+pdsa8jbNbJVKwqlnK62Mqm8LzhupdEx3jWURnX5PF40Lpz4POBypwnWD7OqmJ+MAOqgmnpVSkDhKpMVl0qR5ujhtXnO4wmjTZEoI7+FM1ZSrSlHu5VB1MJND0KwHsg7rdGBkNr8v63s6SpGKv0qCGY7S5soNIZUYOgkE2zYq+0YZ4kx5lARfGyfbhdvlwpIcJR/ZK7ZCEnvCer4RG2Ch3eI1AXU4pHUyTUC8BvuTXgFCZsgJVbIbWRo48Sn2XuDyDuWQMlzlkFXwdG/nMpjUOAilz8FP4DgnBvwMupgsw3/ofKx08a9SDtwvzpq55KGaRwz6tw93VU4daCbXparDT9GTf7OijoYJkoqdlYfS8ZrRW1/j20uvbQ6O7TyAkxmlFDS36Uk0gLtfjZcMKGifU4sO/ZgqPgRnPACojVkEjuiNVvqeV33MMXvxMP4cV0D05xwNtNdsi3D8ntytRoXxi1sJBvm8O6rx8UR1L83GRi10pDgPZzjuR4aLqnNLSrqVVBEJiP/Mm/I2RNbXwMshzXNGHAwelS23TDkFl6p4ITHG9/pvsNryAFbWvKFSFlJfNQP8L0G5+DhZpXAhFAKO85JiM1yy7yv596zVNPguIyZFHqGtUpUXHa9fbOH1JKPpLeBRL9oyfrhlvpuzhws90NerIIK8W0i3qoc+JrqchRDnG/7Rv7tvXN6l7Uz0z1nX9TPXw0t5orA2BPqZ8zb2plx3Bcz3wKkPfq51NyHuKX+hTRBB5KfyWQfjaaDHR0rQSp9w4sEpFbMw4DfifxgB+d0rcDqgRIq419/30OyTCVREdIyjFcJ17pjYXv7iTyxtNzYCCjyf866I74RA2U/8rhT+Vq3cOrvsceccibvZRjvHx1h4abUajGVxBhXtmNCpe0A2Zlbbm9Ddo/MuwHJ8vaawjC5gvyJ4UC+uoPFNxh8L5ibrY4UVAjhVym4uemx3v3ky4B3DY+g2Ql5uEb8mW8kqWRKMvhKQGSbs4RJQyl8azOqdJbnuTw5PK7wiFJdaTIzz+R4MhUwc9gqY1zhkbrUDxD3atgPv2f5CN6WZ1P37x30rFFM7qrrBZIqKjf+N2FAXy62/xu3SeRtjMf+BsT6uQ2mCZGN3gMRJh7QVr2laSgZ/3jQXFAB1e4iFPKVn3YPDR87mKAITmvp1IpBCN9zfy+HsKr18dUEvf/wc0fO9iUKql3aQMMnvX/2V73ydVbIZFltirh9GukME28PmTrP++zeOaqNqOh78wTLFtbxVl6dk3UYuGpi4FzJjo/61Y2c23hCNmeber1pUPWbWZNUwRUULeABNNY99k4OK/6StaODUm0ZTBYQIt8k2I6o0kODTEdC85lt0d+J8rpr7euYkp/IYLV+n5/e7tqIy+0qnyE13h8dnioeV2+ObvbLlkkKEhWFbu3gPOKmzsXcRTb9AR+5JSyXgRBSzylHtpi5lukh4WQppUU2wMUoiYvk2j4hP7okvJAnW99hUwc4cDo8HO7wuWyrWe1hP3/bIulToUHrK8EuJTugseUsrtN+wCkoFaqyqqz4NthZXlJBRSIdUQwBZXdomGMJrcAGZCD/CWbO91Uh8u/l2I30agN7XinSgJlkSmluMsLGFWkjnm52yyDEbQYpGks='
		elif division==3:
			viewState='/wEPDwUENTM4MQ8WBB4LVXJsUmVmZXJyZXIFU2h0dHBzOi8vbGVnYWN5LnVzYXN3aW1taW5nLm9yZy9EZXNrdG9wRGVmYXVsdC5hc3B4P1RhYklkPTMwNTUmQWxpYXM9UmFpbmJvdyZMYW5nPWVuHhNWYWxpZGF0ZVJlcXVlc3RNb2RlAgEWAmYPZBYCAgMPZBYCAgEPZBYCAgkPZBYCZg9kFgQCBA9kFgJmD2QWCAIBD2QWAmYPZBYCZg9kFgICAQ8PFgIeBFRleHRlZGQCAw9kFgICAQ9kFhBmD2QWAmYPZBYCAgEPDxYCHwIFDE5DQUEgRGl2IElJSWRkAgQPZBYEZg9kFgICAQ8PFgIfAgULQ29uZmVyZW5jZTpkZAIBD2QWAgIBDxAPFgYeDURhdGFUZXh0RmllbGQFEWxldmVsX2Rlc2NyaXB0aW9uHg5EYXRhVmFsdWVGaWVsZAUfc2Vjb25kYXJ5X29yZ2FuaXphdGlvbl9sZXZlbF9pZB4LXyFEYXRhQm91bmRnZBAVMgktLSBBbGwgLS0SQWxsZWdoZW55IE1vdW50YWluEkFtZXJpY2FuIFNvdXRod2VzdBFBcHBhbGFjaGlhbiAoQVNDKRJCbHVlZ3Jhc3MgTW91bnRhaW4QQ2FwaXRhbCBBdGhsZXRpYwpDZW50ZW5uaWFsFkNpdHkgVW5pdi4gb2YgTmV3IFlvcmsYQ29sbGVnZSBvZiBJbGxpbm9pcy9XaXNjGENvbG9uaWFsIFN0YXRlcyBBdGhsZXRpYxJDb21tb253ZWFsdGggQ29hc3QIRW1waXJlIDgYR3JlYXQgTm9ydGhlYXN0IEF0aGxldGljFEdyZWF0IFNvdXRoIEF0aGxldGljFEhlYXJ0bGFuZCBDb2xsZWdpYXRlC0luZGVwZW5kZW50FElvd2EgSW50ZXJjb2xsZWdpYXRlCExhbmRtYXJrDExpYmVyYWwgQXJ0cw5MaWJlcnR5IExlYWd1ZQtMaXR0bGUgRWFzdBNNYXNzYWNodXNldHRzIFN0YXRlEU1ldHJvcG9saXRhbiBTd2ltGE1pY2hpZ2FuIEludGVyY29sbGVnaWF0ZQ9NaWRkbGUgQXRsYW50aWMHTWlkd2VzdBlNaW5uZXNvdGEgSW50ZXJjb2xsZWdpYXRlFk5ldyBFbmdsYW5kIEludGVyY29sbC4WTmV3IEVuZ2xhbmQgU21hbGwgQ29sbBlOZXcgRW5nbGFuZCBXb21lbidzL01lbidzE05ldyBKZXJzZXkgQXRobGV0aWMOTm9ydGggQXRsYW50aWMUTm9ydGggQ29hc3QgQXRobGV0aWMWTm9ydGggRWFzdGVybiBBdGhsZXRpYxJOb3J0aGVybiBBdGhsZXRpY3MUTm9ydGh3ZXN0IENvbmZlcmVuY2UNT2hpbyBBdGhsZXRpYxVPbGQgRG9taW5pb24gQXRobGV0aWMSUGFjaWZpYyBDb2xsZWdpYXRlGVByZXNpZGVudHMnIEF0aGxldGljIENvbmYHU2t5bGluZRlTb3V0aGVybiBBdGhsZXRpYyBBc3NvY2lhE1NvdXRoZXJuIENhbGlmb3JuaWETU291dGhlcm4gQ29sbGVnaWF0ZRlTdC4gTG91aXMgSW50ZXJjb2xsZWdpYXRlFlN0YXRlIFVuaXYgb2YgTmV3IFlvcmsTVW5pdmVyc2l0eSBBdGhsZXRpYxZVcHBlciBNaWR3ZXN0IEF0aGxldGljElVTQSBTb3V0aCBBdGhsZXRpYxlXaXNjb25zaW4gSW50ZXJjb2xsZWdpYXRlFTIAAjU5AjgxAzM0NgMxMjUCODICODMCODQCODUCODYCODcCODgCOTACODkCOTEDMzM4AjkyAjkzAzEyNAI5NAI5NQI5NgMxMzACOTcCOTgCOTkDMTAwAzEwMQMxMDIDMTAzAzEwNAMxMDUDMTA2AzEwNwMxMDgDMTA5AzExMAMxMTEDMTI5AzExMgMxMTQDMzQzAzExNQMxMTYDMTEzAzExNwMxMTkDMTIwAzExOAMxMjEUKwMyZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dkZAIGD2QWAgIBD2QWAgIFDw9kFgQeCHJlYWRvbmx5BQhyZWFkb25seR4Fc3R5bGUFDWRpc3BsYXk6bm9uZTtkAggPZBYCAgEPZBYGAgMPEA8WBh8DBRVuYW1lZF9kYXRlX3JhbmdlX2Rlc2MfBAUhc2Vjb25kYXJ5X29yZ19uYW1lZF9kYXRlX3JhbmdlX2lkHwVnZBAVCBgoMSkgMjAxNy0xOCBOQ0FBIERpdiBJSUkYKDIpIDIwMTYtMTcgTkNBQSBEaXYgSUlJGCgzKSAyMDE1LTE2IE5DQUEgRGl2IElJSRgoNCkgMjAxNC0xNSBOQ0FBIERpdiBJSUkYKDUpIDIwMTMtMTQgTkNBQSBEaXYgSUlJGCg2KSAyMDEyLTEzIE5DQUEgRGl2IElJSRgoNykgMjAxMS0xMiBOQ0FBIERpdiBJSUkYKDgpIDIwMTAtMTEgTkNBQSBEaXYgSUlJFQgCNDgCNDQCMzkCMzUCMzECMjcCMjIBOBQrAwhnZ2dnZ2dnZ2RkAgcPZBYEZg8PFgYeEFNob3dQb3B1cE9uRm9jdXNoHgdNYXhEYXRlBgBwhDAgLDaNHgxTZWxlY3RlZERhdGVkZBYEZg8UKwAIDxYKHhFFbmFibGVBcmlhU3VwcG9ydGgfCQYAcIQwICw2jR8CZB4EU2tpbgUHRGVmYXVsdB4NTGFiZWxDc3NDbGFzcwUHcmlMYWJlbGQWBh4FV2lkdGgbAAAAAAAAWUAHAAAAHghDc3NDbGFzcwURcmlUZXh0Qm94IHJpSG92ZXIeBF8hU0ICggIWBh8OGwAAAAAAAFlABwAAAB8PBRFyaVRleHRCb3ggcmlFcnJvch8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUTcmlUZXh0Qm94IHJpRm9jdXNlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUTcmlUZXh0Qm94IHJpRW5hYmxlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwUUcmlUZXh0Qm94IHJpRGlzYWJsZWQfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEXJpVGV4dEJveCByaUVtcHR5HxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRByaVRleHRCb3ggcmlSZWFkHxACggJkAgIPFCsADQ8WEAUDRVJTaAUNU2VsZWN0ZWREYXRlcw8FjwFUZWxlcmlrLldlYi5VSS5DYWxlbmRhci5Db2xsZWN0aW9ucy5EYXRlVGltZUNvbGxlY3Rpb24sIFRlbGVyaWsuV2ViLlVJLCBWZXJzaW9uPTIwMTMuMS4yMjAuNDUsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MTIxZmFlNzgxNjViYTNkNBQrAAAFEUVuYWJsZU11bHRpU2VsZWN0aAUPUmVuZGVySW52aXNpYmxlZwULU3BlY2lhbERheXMPBZIBVGVsZXJpay5XZWIuVUkuQ2FsZW5kYXIuQ29sbGVjdGlvbnMuQ2FsZW5kYXJEYXlDb2xsZWN0aW9uLCBUZWxlcmlrLldlYi5VSSwgVmVyc2lvbj0yMDEzLjEuMjIwLjQ1LCBDdWx0dXJlPW5ldXRyYWwsIFB1YmxpY0tleVRva2VuPTEyMWZhZTc4MTY1YmEzZDQUKwAABQRNaW5EBgBAVyBTBVEIBQRNYXhEBgBwhDAgLDaNBRBWaWV3U2VsZWN0b3JUZXh0BQF4DxYEHwtoHwwFB0RlZmF1bHRkZBYEHw8FC3JjTWFpblRhYmxlHxACAhYEHw8FDHJjT3RoZXJNb250aB8QAgJkFgQfDwUKcmNTZWxlY3RlZB8QAgJkFgQfDwUKcmNEaXNhYmxlZB8QAgIWBB8PBQxyY091dE9mUmFuZ2UfEAICFgQfDwUJcmNXZWVrZW5kHxACAhYEHw8FB3JjSG92ZXIfEAICFgQfDwUxUmFkQ2FsZW5kYXJNb250aFZpZXcgUmFkQ2FsZW5kYXJNb250aFZpZXdfRGVmYXVsdB8QAgIWBB8PBQlyY1ZpZXdTZWwfEAICZAICDw8WBB4SRW5hYmxlQ2xpZW50U2NyaXB0aB4HRW5hYmxlZGhkZAIJD2QWBGYPDxYGHwhoHwkGAHCEMCAsNo0fCmRkFgRmDxQrAAgPFgofC2gfCQYAcIQwICw2jR8CZB8MBQdEZWZhdWx0Hw0FB3JpTGFiZWxkFgYfDhsAAAAAAABZQAcAAAAfDwURcmlUZXh0Qm94IHJpSG92ZXIfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEXJpVGV4dEJveCByaUVycm9yHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRNyaVRleHRCb3ggcmlGb2N1c2VkHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRNyaVRleHRCb3ggcmlFbmFibGVkHxACggIWBh8OGwAAAAAAAFlABwAAAB8PBRRyaVRleHRCb3ggcmlEaXNhYmxlZB8QAoICFgYfDhsAAAAAAABZQAcAAAAfDwURcmlUZXh0Qm94IHJpRW1wdHkfEAKCAhYGHw4bAAAAAAAAWUAHAAAAHw8FEHJpVGV4dEJveCByaVJlYWQfEAKCAmQCAg8UKwANDxYQBQNFUlNoBQ1TZWxlY3RlZERhdGVzDwWPAVRlbGVyaWsuV2ViLlVJLkNhbGVuZGFyLkNvbGxlY3Rpb25zLkRhdGVUaW1lQ29sbGVjdGlvbiwgVGVsZXJpay5XZWIuVUksIFZlcnNpb249MjAxMy4xLjIyMC40NSwgQ3VsdHVyZT1uZXV0cmFsLCBQdWJsaWNLZXlUb2tlbj0xMjFmYWU3ODE2NWJhM2Q0FCsAAAURRW5hYmxlTXVsdGlTZWxlY3RoBQ9SZW5kZXJJbnZpc2libGVnBQtTcGVjaWFsRGF5cw8FkgFUZWxlcmlrLldlYi5VSS5DYWxlbmRhci5Db2xsZWN0aW9ucy5DYWxlbmRhckRheUNvbGxlY3Rpb24sIFRlbGVyaWsuV2ViLlVJLCBWZXJzaW9uPTIwMTMuMS4yMjAuNDUsIEN1bHR1cmU9bmV1dHJhbCwgUHVibGljS2V5VG9rZW49MTIxZmFlNzgxNjViYTNkNBQrAAAFBE1pbkQGAEBXIFMFUQgFBE1heEQGAHCEMCAsNo0FEFZpZXdTZWxlY3RvclRleHQFAXgPFgQfC2gfDAUHRGVmYXVsdGRkFgQfDwULcmNNYWluVGFibGUfEAICFgQfDwUMcmNPdGhlck1vbnRoHxACAmQWBB8PBQpyY1NlbGVjdGVkHxACAmQWBB8PBQpyY0Rpc2FibGVkHxACAhYEHw8FDHJjT3V0T2ZSYW5nZR8QAgIWBB8PBQlyY1dlZWtlbmQfEAICFgQfDwUHcmNIb3Zlch8QAgIWBB8PBTFSYWRDYWxlbmRhck1vbnRoVmlldyBSYWRDYWxlbmRhck1vbnRoVmlld19EZWZhdWx0HxACAhYEHw8FCXJjVmlld1NlbB8QAgJkAgIPDxYEHxFoHxJoZGQCCg9kFgICAQ9kFgICAw9kFgYCAQ8QDxYGHwQFCGRpc3RhbmNlHwMFCGRpc3RhbmNlHwVnZBAVDQI1MAMxMDADMjAwAzQwMAM1MDADODAwBDEwMDAEMTUwMAQxNjUwBDIwMDAEMzAwMAQ0MDAwBDUwMDAVDQI1MAMxMDADMjAwAzQwMAM1MDADODAwBDEwMDAEMTUwMAQxNjUwBDIwMDAEMzAwMAQ0MDAwBDUwMDAUKwMNZ2dnZ2dnZ2dnZ2dnZ2RkAgQPEA8WBh8EBQlzdHJva2VfaWQfAwULc3Ryb2tlX2NvZGUfBWdkEBUFAkZSAkJLAkJSAkZMAklNFQUBMQEyATMBNAE1FCsDBWdnZ2dnZGQCBw8QDxYGHwQFCWNvdXJzZV9pZB8DBQtjb3Vyc2VfY29kZR8FZ2QQFQMDU0NZA1NDTQNMQ00VAwExATIBMxQrAwNnZ2dkZAILD2QWAgIBD2QWAgIDD2QWBgIBDxAPFgYfBAUIZGlzdGFuY2UfAwUIZGlzdGFuY2UfBWdkEBUDAzIwMAM0MDADODAwFQMDMjAwAzQwMAM4MDAUKwMDZ2dnZGQCBA8QDxYGHwQFCXN0cm9rZV9pZB8DBQtzdHJva2VfY29kZR8FZ2QQFQIERlItUgVNRUQtUhUCATYBNxQrAwJnZ2RkAgcPEA8WBh8EBQljb3Vyc2VfaWQfAwULY291cnNlX2NvZGUfBWdkEBUDA1NDWQNTQ00DTENNFQMBMQEyATMUKwMDZ2dnZGQCDw9kFgICAQ9kFgICAQ8QDxYGHwMFDXN0YW5kYXJkX25hbWUfBAUZc2Vjb25kYXJ5X29yZ19zdGFuZGFyZF9pZB8FZ2QQFQMBQQFCAk5TFQMBNwE4ATkUKwMDZ2dnZGQCFQ9kFgJmD2QWAgIBDw8WAh8CBTBTaG93IFRlYW1zIHRoYXQgYXJlIEluZWxpZ2libGUgZm9yIE5DQUEgQ2hhbXBzPzpkZAIFD2QWAgIBD2QWCAIBDw8WAh8CBQtDb25mZXJlbmNlOmRkAgMPEA8WBh8DBRFsZXZlbF9kZXNjcmlwdGlvbh8EBR9zZWNvbmRhcnlfb3JnYW5pemF0aW9uX2xldmVsX2lkHwVnZBAVMgktLSBBbGwgLS0SQWxsZWdoZW55IE1vdW50YWluEkFtZXJpY2FuIFNvdXRod2VzdBFBcHBhbGFjaGlhbiAoQVNDKRJCbHVlZ3Jhc3MgTW91bnRhaW4QQ2FwaXRhbCBBdGhsZXRpYwpDZW50ZW5uaWFsFkNpdHkgVW5pdi4gb2YgTmV3IFlvcmsYQ29sbGVnZSBvZiBJbGxpbm9pcy9XaXNjGENvbG9uaWFsIFN0YXRlcyBBdGhsZXRpYxJDb21tb253ZWFsdGggQ29hc3QIRW1waXJlIDgYR3JlYXQgTm9ydGhlYXN0IEF0aGxldGljFEdyZWF0IFNvdXRoIEF0aGxldGljFEhlYXJ0bGFuZCBDb2xsZWdpYXRlC0luZGVwZW5kZW50FElvd2EgSW50ZXJjb2xsZWdpYXRlCExhbmRtYXJrDExpYmVyYWwgQXJ0cw5MaWJlcnR5IExlYWd1ZQtMaXR0bGUgRWFzdBNNYXNzYWNodXNldHRzIFN0YXRlEU1ldHJvcG9saXRhbiBTd2ltGE1pY2hpZ2FuIEludGVyY29sbGVnaWF0ZQ9NaWRkbGUgQXRsYW50aWMHTWlkd2VzdBlNaW5uZXNvdGEgSW50ZXJjb2xsZWdpYXRlFk5ldyBFbmdsYW5kIEludGVyY29sbC4WTmV3IEVuZ2xhbmQgU21hbGwgQ29sbBlOZXcgRW5nbGFuZCBXb21lbidzL01lbidzE05ldyBKZXJzZXkgQXRobGV0aWMOTm9ydGggQXRsYW50aWMUTm9ydGggQ29hc3QgQXRobGV0aWMWTm9ydGggRWFzdGVybiBBdGhsZXRpYxJOb3J0aGVybiBBdGhsZXRpY3MUTm9ydGh3ZXN0IENvbmZlcmVuY2UNT2hpbyBBdGhsZXRpYxVPbGQgRG9taW5pb24gQXRobGV0aWMSUGFjaWZpYyBDb2xsZWdpYXRlGVByZXNpZGVudHMnIEF0aGxldGljIENvbmYHU2t5bGluZRlTb3V0aGVybiBBdGhsZXRpYyBBc3NvY2lhE1NvdXRoZXJuIENhbGlmb3JuaWETU291dGhlcm4gQ29sbGVnaWF0ZRlTdC4gTG91aXMgSW50ZXJjb2xsZWdpYXRlFlN0YXRlIFVuaXYgb2YgTmV3IFlvcmsTVW5pdmVyc2l0eSBBdGhsZXRpYxZVcHBlciBNaWR3ZXN0IEF0aGxldGljElVTQSBTb3V0aCBBdGhsZXRpYxlXaXNjb25zaW4gSW50ZXJjb2xsZWdpYXRlFTIAAjU5AjgxAzM0NgMxMjUCODICODMCODQCODUCODYCODcCODgCOTACODkCOTEDMzM4AjkyAjkzAzEyNAI5NAI5NQI5NgMxMzACOTcCOTgCOTkDMTAwAzEwMQMxMDIDMTAzAzEwNAMxMDUDMTA2AzEwNwMxMDgDMTA5AzExMAMxMTEDMTI5AzExMgMxMTQDMzQzAzExNQMxMTYDMTEzAzExNwMxMTkDMTIwAzExOAMxMjEUKwMyZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2cWAWZkAgcPEA8WBh8DBQhsc2NfbmFtZR8EBQZsc2NfaWQfBWdkEBU9CS0tIEFsbCAtLRNBRElST05EQUNLIFNXSU1NSU5HD0FMQVNLQSBTV0lNTUlORxtBTExFR0hFTlkgTU9VTlRBSU4gU1dJTU1JTkcQQVJJWk9OQSBTV0lNTUlORxFBUktBTlNBUyBTV0lNTUlORw9CT1JERVIgU1dJTU1JTkcbQ0VOVFJBTCBDQUxJRk9STklBIFNXSU1NSU5HEUNPTE9SQURPIFNXSU1NSU5HFENPTk5FQ1RJQ1VUIFNXSU1NSU5HG0ZMT1JJREEgR09MRCBDT0FTVCBTV0lNTUlORxBGTE9SSURBIFNXSU1NSU5HEEdFT1JHSUEgU1dJTU1JTkcNR1VMRiBTV0lNTUlORxFIQVdBSUlBTiBTV0lNTUlORxFJTExJTk9JUyBTV0lNTUlORxBJTkRJQU5BIFNXSU1NSU5HFklOTEFORCBFTVBJUkUgU1dJTU1JTkcNSU9XQSBTV0lNTUlORxFLRU5UVUNLWSBTV0lNTUlORxJMQUtFIEVSSUUgU1dJTU1JTkcSTE9VSVNJQU5BIFNXSU1NSU5HDk1BSU5FIFNXSU1NSU5HEU1BUllMQU5EIFNXSU1NSU5HFU1FVFJPUE9MSVRBTiBTV0lNTUlORxFNSUNISUdBTiBTV0lNTUlORxhNSURETEUgQVRMQU5USUMgU1dJTU1JTkcTTUlEV0VTVEVSTiBTV0lNTUlORxJNSU5ORVNPVEEgU1dJTU1JTkcUTUlTU0lTU0lQUEkgU1dJTU1JTkcYTUlTU09VUkkgVkFMTEVZIFNXSU1NSU5HEE1PTlRBTkEgU1dJTU1JTkcUTkVXIEVOR0xBTkQgU1dJTU1JTkcTTkVXIEpFUlNFWSBTV0lNTUlORxNORVcgTUVYSUNPIFNXSU1NSU5HEE5JQUdBUkEgU1dJTU1JTkcXTk9SVEggQ0FST0xJTkEgU1dJTU1JTkcVTk9SVEggREFLT1RBIFNXSU1NSU5HFE5PUlRIIFRFWEFTIFNXSU1NSU5HDU9ISU8gU1dJTU1JTkcRT0tMQUhPTUEgU1dJTU1JTkcPT1JFR09OIFNXSU1NSU5HDk9aQVJLIFNXSU1NSU5HGlBBQ0lGSUMgTk9SVEhXRVNUIFNXSU1NSU5HEFBBQ0lGSUMgU1dJTU1JTkcXUE9UT01BQyBWQUxMRVkgU1dJTU1JTkcbU0FOIERJRUdPLUlNUEVSSUFMIFNXSU1NSU5HFlNJRVJSQSBORVZBREEgU1dJTU1JTkcUU05BS0UgUklWRVIgU1dJTU1JTkcXU09VVEggQ0FST0xJTkEgU1dJTU1JTkcVU09VVEggREFLT1RBIFNXSU1NSU5HFFNPVVRIIFRFWEFTIFNXSU1NSU5HFVNPVVRIRUFTVEVSTiBTV0lNTUlORxxTT1VUSEVSTiBDQUxJRk9STklBIFNXSU1NSU5HDFVTQSBTV0lNTUlORw1VVEFIIFNXSU1NSU5HEVZJUkdJTklBIFNXSU1NSU5HE1dFU1QgVEVYQVMgU1dJTU1JTkcWV0VTVCBWSVJHSU5JQSBTV0lNTUlORxJXSVNDT05TSU4gU1dJTU1JTkcQV1lPTUlORyBTV0lNTUlORxU9AAJBRAJBSwJBTQJBWgJBUgJCRAJDQwJDTwJDVAJGRwJGTAJHQQJHVQJISQJJTAJJTgJJRQJJQQJLWQJMRQJMQQJNRQJNRAJNUgJNSQJNQQJNVwJNTgJNUwJNVgJNVAJORQJOSgJOTQJOSQJOQwJORAJOVAJPSAJPSwJPUgJPWgJQTgJQQwJQVgJTSQJTTgJTUgJTQwJTRAJTVAJTRQJDQQJVUwJVVAJWQQJXVAJXVgJXSQJXWRQrAz1nZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnZ2dnFgFmZAIPD2QWAgIBD2QWAmYPZBYCZg9kFgICAQ88KwALAGQCBw8PFgIeB1Zpc2libGVoZBYCAgEPZBYGZg8WAh8TaGQCAQ9kFgJmDxYCHxNoZAIDD2QWAmYPZBYEAgEPPCsACwBkAgMPPCsACwBkAgYPDxYCHxNoZBYCAgUPZBYEAgIPEGQQFQQJQWRvYmUgUERGDkZvcm1hdHRlZCBIVE1MCFJhdyBIVE1MD0V4cG9ydCB0byBFeGNlbBUECUFkb2JlIFBERg5Gb3JtYXR0ZWQgSFRNTAhSYXcgSFRNTA9FeHBvcnQgdG8gRXhjZWwUKwMEZ2dnZxYBZmQCBg8WAh8TaGQYAQUeX19Db250cm9sc1JlcXVpcmVQb3N0QmFja0tleV9fFhkFGGN0bDAwJGN0bDAyJHJiSW5kaXZpZHVhbAUTY3RsMDAkY3RsMDIkcmJSZWxheQUTY3RsMDAkY3RsMDIkcmJSZWxheQUWY3RsMDAkY3RsMDIkcmFkQWxsVGVhbQUbY3RsMDAkY3RsMDIkcmFkU3BlY2lmaWNUZWFtBRtjdGwwMCRjdGwwMiRyYWRTcGVjaWZpY1RlYW0FHGN0bDAwJGN0bDAyJHJiTmFtZWREYXRlUmFuZ2UFF2N0bDAwJGN0bDAyJHJiRGF0ZVJhbmdlBRdjdGwwMCRjdGwwMiRyYkRhdGVSYW5nZQUiY3RsMDAkY3RsMDIkdWNTdGFydERhdGUkcmFkVGhlRGF0ZQUrY3RsMDAkY3RsMDIkdWNTdGFydERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUrY3RsMDAkY3RsMDIkdWNTdGFydERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUgY3RsMDAkY3RsMDIkdWNFbmREYXRlJHJhZFRoZURhdGUFKWN0bDAwJGN0bDAyJHVjRW5kRGF0ZSRyYWRUaGVEYXRlJGNhbGVuZGFyBSljdGwwMCRjdGwwMiR1Y0VuZERhdGUkcmFkVGhlRGF0ZSRjYWxlbmRhcgUeY3RsMDAkY3RsMDIkcmFkRXZlbnRJbmRpdmlkdWFsBRljdGwwMCRjdGwwMiRyYWRFdmVudFJlbGF5BRljdGwwMCRjdGwwMiRyYWRFdmVudFJlbGF5BRhjdGwwMCRjdGwwMiRyYkdlbmRlck1hbGUFGmN0bDAwJGN0bDAyJHJiR2VuZGVyRmVtYWxlBRpjdGwwMCRjdGwwMiRyYkdlbmRlckZlbWFsZQUbY3RsMDAkY3RsMDIkcmFkQmVzdFRpbWVPbmx5BSFjdGwwMCRjdGwwMiRyYWRBbGxUaW1lc0ZvclN3aW1tZXIFIWN0bDAwJGN0bDAyJHJhZEFsbFRpbWVzRm9yU3dpbW1lcgUlY3RsMDAkY3RsMDIkY2JTaG93SW5lbGlnaWJsZVRlYW1UaW1lc+5Ck46k+HzG6+bV8EtP1yTiy1BT'
			eventValidation='/wEdAG8YVePJCoRWPuS+blKWcagYmMwLJUVUxz/ruqloW0EARRA36MGSNcW9LVxCPwRsea5WIvmKpNl3JDvdhn+kjTw1IQb8j+9qi4mNfs1KlPHxt7P4AUsKMnLhMPP+aw7zL8Y1D4rH//yw0nHvyX7GbtQoxMnmZuCJw1Si2ebFR4Fd44nzRqwqL3Yc6J17xZPA7iBI91s9eKJ1XNX7bCRBJ3bUFjMSFS1f5hCCa8AfVr6eoRZwVTORENLajvg9r8Ab+ZXO61yirOt0c6nJP/uBr2MLY3JRXD682NJnb1bMEJynSXGOpimCHtOC+KIprUFoqZCFx1iOfKFfHYQ/3DAxm2lHqKbjiywpgHSc+BoASNC6IMTznWiRI1pPQpbitGbYrFF/38PNghYdEK3ujMYVCs3cx2QrOdqSEYzuXFfmmNGXbNGi2NfcsefLP7HKbTheAyPlLbmeX62rlg701Y2E4JzXaoIGO7U18pksXUAGGy87GcHCCR68jfZbvCFswvzTjRaEBPJvXkMRecDW+NebvWhMgYZH7OcpAHPKcbLSBqVG8ew98nBMom+RuVbbiJiIcfdPZMq7zAB4XtWFJbym4YwAW9BVFf2OnNoONZiP7TO3NR6a+tuihOlr05CHOSuzaSn70jKHIXDV1zSSOUfqmpzyKce2Yj3jZMUGhHCvFOGOYdqfmOmcT1h5jDpdWjlXQF1OUpNPIshZfv5Lzki1J0ISxKqz93Mi2VKEEciSJwh0KbHomd5OrBzj257icVYURZ6ONl14ndxijv2jTnseAaAU+e3mOpgvKpNprshBI2vjUYeIP+HJipLhgHsBZ7itc53xoAP+4+D8xSdo9h6dYt+tNU6MYH8swX1J1QqfkqJ3DUoB7rVNFDXN/i8+3gh4kVr0YiQEohiIvVnKePPcAZIeD8EriiZwcidpLys8nmjwnddjy5bkyo1A+Ug4oKEPVr6kqHrJbhEKRJhhiqVuRZ8BYaZdrdm7TrM9L1Yfu/k/9G+5Y1RC2sYBBHjV/AH68vCe2f3O0HP+EJwso1Un0li2ygetIiC6VJ93cQU+x8DG0sp5Uw8zIXwCsvS1LCojswguQh0GiuWBU3alyj/XXfQzkVenknuLUS/W4yZd1CI/lzoYJkoqdlYfS8ZrRW1/j20uvbQ6O7TyAkxmlFDS36Uk0gLtfjZcMKGifU4sO/ZgqPgRnPACojVkEjuiNVvqeV33MMXvxMP4cV0D05xwNtNdsi3D8ntytRoXxi1sJBvm8OnheRlDaqIF+G8XkQcqwP0Els/vFmwbC1wiN665CSZ4mYLYZLg09zy97wXWIqs8hpl0rQUS1VWF4GiD+AxXTPTd8qWHjixar6W4qhbD/Q84jZV9arrjRo1nXNK4hXthfNduRtm54QD4SrmMxZNbEOImJ/e5E3kH1+r0e3k03uEbyfrhlvpuzhws90NerIIK8W0i3qoc+JrqchRDnG/7Rv7tvXN6l7Uz0z1nX9TPXw0t5orA2BPqZ8zb2plx3Bcz3wKkPfq51NyHuKX+hTRBB5KfyWQfjaaDHR0rQSp9w4sEpFbMw4DfifxgB+d0rcDqgRIq419/30OyTCVREdIyjFcJ17pjYXv7iTyxtNzYCCjyf866I74RA2U/8rhT+Vq3cOrvsceccibvZRjvHx1h4abUajGVxBhXtmNCpe0A2Zlbbm9Ddo/MuwHJ8vaawjC5gvyJ4UC+uoPFNxh8L5ibrY4UVAjhVym4uemx3v3ky4B3DY+g2Ql5uEb8mW8kqWRKMvhKQGSbs4RJQyl8azOqdJbnuTw5PK7wiFJdaTIzz+R4MhUwc9gqY1zhkbrUDxD3atgPv2f5CN6WZ1P37x30rFFM7qrrBZIqKjf+N2FAXy62/xu3SeRtjMf+BsT6uQ2mCZGN3gMRJh7QVr2laSgZ/3jQXFAB1e4iFPKVn3YPDR87mKAITmvp1IpBCN9zfy+HsKr18dUEvf/wc0fO9iUKql3aQMMnvX/2V73ydVbIZFltirh9GukME28PmTrP++zeOaqNqOh78wTLFtbxVl6dk3UYuGpi4FzJjo/61Y2c23hCNmeber1pUPWbWZNUwRUULeABNNY99k4OK/6StaODUm0ZTBYQIt8k2I6o0kODTEdC85lt0d+J8rpr7euYkp/IYLV+n5/e7tqIy+0qnyE13h8dnioeV2+ObvbLlkkKEhWF4JAh3LTGdnfRBexZIGIN1kGHGs4HUmFL7VunNezb8FQqoC2sqFnGJfY0gZeNylU3bKtZ7WE/f9si6VOhQesrwS4lO6Cx5Syu037AKSgVqrKqrPg22FleUkFFIh1RDAFld2iYYwmtwAZkIP8JZs73VSHy7+XYjfRqA3teKdKAmWSP4MmYOhcb/vsIBT2gO1DCSzyyxw=='
		else:
			return

	rStroke = '6'
	if relInd=='rbRelay':
		rDistance = distance
	else:
		rDistance = '200'

	# do some date conversion if using a manual date range
	dateType = 'rbNamedDateRange'
	SD = ''
	ED = ''
	SDValid = ''
	EDValid = ''
	if startDate!='' and endDate !='':
		dateType = 'rbDateRange'
		split = startDate.split('/')
		if int(split[1]) < 10:
			split[1] = '0' + split[1]
		if int(split[0]) < 10:
			split[0] = '0' + split[0]
		SD = split[2] + '-' + split[0] + '-' + split[1]
		split = endDate.split('/')
		if int(split[1]) < 10:
			split[1] = '0' + split[1]
		if int(split[0]) < 10:
			split[0] = '0' + split[0]
		ED = split[2] + '-' + split[0] + '-' + split[1]
		SDValid = SD + '-00-00-00'
		EDValid = ED + '-00-00-00'

	# translate the year being used
	dateDict = {'19 DI':'53', '19 DII': '54', '19 DIII': '55', '18 DI': '46', '18 DII': '47', '18 DIII': '48',
				'17 DI': '42', '17 DII': '43', '17 DIII': '44', '16 DI': '37', '16 DII': '38', '16 DIII': '39',
				'15 DIII': '35', '14 DIII': '31', '13 DIII': '27', '12 DIII': '22', '11 DIII': '8', '15 DI': '33',
				'14 DI': '30', '13 DI': '25', '12 DI': '20', '11 DI': '7', '10 DI': '4', '09 DI': '5', '08 DI': '6',
				'15 DII': '34', '14 DII': '29', '13 DII': '26', '12 DII': '21', '11 DII': '9'}
	dateNum = dateDict[date]
	revd = dict([reversed(i) for i in dateDict.items()])
	# make sure we can translate back as well
	dateDict.update(revd)
	# translate strokes
	if stroke=='FR':
		strokeOut = 'Freestyle'
		stroke = '1'
	elif stroke=='BK':
		strokeOut='Backstroke'
		stroke = '2'
	elif stroke=='BR':
		strokeOut='Breastroke'
		stroke = '3'
	elif stroke=='FL':
		strokeOut='Butterfly'
		stroke = '4'
	elif stroke=='IM':
		strokeOut='IM'
		stroke = '5'
	elif stroke=='FR-R':
		strokeOut='Freestyle Relay'
		stroke = '1'
		rStroke = '6'
	elif stroke=='MED-R':
		strokeOut='Medley Relay'
		stroke = '1'
		rStroke = '7'

	# translate best or all times, D1 men relays broken for now
	if 'all' in bestAll and not (rStroke in ['6','7'] and division==1 and gender=='m'):
		bestAll = 'radAllTimesForSwimmer'
	else:
		bestAll = 'radBestTimeOnly'

	# translate gender
	if 'f' in gender.lower():
		gender = 'rbGenderFemale'
		genderOut ='Women'
	else:
		gender = 'rbGenderMale'
		genderOut = 'Men'

	payload = {
		'ctl00$RadScriptManager1': 'ctl00$ctl02$updpnlSearh|ctl00$ctl02$btnSearch',
		'RadScriptManager1_TSM': ';;System.Web.Extensions, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35:en:d28568d3-e53e-4706-928f-3765912b66ca:ea597d4b:b25378d2;Telerik.Web.UI, Version=2013.1.220.45, Culture=neutral, PublicKeyToken=121fae78165ba3d4:en:3e3b0da6-8c39-4d10-9111-25eaee1f7355:16e4e7cd:ed16cbdc:f7645509:8674cba1:7c926187:b7778d6c:c08e9f8a:59462f1:a51ee93e;',
		'RadStyleSheetManager1_TSSM': ';Telerik.Web.UI, Version=2013.1.220.45, Culture=neutral, PublicKeyToken=121fae78165ba3d4:en:3e3b0da6-8c39-4d10-9111-25eaee1f7355:aac1aeb7:c73cf106:c86a4a06:4c651af2',
		'__EVENTTARGET': '',
		'__EVENTARGUMENT': '',
		'__VIEWSTATE': viewState,
		'__VIEWSTATEGENERATOR': 'DEAEDF11',
		'__EVENTVALIDATION': eventValidation,
		'ctl00_Header1_rmPortalTabs_i0_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i1_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i2_i0_ctl03_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i2_i0_ctl07_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i3_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i4_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i5_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i6_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i7_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i8_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_i9_i0_ctl00_ClientState': '',
		'ctl00_Header1_rmPortalTabs_ClientState': '',
		'ctl00$ctl02$TimeType': relInd,
		'ctl00$ctl02$ddLevel1': conference,
		'ctl00$ctl02$radTeam': team,
		'ctl00$ctl02$txtTeamName': '',
		'ctl00$ctl02$hidTeamId': '',
		'ctl00$ctl02$Date': dateType,
		'ctl00$ctl02$ddNamedDateRange': dateNum,
		'ctl00$ctl02$ucStartDate$radTheDate': SD,
		'ctl00$ctl02$ucStartDate$radTheDate$dateInput': startDate,
		'ctl00_ctl02_ucStartDate_radTheDate_dateInput_ClientState': '{"enabled":true,"emptyMessage":"","validationText":"' + SDValid + '","valueAsString":"'+SDValid+'","minDateStr":"1900-01-01-00-00-00","maxDateStr":"3016-07-12-00-00-00"}',
		'ctl00_ctl02_ucStartDate_radTheDate_calendar_SD': '[]',
		'ctl00_ctl02_ucStartDate_radTheDate_calendar_AD': '[[1900,1,1],[3013,11,5],[2013,11,5]]',
		'ctl00_ctl02_ucStartDate_radTheDate_ClientState': '{"minDateStr":"1900-01-01-00-00-00","maxDateStr":"3013-11-05-00-00-00"}',
		'ctl00$ctl02$ucEndDate$radTheDate': ED,
		'ctl00$ctl02$ucEndDate$radTheDate$dateInput': endDate,
		'ctl00_ctl02_ucEndDate_radTheDate_dateInput_ClientState': '{"enabled":true,"emptyMessage":"","validationText":"'+EDValid+'","valueAsString":"'+EDValid+'","minDateStr":"1900-01-01-00-00-00","maxDateStr":"3013-11-05-00-00-00"}',
		'ctl00_ctl02_ucEndDate_radTheDate_calendar_SD': '[]',
		'ctl00_ctl02_ucEndDate_radTheDate_calendar_AD': '[[1900,1,1],[3016,11,5],[2016,11,5]]',
		'ctl00_ctl02_ucEndDate_radTheDate_ClientState': '{"minDateStr":"1900-01-01-00-00-00","maxDateStr":"3016-11-05-00-00-00"}',
		'ctl00$ctl02$Event': eventType,
		'ctl00$ctl02$ucDistanceStrokeCourseCtl$ddDistance': distance,
		'ctl00$ctl02$ucDistanceStrokeCourseCtl$ddStroke': stroke,
		'ctl00$ctl02$ucDistanceStrokeCourseCtl$ddCourse': '1',
		'ctl00$ctl02$ucDistanceStrokeCourseRelayCtl$ddDistance': rDistance,
		'ctl00$ctl02$ucDistanceStrokeCourseRelayCtl$ddStroke': rStroke,
		'ctl00$ctl02$ucDistanceStrokeCourseRelayCtl$ddCourse': '1',
		'ctl00$ctl02$gender': gender,
		'ctl00$ctl02$ddStandard': cut,
		'ctl00$ctl02$radTimesToInclude': bestAll,
		'ctl00$ctl02$txtMaxResults': number,
		'ctl00$ctl02$cbShowIneligibleTeamTimes': 'on',
		'__ASYNCPOST': 'true',
		'ctl00$ctl02$btnSearch': 'Search'
	}

	# probably most of this info is not necessary
	headers = {
		'Accept': '*/*',
		'Accept-Encoding': 'gzip, deflate, br',
		'Accept-Language': 'en-US,en;q=0.8',
		'Cache-Control': 'no-cache',
		'Connection': 'keep-alive',
		'Content-Length': '15658	',
		'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
		'Cookie': 'PortalAlias=Rainbow; ASP.NET_SessionId=yi434cvjd30ivcbk4qr0cvgn; sflfpw=1; Esperantus_Language_Rainbow=en; BIGipServerVSSWIMSWEB_8080_pool=!j1fkbpZTxPRu/0wnsZ1Ff84UkPqNMqUT5JI3thkMv5++26vovSRt+sxcJKzEoWl3DWAVaAWz/YfOe8E=',
		'Host': 'legacy.usaswimming.org',
		'Origin': 'https://legacy.usaswimming.org',
		'Referer': URL,
		'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) '
					  'Chrome/58.0.3029.110 Safari/537.36',
		'X-MicrosoftAjax': 'Delta=true',
		'X-Requested-With': 'XMLHttpRequest'
	}

	html = requests.post(URL, data=payload, headers=headers).text

	# find a good place to start parsing
	place = html.find('Meet Results</td>') + 20
	end = html.find('</table>', place + 1000)
	count = 0
	event = str(distance) + ' ' + strokeOut
	num = 0
	times_dict = []
	keys = set()

	# parse the individual times looping through the html
	# there is so much extra junk in the html this is faster than fully parsing
	if relInd=='rbIndividual':
		while place > 0:
			start = Time.time()
			place = html.find('</td>', place+1, end)
			count = (count + 1) % 12
			if count == 1:
				time, swimmer, team, meet, date = None, None, None, None, None
			if count==2:
				time = html[html.find('>', place+5)+1:html.find('<', place+9)]
			if count==4:
				swimmer = html[html.find('>', place+5)+1:html.find('<', place+9)]
			if count==5:
				age = html[html.find('>', place+5)+1:html.find('<', place+9)]
			if count==6:
				team = html[html.find('>', place+5)+1:html.find('<', place+9)]
			if count==7:
				year = html[html.find('>', place+5)+1:html.find('<', place+9)]
			if count==8:
				meet = html[html.find('>', place+5)+1:html.find('<', place+9)]
			if count==9:
				date = html[html.find('>', place+5)+1:html.find('<', place+9)]
				if time=='Alt Adj' or not time or time=='':
					continue
				# print meet, date, swimmer, year, team, genderOut, event, time, age
				if conference != '':
					conf_name = conferenceMap[conference]
				else:
					conf_name = None
				start = Time.time()
				# insert into staging table if key doesn't exist
				key = hash(swimmer + event + time + date)
				if key not in keys:
					keys.add(key)
					start = Time.time()
					num += 1
					new_swim = {'meet': meet, 'date': date, 'season': season, 'name': swimmer,
							'team': team, 'gender': genderOut, 'event': event, 'time': time, 'division': division,
							'relay': False, 'year': year, 'conference':conf_name}
					clean = clean_data(new_swim)
					if clean:
						times_dict.append(clean)

	# parse relays
	elif relInd=='rbRelay':
		while place > 0:
			place = html.find('</td>', place+1, end)
			count = (count+1) % 8
			if count == 1:
				time, swimmer, team, meet, date = None, None, None, None, None
			if count==2:
				time = html[html.find('>', place + 5) + 1:html.find('<', place + 9)]
			if count==3:
				team = html[html.find('>', place + 5) + 1:html.find('<', place + 9)]
			if count==4:
				meet = html[html.find('>', place + 5) + 1:html.find('<', place + 9)]
			if count==5:
				date = html[html.find('>', place + 5) + 1:html.find('<', place + 9)]
				#print time, team, meet, date
				if 'nbsp' in team:
					continue
				swimmer = team + ' Relay'
				if time=='Time' or not time:
					continue
				swimmer = swimmer.replace('<br>', '')

				if conference != '':
					conf_name = conferenceMap[conference]
				else:
					conf_name = None

				# insert into staging table if key doesn't exist
				key = hash(swimmer + event + time + date)
				if key not in keys:
					keys.add(key)
					num += 1
					new_swim = {'meet': meet, 'date': date, 'season': season, 'name': swimmer,
							'team': team, 'gender': genderOut, 'event': event, 'time': time, 'division': division,
							'relay': True, 'year': None, 'conference': conf_name}
					clean = clean_data(new_swim)
					if clean:
						times_dict.append(clean)

	# load all times into staging table
	if len(times_dict) > 0:
		print 'Swims: ', len(times_dict)
		Swimstaging.insert_many(times_dict).execute()

	return num

confTeams = getNewConfs()
# cleans up data to be inserted
def clean_data(data):
	data['season'] = int(data['season']) + 2000
	data['time'] = toTime(data['time'])
	from events import badEventMap, eventConvert
	if data['name'] == '&nbsp;' or data['team']=='&nbsp;':  # junk data
		return

	# meters and other bad meets
	if data['meet'] in ['Youth Olympic Games Buenos Aires 2018'] \
			or '25m' in data['meet'] or 'Campeonato' in data['meet']:
		return

	# convert bad event names
	if data['event'] in badEventMap:
		data['event'] = badEventMap[data['event']]

	# invert dictionary
	convert = dict([[v, k] for k,v in eventConvert.items()])
	convert['50 Yard Medley Relay'] = '200 Medley Relay'
	convert['50 Yard Freestyle Relay'] = '200 Free Relay'
	if data['event'] in convert:
		data['event'] = convert[data['event']]

	data['division'] = 'D' + str(data['division'])

	if not data['conference']:
		try:
			data['conference'] = confTeams[data['division']][data['gender']][str(data['season'])][data['team']]
		except KeyError:
			try:  # try last year if not this year loaded
				data['conference'] = confTeams[data['division']][data['gender']][str(data['season']-1)][data['team']]
			except KeyError:
				data['conference'] = None

	return data

# pull team/conference info from file
def getConfs():
	confTeams = {}
	with open('bin/conferences.txt', 'r') as file:
		for line in file:
			parts = re.split('\t', line.strip())
			division = parts[0]
			gender = parts[1]
			year = '20' + parts[2]
			conf = parts[3]
			team = parts[4]
			if not division in confTeams:
				confTeams[division] = {}
			if not gender in confTeams[division]:
				confTeams[division][gender] = {}
			if not year in confTeams[division][gender]:
				confTeams[division][gender][year] = {}
			if not conf in confTeams[division][gender][year]:
				confTeams[division][gender][year][team] = conf
	return confTeams


def topTimesLoop():
	best_all = 'all'  #'all'
	confDiv = getConfs()
	genders = ['m', 'f']
	divisions = ['DI', 'DII', 'DIII']
	distances = dict()
	distances['FR'] = [50, 100, 200, 500, 1000, 1650]
	distances['FL'] = [100, 200]
	distances['BK'] = [100, 200]
	distances['BR'] = [100, 200]
	distances['IM'] = [200, 400]
	distances['MED-R'] = [200, 400]
	distances['FR-R'] = [200, 400, 800]
	conferences = ['']
	years = ['19'] #c,'17','16','15','14','13','12','11','10']

	for year in years:
		for division in divisions:
			if division == 'DI':
				divNum = 'D1'
			elif division == 'DII':
				divNum = 'D2'
			else:
				divNum = 'D3'
			for gender in genders:
				for conference in conferences:
					if conference == '':
						confName = 'all'
					else:
						confName = conferenceMap[conference]
					if confName in confDiv and confDiv[confName] != divNum:
						continue
					for stroke in distances:
						for distance in distances[stroke]:
							print year, division, gender, distance, stroke

							# now find the times and load them into the new file if they aren't in the old
							print getTopTimes(date=year+' '+division, distance=distance,
									stroke=stroke, gender=gender, conference=conference, bestAll=best_all,
											  number=7000, season=year)
	#purposefuly load duplicates then delete
	print 'deleting dups'
	Swimstaging.raw('DELETE '
		'FROM swimstaging '
		'USING ( '
		'SELECT count(s1.id), s1.id AS swim1, s2.id AS swim2 '
		'FROM swimstaging s1, swimstaging s2 '
		'WHERE s1.name=s2.name and s1.event=s2.event and s1.time=s2.time and s1.date=s2.date and s1.id!=s2.id '
		'GROUP BY s1.id, s2.id '
		') AS s '
		'WHERE swimstaging.id = s.swim1').execute()


# get 100 free results for every conference to figure out which teams are in a conference and division
def scrapeConferenceData(yearNum=19):
	genders = ['m', 'f']
	divisions = ['DI', 'DII', 'DIII']
	distances = {}
	distances['FR'] = [100]
	conferences = conferenceMap
	years = [str(yearNum)]  #, '17', '16', '15', '14', '13', '12', '11']

	directory = 'data'
	for year in years:
		for division in divisions:
			for gender in genders:
				filePath = directory + '/confs/' + division + year + gender
				with open(filePath, 'w+') as meetFile:
					for conference in conferences:
						print conferenceMap[conference]
						for stroke in distances:
							for distance in distances[stroke]:
								print year, division, gender, distance, stroke

								# now find the times and load them into the new file if they aren't in the old
								print conference
								print getTopTimes(date=year+' '+division, distance=distance,
											stroke=stroke, gender=gender, conference=conference, bestAll='best',
												  number=7000, season=year)


# parse data stored from getConferenceData and store conference mapping to a file
def storeConfs():
	confs = {'D1': {'Men': {}, 'Women': {}}, 'D2': {'Men': {}, 'Women': {}}, 'D3': {'Men': {}, 'Women': {}}}
	root = 'data/confs/'
	for fileName in os.listdir(root):
		with open(root + fileName, 'r') as file:
			match = re.search('(\D+)(\d+)([mf])', fileName)
			if not match:
				continue
			division, year, gender = match.groups()
			if division == 'DI':
				div = 'D1'
			elif division == 'DII':
				div = 'D2'
			else:
				div = 'D3'
			for line in file:
				swimArray = re.split('\t', line)
				# meet = swimArray[0].strip()
				# d = swimArray[1]
				# name = swimArray[2]
				# year = swimArray[3]
				team = swimArray[4]
				gender = swimArray[5]
				# event = swimArray[6]
				# time = toTime(swimArray[7])
				conf = swimArray[8].strip()

				if not year in confs[div][gender]:
					confs[div][gender][year] = {}
				if not conf in confs[div][gender][year]:
					confs[div][gender][year][conf] = set()

				confs[div][gender][year][conf].add(team)

	with open('data/conferences.txt', 'w+') as file:
		for div in confs:
			for gender in confs[div]:
				for year in confs[div][gender]:
					for conf in confs[div][gender][year]:
						for team in confs[div][gender][year][conf]:
							file.write(div+'\t'+gender+'\t'+year+'\t'+conf+'\t'+team+'\n')
							#print div, gender, year, conf, team.strip()


def updateConfs(year=19):
	scrapeConferenceData(yearNum=year)
	storeConfs()

if __name__ == "__main__":
	#updateConfs()
	topTimesLoop()  # get all new times
